import _$1, { isObject as isObject$1, isFunction } from 'lodash';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
var _core_1 = _core.version;

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _shared = createCommonjsModule(function (module) {
var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: _core.version,
  mode:  'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});
});

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');

var Symbol = _global.Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
};

$exports.store = store;
});

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function (it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
var _addToUnscopables = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

var _iterStep = function (done, value) {
  return { value: value, done: !!done };
};

var _iterators = {};

var toString = {}.toString;

var _cof = function (it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function (it) {
  return _iobject(_defined(it));
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var _functionToString = _shared('native-function-to-string', Function.toString);

var _redefine = createCommonjsModule(function (module) {
var SRC = _uid('src');

var TO_STRING = 'toString';
var TPL = ('' + _functionToString).split(TO_STRING);

_core.inspectSource = function (it) {
  return _functionToString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === _global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    _hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    _hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
});
});

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function (fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function (it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function (index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes



var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var shared = _shared('keys');

var _sharedKey = function (key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (_has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)



var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
  return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



var IE_PROTO$1 = _sharedKey('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

var def = _objectDp.f;

var TAG = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if ( typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ( (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    _hide(proto, ITERATOR, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

var ITERATOR$1 = _wks('iterator');
var TO_STRING_TAG = _wks('toStringTag');
var ArrayValues = _iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = _global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = ArrayValues;
    if (explicit) for (key in es6_array_iterator) if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
  }
}

// 21.2.5.3 get RegExp.prototype.flags

var _flags = function () {
  var that = _anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

// 21.2.5.3 get RegExp.prototype.flags()
if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
  configurable: true,
  get: _flags
});

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  _redefine(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (_fails(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = _anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function (TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var at = _stringAt(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
var _advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG$1 = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
    // builtinTag case
    : ARG ? _cof(O)
    // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
var _regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (_classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var _regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: _regexpExec !== /./.exec
}, {
  exec: _regexpExec
});

var SPECIES = _wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

var _fixReWks = function (KEY, length, exec) {
  var SYMBOL = _wks(KEY);

  var DELEGATES_TO_SYMBOL = !_fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      _defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === _regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    _redefine(String.prototype, KEY, strfn);
    _hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

// @@match logic
_fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      if (!rx.global) return _regexpExecAbstract(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = _regexpExecAbstract(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

var doc = typeof document === 'undefined' ? {
  body: {},
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  activeElement: {
    blur: function blur() {},
    nodeName: ''
  },
  querySelector: function querySelector() {
    return null;
  },
  querySelectorAll: function querySelectorAll() {
    return [];
  },
  getElementById: function getElementById() {
    return null;
  },
  createEvent: function createEvent() {
    return {
      initEvent: function initEvent() {}
    };
  },
  createElement: function createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function setAttribute() {},
      getElementsByTagName: function getElementsByTagName() {
        return [];
      }
    };
  },
  location: {
    hash: ''
  }
} : document; // eslint-disable-line

var win = typeof window === 'undefined' ? {
  doc: doc,
  navigator: {
    userAgent: ''
  },
  location: {},
  history: {},
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  getComputedStyle: function getComputedStyle() {
    return {
      getPropertyValue: function getPropertyValue() {
        return '';
      }
    };
  },
  Image: function Image() {},
  Date: function Date() {},
  screen: {},
  setTimeout: function setTimeout() {},
  clearTimeout: function clearTimeout() {}
} : window; // eslint-disable-line

var scrollRec;
var script = {
  name: 'cmui-popup',
  props: {
    visible: {
      type: Boolean,
      default: false,
      intro: '弹层是否可见，需配合sync'
    },
    maskEvent: {
      type: Boolean,
      default: true,
      intro: '点击mask区域是否关闭弹层'
    },
    position: {
      type: String,
      default: 'right',
      intro: '弹出的方向，可以是top right bottom left center 中的任意一个或者多个'
    },
    targetStyle: {
      type: Object,
      default: null,
      intro: '弹层样式'
    },
    targetClass: {
      type: String,
      default: '',
      intro: '额外要加入的class用于修改样式'
    },
    stopPageScroll: {
      type: Boolean,
      default: true,
      intro: '是否阻止页面滚动'
    }
  },
  data: function data() {
    var userAgent = win.navigator.userAgent;
    var isIos = (userAgent.match(/iphone|ipad|ipad/ig) || '').length; // device.os === 'ios'

    var ua = /OS\s(\d+)/.exec(userAgent);
    return {
      useFlex: !(ua && isIos && parseInt(ua[1] < 9))
    };
  },
  computed: {
    _position: function _position() {
      return this.position.match(/(top|right|left|bottom|center)\b/g);
    },
    _contentStyle: function _contentStyle() {
      var width, height;

      var position = this._position.join(' ');

      switch (position) {
        case 'top':
          width = '100%'; // height="60%";

          break;

        case 'bottom':
          width = '100%'; // height="60%";

          break;

        case 'left':
          height = '100%';
          width = '80%';
          break;

        case 'right':
          height = '100%';
          width = '80%';
          break;
      }

      return {
        width: width,
        height: height
      };
    },
    selfVisible: {
      get: function get() {
        if (this.stopPageScroll && typeof document !== 'undefined') {
          if (this.visible) {
            scrollRec = document.documentElement.scrollTop || document.body.scrollTop;
            document.body.style.top = -scrollRec + 'px';
            document.body.classList.add('fixed-full');
          } else {
            document.body.style.removeProperty('top');
            document.body.classList.remove('fixed-full');
            document.documentElement.scrollTop = scrollRec;
          }
        }

        return this.visible;
      },
      set: function set(value) {
        this.$emit('update:visible', value); // this.visible = value

        return value;
      }
    }
  },
  mounted: function mounted() {},
  methods: {
    maskClick: function maskClick() {
      if (this.maskEvent) {
        this.selfVisible = false;
      }
    }
  }
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".cmui-popup[data-v-5bda0230]{z-index:1000}.cmui-popup .cmui-popup__mask[data-v-5bda0230]{background-color:rgba(0,0,0,.4)}.cmui-popup .cmui-popup__mask[data-v-5bda0230]:before{display:block;width:1px;height:1px;margin-left:-10px;background-color:rgba(0,0,0,.1);content:\".\"}.cmui-popup .cmui-popup__container[data-v-5bda0230]{pointer-events:none}.cmui-popup .cmui-popup__content[data-v-5bda0230]{max-width:100%;max-height:100%;pointer-events:auto}.cmui-popup .cmui-popup__bottom[data-v-5bda0230],.cmui-popup .cmui-popup__main[data-v-5bda0230],.cmui-popup .cmui-popup__top[data-v-5bda0230]{width:100%}.cmui-popup[data-v-5bda0230]{-webkit-transition-duration:.3s;transition-duration:.3s}.cmui-popup-enter .cmui-popup__mask[data-v-5bda0230],.cmui-popup-leave-to .cmui-popup__mask[data-v-5bda0230]{opacity:0}.cmui-popup-enter .cmui-popup__container.right[data-v-5bda0230],.cmui-popup-leave-to .cmui-popup__container.right[data-v-5bda0230]{-webkit-transform:translateX(100%);transform:translateX(100%)}.cmui-popup-enter .cmui-popup__container.top[data-v-5bda0230],.cmui-popup-leave-to .cmui-popup__container.top[data-v-5bda0230]{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.cmui-popup-enter .cmui-popup__container.bottom[data-v-5bda0230],.cmui-popup-leave-to .cmui-popup__container.bottom[data-v-5bda0230]{-webkit-transform:translateY(100%);transform:translateY(100%)}.cmui-popup-enter .cmui-popup__container.left[data-v-5bda0230],.cmui-popup-leave-to .cmui-popup__container.left[data-v-5bda0230]{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.cmui-popup-enter-active .cmui-popup__mask[data-v-5bda0230],.cmui-popup-leave-active .cmui-popup__mask[data-v-5bda0230]{-webkit-transition:opacity .4s;transition:opacity .4s}.cmui-popup-enter-active .cmui-popup__container[data-v-5bda0230],.cmui-popup-leave-active .cmui-popup__container[data-v-5bda0230]{-webkit-transition:-webkit-transform .4s;transition:-webkit-transform .4s;transition:transform .4s;transition:transform .4s, -webkit-transform .4s;transition:transform .4s,-webkit-transform .4s}.cmui-popup-enter-active .cmui-popup__container.center .cmui-popup__content[data-v-5bda0230]{-webkit-animation:dialog-zoom-in-data-v-5bda0230 .4s;animation:dialog-zoom-in-data-v-5bda0230 .4s}.cmui-popup-leave-active .cmui-popup__container.center .cmui-popup__content[data-v-5bda0230]{-webkit-animation:dialog-zoom-out-data-v-5bda0230 .4s;animation:dialog-zoom-out-data-v-5bda0230 .4s}@-webkit-keyframes dialog-zoom-in-data-v-5bda0230{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.1);transform:scale(1.1)}to{-webkit-transform:scale(1);transform:scale(1)}}@keyframes dialog-zoom-in-data-v-5bda0230{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.1);transform:scale(1.1)}to{-webkit-transform:scale(1);transform:scale(1)}}@-webkit-keyframes dialog-zoom-out-data-v-5bda0230{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.1);transform:scale(1.1)}to{-webkit-transform:scale(0);transform:scale(0)}}@keyframes dialog-zoom-out-data-v-5bda0230{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.1);transform:scale(1.1)}to{-webkit-transform:scale(0);transform:scale(0)}}";
styleInject(css_248z);

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
const __vue_script__ = script;
/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { name: "cmui-popup" } }, [
    _c(
      "div",
      {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.selfVisible,
            expression: "selfVisible"
          }
        ],
        staticClass: "cmui-popup fixed-full"
      },
      [
        _c(
          "div",
          {
            staticClass: "cmui-popup__mask abs-full",
            on: { click: _vm.maskClick }
          },
          [_vm._t("mask")],
          2
        ),
        _vm._v(" "),
        _c(
          "div",
          {
            staticClass: "cmui-popup__container abs-full flex-container",
            class: [_vm._position]
          },
          [
            _c(
              "div",
              {
                staticClass: "cmui-popup__content",
                class: [_vm.targetClass, { "flex-container-col": _vm.useFlex }],
                style: [_vm._contentStyle, _vm.targetStyle]
              },
              [
                _c(
                  "div",
                  { staticClass: "cmui-popup__top" },
                  [_vm._t("top")],
                  2
                ),
                _vm._v(" "),
                _c(
                  "div",
                  {
                    ref: "main",
                    staticClass: "cmui-popup__main flex1 scroll-container-y"
                  },
                  [_vm._t("default")],
                  2
                ),
                _vm._v(" "),
                _c(
                  "div",
                  { staticClass: "cmui-popup__bottom" },
                  [_vm._t("bottom")],
                  2
                )
              ]
            )
          ]
        )
      ]
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = "data-v-5bda0230";
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

var script$1 = {
  name: 'cmui-alert',
  methodName: 'alert',
  argumentsRole: function argumentsRole(options, args, CURRENT) {
    if (args.length > 1) {
      options.okFn = _$1.filter(args, _$1.isFunction)[0];
      options.callback = _$1.filter(args, _$1.isFunction)[1];

      var stringList = _$1.filter(args, function (item) {
        return _typeof(item).match(/string|number|boolean/);
      }).map(function (item) {
        return item.toString();
      });

      options.content = _$1.last(stringList);

      if (stringList.length > 1) {
        options.title = stringList[0];
      }
    } else {
      if (_typeof(args[0]).match(/string|number|boolean/)) {
        options.content = args[0];
      } else if (_$1.isObject(args[0])) {
        options = args[0];
      } else {
        return CURRENT;
      }
    }
  },
  components: {
    cmuiPopup: __vue_component__
  },
  props: {
    title: {
      type: String,
      default: '',
      intro: '标题'
    },
    content: {
      type: String,
      default: '',
      intro: '内容'
    },
    okText: {
      type: String,
      default: '确定',
      intro: '确定按钮文本'
    },
    okFn: {
      type: Function,
      default: function _default() {},
      intro: '点击确定触发的回调'
    },
    okStyle: {
      type: Object,
      default: null,
      intro: '确定按钮样式'
    },
    okDisable: {
      type: Boolean,
      default: false,
      intro: '禁用确定按钮'
    },
    okDisableStyle: {
      type: Object,
      default: null,
      intro: '确定按钮禁用样式'
    },
    visible: {
      type: Boolean,
      default: false,
      intro: '组件是否显示，需要使用sync'
    },
    targetClass: {
      type: String,
      default: '',
      intro: '容器附加class'
    }
  },
  data: function data() {
    return {
      bodyStyle: {
        'max-height': 'auto'
      }
    };
  },
  computed: {
    selfVisible: {
      get: function get() {
        return this.visible;
      },
      set: function set(value) {
        this.$emit('update:visible', value);
      }
    }
  },
  mounted: function mounted() {
    var dom = document.documentElement;
    this.bodyStyle['max-height'] = dom.clientHeight * 0.72 - 69 - parseInt(getComputedStyle(dom).fontSize) + 'px';
  },
  methods: {
    cancel: function cancel() {
      if (!this.okDisable) {
        this.selfVisible = false;
        typeof this.okFn === 'function' && this.okFn();
      }
    }
  }
};

/* script */
const __vue_script__$1 = script$1;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-popup",
    {
      staticClass: "cmui-alert cmui-dialog",
      attrs: {
        position: "center",
        visible: _vm.selfVisible,
        "mask-event": false,
        "target-class":
          "cmui-dialog__container cmui-alert__container " + _vm.targetClass
      },
      on: {
        "update:visible": function($event) {
          _vm.selfVisible = $event;
        }
      }
    },
    [
      _c("div", { staticClass: "cmui-dialog__content cmui-alert__content" }, [
        _vm.title || _vm.$slots.top
          ? _c(
              "div",
              { staticClass: "cmui-dialog__title cmui-alert__title" },
              [
                !_vm.$slots.top
                  ? _c("div", { domProps: { innerHTML: _vm._s(_vm.title) } })
                  : _vm._t("top")
              ],
              2
            )
          : _vm._e(),
        _vm._v(" "),
        _c("div", { staticClass: "cmui-dialog__warp cmui-alert__warp" }, [
          !_vm.content || _vm.$slots.default
            ? _c(
                "div",
                {
                  staticClass:
                    "cmui-dialog__body cmui-alert__body scroll-container-y",
                  style: _vm.bodyStyle
                },
                [_vm.$slots.default ? _vm._t("default") : _vm._e()],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.content || !_vm.$slots.default
            ? _c("div", {
                staticClass:
                  "cmui-dialog__body cmui-alert__body scroll-container-y",
                style: _vm.bodyStyle,
                domProps: { innerHTML: _vm._s(_vm.content) }
              })
            : _vm._e()
        ])
      ]),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "cmui-dialog__buttons cmui-alert__buttons" },
        [
          !_vm.$slots.bottom
            ? _c("div", {
                staticClass: "cmui-alert__button cmui-dialog__button",
                class: { okDisable: _vm.okDisable },
                style: _vm.okDisable ? _vm.okDisableStyle : _vm.okStyle,
                domProps: { innerHTML: _vm._s(_vm.okText) },
                on: {
                  click: function($event) {
                    return _vm.cancel()
                  }
                }
              })
            : _vm._t("bottom")
        ],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  const __vue_inject_styles__$1 = undefined;
  /* scoped */
  const __vue_scope_id__$1 = undefined;
  /* module identifier */
  const __vue_module_identifier__$1 = undefined;
  /* functional template */
  const __vue_is_functional_template__$1 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$1 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    false,
    undefined,
    undefined,
    undefined
  );

// 7.2.2 IsArray(argument)

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

var SPECIES$1 = _wks('species');

var _arraySpeciesConstructor = function (original) {
  var C;
  if (_isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
    if (_isObject(C)) {
      C = C[SPECIES$1];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


var _arraySpeciesCreate = function (original, length) {
  return new (_arraySpeciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex





var _arrayMethods = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || _arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = _toObject($this);
    var self = _iobject(O);
    var f = _ctx(callbackfn, that, 3);
    var length = _toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $find = _arrayMethods(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
_export(_export.P + _export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY);

function dialogInstall(Component) {
  var name = Component.name,
      props = Component.props,
      methodName = Component.methodName,
      argumentsRole = Component.argumentsRole;

  var defaultsOptions = _$1.mapValues(props, function (item) {
    return _$1.isFunction(item.default) ? item.default() : item.default;
  });

  var timeHandle;

  var id = "".concat(name, "-") + _$1.uniqueId();

  var CURRENT = null;

  var setCurrent = _$1.once(function (Vue) {
    var dom = document.createElement('div');
    dom.id = id;
    document.body.appendChild(dom);
    var Dialog = Vue.extend(Component);
    CURRENT = new Dialog().$mount(dom);
  });

  Component.install = function (Vue, Maple) {
    Vue.component(name, Component);

    function dialog() {
      setCurrent(Vue);
      var options = {};

      if (arguments.length) {
        var rs = argumentsRole(options, arguments, CURRENT);

        if (rs === CURRENT) {
          return CURRENT;
        }
      } else {
        return CURRENT;
      }

      options = _$1.defaults(_$1.find(arguments, _$1.isPlainObject), options, defaultsOptions);

      _$1.forEach(options, function (value, key) {
        CURRENT[key] = value;
      });

      CURRENT.visible = true;
      CURRENT.$on('update:visible', function (value) {
        CURRENT.visible = value;
      });

      if (typeof options.callback === 'function') {
        CURRENT.$nextTick(function () {
          options.callback(CURRENT.$el);
        });
      }

      timeHandle && clearTimeout(timeHandle);

      if (options.timeout) {
        timeHandle = setTimeout(function () {
          clearTimeout(timeHandle);
          CURRENT.cancel();
        }, options.timeout);
      }

      return CURRENT;
    }

    Vue.prototype[methodName] = dialog;

    if (Maple) {
      Maple[methodName] = dialog;
    }
  };

  return Component;
}

dialogInstall(__vue_component__$1);

var f$1 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$1
};

var gOPD = Object.getOwnPropertyDescriptor;

var f$2 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
	f: f$2
};

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */


var check = function (O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

var setPrototypeOf = _setProto.set;
var _inheritIfRequired = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return _objectKeysInternal(O, hiddenKeys);
};

var _objectGopn = {
	f: f$3
};

var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var space = '[' + _stringWs + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = _fails(function () {
    return !!_stringWs[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  _export(_export.P + _export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(_defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

var _stringTrim = exporter;

var gOPN = _objectGopn.f;
var gOPD$1 = _objectGopd.f;
var dP$1 = _objectDp.f;
var $trim = _stringTrim.trim;
var NUMBER = 'Number';
var $Number = _global[NUMBER];
var Base = $Number;
var proto$1 = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = _cof(_objectCreate(proto$1)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = _toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? _fails(function () { proto$1.valueOf.call(that); }) : _cof(that) != NUMBER)
        ? _inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = _descriptors ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key$1; keys.length > j; j++) {
    if (_has(Base, key$1 = keys[j]) && !_has($Number, key$1)) {
      dP$1($Number, key$1, gOPD$1(Base, key$1));
    }
  }
  $Number.prototype = proto$1;
  proto$1.constructor = $Number;
  _redefine(_global, NUMBER, $Number);
}

var cubic = function cubic(value) {
  return Math.pow(value, 3);
};

var easeInOutCubic = function easeInOutCubic(value) {
  return value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;
};

var script$2 = {
  name: 'cmui-backtop',
  props: {
    visibilityHeight: {
      type: Number,
      default: 200
    },
    target: {
      type: String,
      default: ''
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    }
  },
  data: function data() {
    return {
      el: null,
      container: null,
      visible: false
    };
  },
  computed: {
    styleBottom: function styleBottom() {
      return "".concat(this.bottom, "px");
    },
    styleRight: function styleRight() {
      return "".concat(this.right, "px");
    }
  },
  mounted: function mounted() {
    this.init();
    this.throttledScrollHandler = _$1.throttle(this.onScroll, 300);
    this.container.addEventListener('scroll', this.throttledScrollHandler);
  },
  beforeDestroy: function beforeDestroy() {
    this.container.removeEventListener('scroll', this.throttledScrollHandler);
  },
  methods: {
    init: function init() {
      this.container = document;
      this.el = document.documentElement;

      if (this.target) {
        this.el = document.querySelector(this.target);

        if (!this.el) {
          throw new Error("target is not existed: ".concat(this.target));
        }

        this.container = this.el;
      }
    },
    onScroll: function onScroll() {
      var scrollTop = this.el.scrollTop;
      this.visible = scrollTop >= this.visibilityHeight;
    },
    handleClick: function handleClick(e) {
      this.scrollToTop();
      this.$emit('click', e);
    },
    scrollToTop: function scrollToTop() {
      var targetValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var el = this.el;
      var beginTime = Date.now();
      var beginValue = el.scrollTop;

      var rAF = window.requestAnimationFrame || function (func) {
        return setTimeout(func, 16);
      };

      var frameFunc = function frameFunc() {
        var progress = (Date.now() - beginTime) / 500;

        if (progress < 1) {
          el.scrollTop = (beginValue - targetValue) * (1 - easeInOutCubic(progress)) + targetValue;
          rAF(frameFunc);
        } else {
          el.scrollTop = targetValue;
        }
      };

      rAF(frameFunc);
    }
  }
};

var css_248z$1 = ".cmui-fade-in-linear-enter-active[data-v-7cc2281d],.cmui-fade-in-linear-leave-active[data-v-7cc2281d]{-webkit-transition:opacity .2s linear;transition:opacity .2s linear}.cmui-fade-in-linear-enter[data-v-7cc2281d],.cmui-fade-in-linear-leave-active[data-v-7cc2281d],.cmui-fade-in-linear-leave[data-v-7cc2281d]{opacity:0}.cmui-fade-in-enter-active[data-v-7cc2281d],.cmui-fade-in-leave-active[data-v-7cc2281d]{-webkit-transition:all .3s cubic-bezier(.55,0,.1,1);transition:all .3s cubic-bezier(.55,0,.1,1)}.cmui-fade-in-enter[data-v-7cc2281d],.cmui-fade-in-leave-active[data-v-7cc2281d]{opacity:0}.cmui-backtop[data-v-7cc2281d]{width:40px;height:40px;border-radius:50%;color:#678c12;box-shadow:0 0 6px rgba(0,0,0,.12);cursor:pointer;z-index:5}";
styleInject(css_248z$1);

/* script */
const __vue_script__$2 = script$2;
/* template */
var __vue_render__$2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { name: "cmui-fade-in" } }, [
    _vm.visible
      ? _c(
          "div",
          {
            staticClass:
              "cmui-backtop flex-container center fs-20 pos-f bg-white",
            style: {
              right: _vm.styleRight,
              bottom: _vm.styleBottom
            },
            on: {
              click: function($event) {
                $event.stopPropagation();
                return _vm.handleClick($event)
              }
            }
          },
          [
            _vm._t("default", [
              _c("i", { staticClass: "baseIcon baseIcon-fold" })
            ])
          ],
          2
        )
      : _vm._e()
  ])
};
var __vue_staticRenderFns__$2 = [];
__vue_render__$2._withStripped = true;

  /* style */
  const __vue_inject_styles__$2 = undefined;
  /* scoped */
  const __vue_scope_id__$2 = "data-v-7cc2281d";
  /* module identifier */
  const __vue_module_identifier__$2 = undefined;
  /* functional template */
  const __vue_is_functional_template__$2 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$2 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$2.install = function (Vue, Maple) {
  Vue.component(__vue_component__$2.name, __vue_component__$2);
};

__vue_component__.install = function (Vue, Maple) {
  Vue.component(__vue_component__.name, __vue_component__);
};

var script$3 = {
  name: 'cmui-actions',
  methodName: 'actions',
  argumentsRole: function argumentsRole(options, args, CURRENT) {
    options.items = [];

    if (args.length > 1) {
      var fnList = _$1.filter(args, _$1.isFunction);

      options.selectFn = fnList[0];
      options.cancelFn = fnList[1];

      var styleList = _$1.filter(args, _$1.isPlainObject);

      if (styleList.length === 1) {
        options.itemStyle = styleList[0];
      }

      var stringList = _$1.filter(args, function (item) {
        return _typeof(item).match(/string|number|boolean/);
      }).map(function (item) {
        return item.toString();
      });

      stringList.forEach(function (item, index) {
        var rs = {
          text: item
        };

        var style = _$1.get(styleList, index);

        if (style) {
          rs.style = style;
        }

        options.items.push(rs);
      });

      var arrArg = _$1.find(args, _$1.isArray);

      if (arrArg) {
        options.items = arrArg;
      }
    } else {
      if (_typeof(args[0]).match(/string|number|boolean/)) {
        options.items.push({
          text: args[0]
        });
      } else if (_$1.isArray(args[0])) {
        options.items = args[0];
      } else if (_$1.isFunction(args[0])) {
        return this.argumentsRole(args[0]());
      }
    }
  },
  props: {
    items: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '每一项的文本内容，用[String...]的形式表示'
    },
    cancelText: {
      type: String,
      default: '取消',
      intro: '取消按钮的文本'
    },
    cancelFn: {
      type: Function,
      default: null,
      intro: '取消按钮的事件'
    },
    cancelStyle: {
      type: Object,
      default: null,
      intro: '取消按钮的样式'
    },
    itemStyle: {
      type: Object,
      default: null,
      intro: '每一项的样式'
    },
    selectFn: {
      type: Function,
      default: null,
      intro: '每一项被选择时的事件'
    },
    activeIndex: {
      type: Number,
      default: -1,
      intro: '被选中项的索引'
    },
    title: {
      type: String,
      default: '',
      intro: '标题内容'
    },
    visible: {
      type: Boolean,
      default: false,
      intro: '是否显示组件，需要使用sync'
    }
  },
  compontents: {
    cmuiPopup: __vue_component__
  },
  computed: {
    selfVisible: {
      get: function get() {
        return this.visible;
      },
      set: function set(value) {
        this.$emit('update:visible', value);
      }
    }
  },
  methods: {
    cancel: function cancel() {
      this.selfVisible = false;
      this.$emit('cancel', this);
      _$1.isFunction(this.cancelFn) && this.cancelFn();
    },
    itemEvent: function itemEvent(item, index) {
      this.selfVisible = false;
      this.$emit('select', item, index, this);
      _$1.isFunction(this.selectFn) && this.selectFn(item, index);
    },
    getActionText: function getActionText(value, index) {
      if (_$1.isFunction(value)) {
        return this.getActionText(value());
      } else if (_$1.isObject(value)) {
        value.text = value.text || index;
        return String(value.text);
      } else {
        return String(value);
      }
    },
    getActionStyle: function getActionStyle(itemStyle, baseStyle) {
      return _$1.defaults(itemStyle, baseStyle);
    }
  }
};

/* script */
const __vue_script__$3 = script$3;

/* template */
var __vue_render__$3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-popup",
    {
      staticClass: "cmui-actions ",
      attrs: {
        position: "bottom",
        visible: _vm.selfVisible,
        "target-style": { height: "auto" },
        "target-class": "cmui-actions__container"
      },
      on: {
        "update:visible": function($event) {
          _vm.selfVisible = $event;
        }
      }
    },
    [
      _vm.title
        ? _c("div", {
            staticClass: "cmui-actions__title",
            attrs: { slot: "top" },
            domProps: { innerHTML: _vm._s(_vm.title) },
            slot: "top"
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "cmui-actions__group" },
        _vm._l(_vm.items, function(item, index) {
          return _c("div", {
            key: index,
            staticClass: "cmui-actions__button",
            class: { active: _vm.activeIndex === index },
            style: _vm.getActionStyle(item.style, _vm.itemStyle),
            domProps: { innerHTML: _vm._s(_vm.getActionText(item, index)) },
            on: {
              click: function($event) {
                return _vm.itemEvent(item, index)
              }
            }
          })
        }),
        0
      ),
      _vm._v(" "),
      _vm.cancelText
        ? _c(
            "div",
            {
              staticClass: "cmui-actions__cancel",
              attrs: { slot: "bottom" },
              slot: "bottom"
            },
            [
              _c("div", {
                staticClass: "cmui-actions__button",
                style: _vm.cancelStyle,
                domProps: { innerHTML: _vm._s(_vm.cancelText) },
                on: { click: _vm.cancel }
              })
            ]
          )
        : _vm._e()
    ]
  )
};
var __vue_staticRenderFns__$3 = [];
__vue_render__$3._withStripped = true;

  /* style */
  const __vue_inject_styles__$3 = undefined;
  /* scoped */
  const __vue_scope_id__$3 = undefined;
  /* module identifier */
  const __vue_module_identifier__$3 = undefined;
  /* functional template */
  const __vue_is_functional_template__$3 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$3 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    false,
    undefined,
    undefined,
    undefined
  );

dialogInstall(__vue_component__$3);

var script$4 = {
  name: 'cmui-confirm',
  methodName: 'confirm',
  argumentsRole: function argumentsRole(options, args, CURRENT) {
    if (args.length > 1) {
      var fnList = _$1.filter(args, _$1.isFunction);

      options.okFn = fnList[0];
      options.cancelFn = fnList[1];
      options.callback = fnList[2];

      var stringList = _$1.filter(args, function (item) {
        return _typeof(item).match(/string|number|boolean/);
      }).map(function (item) {
        return item.toString();
      });

      options.content = _$1.last(stringList);

      if (stringList.length > 1) {
        options.title = stringList[0];
      }
    } else {
      if (_typeof(args[0]).match(/string|number|boolean/)) {
        options.content = args[0];
      } else if (_$1.isObject(args[0])) {
        options = args[0];
      } else {
        return CURRENT;
      }
    }
  },
  props: {
    title: {
      type: String,
      default: '',
      intro: '标题(支持html)'
    },
    content: {
      type: String,
      default: '',
      intro: '内容(支持html)'
    },
    okText: {
      type: String,
      default: '确定',
      intro: '确认按钮文字'
    },
    okFn: {
      type: Function,
      default: function _default() {},
      intro: '点击确认按钮执行的事件'
    },
    okStyle: {
      type: Object,
      default: null,
      intro: '确认按钮样式'
    },
    cancelText: {
      type: String,
      default: '取消',
      intro: '确认按钮是否可用'
    },
    cancelStyle: {
      type: Object,
      default: null,
      intro: '确认按钮不可用时的样式'
    },
    cancelFn: {
      type: Function,
      default: function _default() {},
      intro: '取消按钮文本'
    },
    okDisable: {
      type: Boolean,
      default: false,
      intro: '取消按钮样式'
    },
    okDisableStyle: {
      type: Object,
      default: null,
      intro: '点击取消按钮触发的回调'
    },
    cancelDisable: {
      type: Boolean,
      default: false,
      intro: '禁用取消按钮'
    },
    cancelDisableStyle: {
      type: Object,
      default: null,
      intro: '禁用取消按钮时的样式'
    },
    visible: {
      type: Boolean,
      default: false,
      intro: '弹窗是否可见'
    },
    targetClass: {
      type: String,
      default: '',
      intro: '为组件设置额外的class，用于修改样式'
    },
    reverse: {
      type: Boolean,
      default: false,
      intro: '翻转取消和确定按钮位置'
    }
  },
  compontents: {
    cmuiPopup: __vue_component__
  },
  data: function data() {
    return {
      bodyStyle: {
        'max-height': 'auto'
      }
    };
  },
  computed: {
    selfVisible: {
      get: function get() {
        return this.visible;
      },
      set: function set(value) {
        this.$emit('update:visible', value);
      }
    }
  },
  mounted: function mounted() {
    var dom = document.documentElement;
    this.bodyStyle['max-height'] = dom.clientHeight * 0.72 - 69 - parseInt(getComputedStyle(dom).fontSize) + 'px';
  },
  methods: {
    cancel: function cancel() {
      this.selfVisible = false;
      typeof this.cancelFn === 'function' && this.cancelFn();
    },
    ok: function ok() {
      this.selfVisible = false;
      typeof this.okFn === 'function' && this.okFn();
    }
  }
};

/* script */
const __vue_script__$4 = script$4;

/* template */
var __vue_render__$4 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-popup",
    {
      staticClass: "cmui-confirm cmui-dialog",
      attrs: {
        position: "center",
        "mask-event": false,
        visible: _vm.selfVisible,
        "target-class":
          "cmui-dialog__container cmui-confirm__container " + _vm.targetClass
      },
      on: {
        "update:visible": function($event) {
          _vm.selfVisible = $event;
        }
      }
    },
    [
      _c("div", { staticClass: "cmui-dialog__content cmui-confirm__content" }, [
        _vm.title || _vm.$slots.top
          ? _c(
              "div",
              { staticClass: "cmui-dialog__title cmui-confirm__title" },
              [
                !_vm.$slots.top
                  ? _c("div", { domProps: { innerHTML: _vm._s(_vm.title) } })
                  : _vm._t("top")
              ],
              2
            )
          : _vm._e(),
        _vm._v(" "),
        _c("div", { staticClass: "cmui-dialog__warp cmui-confirm__warp" }, [
          !_vm.content || _vm.$slots.default
            ? _c(
                "div",
                {
                  staticClass:
                    "cmui-dialog__body cmui-alert__body scroll-container-y",
                  style: _vm.bodyStyle
                },
                [_vm.$slots.default ? _vm._t("default") : _vm._e()],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.content || !_vm.$slots.default
            ? _c("div", {
                staticClass:
                  "cmui-dialog__body cmui-alert__body scroll-container-y",
                style: _vm.bodyStyle,
                domProps: { innerHTML: _vm._s(_vm.content) }
              })
            : _vm._e()
        ])
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass:
            "cmui-dialog__buttons cmui-confirm__buttons flex-container",
          class: { reverse: _vm.reverse },
          attrs: { slot: "bottom" },
          slot: "bottom"
        },
        [
          !_vm.$slots.bottom
            ? [
                _c("div", {
                  staticClass:
                    "cmui-confirm__button ok cmui-dialog__button flex1",
                  class: { okDisable: _vm.okDisable },
                  style: _vm.okDisable ? _vm.okDisableStyle : _vm.okStyle,
                  domProps: { innerHTML: _vm._s(_vm.okText) },
                  on: {
                    click: function($event) {
                      !_vm.okDisable && _vm.ok();
                    }
                  }
                }),
                _vm._v(" "),
                _c("div", {
                  staticClass:
                    "cmui-confirm__button cancel cmui-dialog__button flex1",
                  class: { cancelDisable: _vm.cancelDisable },
                  style: _vm.cancelDisable
                    ? _vm.cancelDisableStyle
                    : _vm.cancelStyle,
                  domProps: { innerHTML: _vm._s(_vm.cancelText) },
                  on: {
                    click: function($event) {
                      !_vm.cancelDisable && _vm.cancel();
                    }
                  }
                })
              ]
            : _vm._t("bottom")
        ],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$4 = [];
__vue_render__$4._withStripped = true;

  /* style */
  const __vue_inject_styles__$4 = undefined;
  /* scoped */
  const __vue_scope_id__$4 = undefined;
  /* module identifier */
  const __vue_module_identifier__$4 = undefined;
  /* functional template */
  const __vue_is_functional_template__$4 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$4 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    false,
    undefined,
    undefined,
    undefined
  );

dialogInstall(__vue_component__$4);

var script$5 = {
  name: 'cmui-notice',
  methodName: 'notice',
  argumentsRole: function argumentsRole(options, args, CURRENT) {
    if (args.length > 1) {
      options.callback = _$1.filter(args, _$1.isFunction)[0];

      var stringList = _$1.filter(args, function (item) {
        return _typeof(item).match(/string|number|boolean/);
      }).map(function (item) {
        return item.toString();
      });

      options.content = stringList[0];

      if (stringList.length > 1) {
        options.timeout = _$1.last(_$1.filter(args, _$1.isNumber)) | 0;
      }
    } else {
      if (_typeof(args[0]).match(/string|number|boolean/)) {
        options.content = args[0];
      } else if (_$1.isObject(args[0])) {
        options = args[0];
      } else {
        return CURRENT;
      }
    }
  },
  components: {
    cmuiPopup: __vue_component__
  },
  props: {
    content: {
      type: String,
      default: '',
      intro: '弹出的内容'
    },
    className: {
      type: String,
      default: '',
      intro: '内容区域的class'
    },
    timeout: {
      type: Number,
      default: 3000,
      intro: '展示时间设置为0则不展示'
    },
    closeFn: {
      type: Function,
      default: function _default() {},
      intro: '关闭时的回调'
    },
    targetClass: {
      type: String,
      default: '',
      intro: '整体的class'
    },
    visible: {
      type: Boolean,
      default: false,
      intro: '是否可见需要配合sync'
    }
  },
  data: function data() {
    var dom = document.documentElement;
    return {
      bodyStyle: {
        'max-height': dom.clientHeight * 0.72 - 69 - parseInt(getComputedStyle(dom).fontSize) + 'px'
      }
    };
  },
  computed: {
    selfVisible: {
      get: function get() {
        return this.visible;
      },
      set: function set(value) {
        this.$emit('update:visible', value);
      }
    }
  },
  methods: {
    cancel: function cancel() {
      this.selfVisible = false;
      typeof this.closeFn === 'function' && this.closeFn();
    }
  }
};

/* script */
const __vue_script__$5 = script$5;

/* template */
var __vue_render__$5 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-popup",
    {
      staticClass: "cmui-notice cmui-dialog",
      attrs: {
        position: "center",
        visible: _vm.selfVisible,
        "mask-event": false,
        "target-class":
          "cmui-notice__container cmui-dialog__container " + _vm.targetClass
      },
      on: {
        "update:visible": function($event) {
          _vm.selfVisible = $event;
        }
      }
    },
    [
      _c(
        "div",
        { staticClass: "cmui-dialog__warp cmui-notice__warp text-center" },
        [
          _vm.content
            ? _c("div", {
                staticClass: "cmui-dialog__body cmui-notice__body",
                class: _vm.className,
                style: _vm.bodyStyle,
                domProps: { innerHTML: _vm._s(_vm.content) }
              })
            : _vm._e()
        ]
      )
    ]
  )
};
var __vue_staticRenderFns__$5 = [];
__vue_render__$5._withStripped = true;

  /* style */
  const __vue_inject_styles__$5 = undefined;
  /* scoped */
  const __vue_scope_id__$5 = undefined;
  /* module identifier */
  const __vue_module_identifier__$5 = undefined;
  /* functional template */
  const __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$5 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    false,
    undefined,
    undefined,
    undefined
  );

dialogInstall(__vue_component__$5);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
function getScroll(target, top) {
  var prop = top ? 'pageYOffset' : 'pageXOffset';
  var method = top ? 'scrollTop' : 'scrollLeft';
  var ret = target[prop];

  if (typeof ret !== 'number') {
    ret = window.document.documentElement[method];
  }

  return ret;
}

function getOffset(element) {
  var rect = element.getBoundingClientRect();
  var scrollTop = getScroll(window, true);
  var scrollLeft = getScroll(window);
  var docEl = window.document.body;
  var clientTop = docEl.clientTop || 0;
  var clientLeft = docEl.clientLeft || 0;
  return {
    top: rect.top + scrollTop - clientTop,
    left: rect.left + scrollLeft - clientLeft
  };
}

var script$6 = {
  name: 'cmui-affix',
  props: {
    top: {
      type: Number,
      default: 0,
      intro: '触发时距离顶部的距离，用PX表示'
    },
    bottom: {
      type: Number,
      default: -Infinity,
      intro: '触发时距离底部的距离，用PX表示'
    }
  },
  data: function data() {
    return {
      affix: false,
      styles: {},
      containerHeight: null
    };
  },
  computed: {
    offsetType: function offsetType() {
      return this.bottom >= 0 ? 'bottom' : 'top';
    }
  },
  mounted: function mounted() {
    window.addEventListener('scroll', this.handleScroll, false);
    window.addEventListener('resize', this.handleScroll, false);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('scroll', this.handleScroll, false);
    window.removeEventListener('resize', this.handleScroll, false);
  },
  methods: {
    handleScroll: function handleScroll() {
      var affix = this.affix;
      var scrollTop = getScroll(window, true);
      var elOffset = getOffset(this.$el);
      var windowHeight = window.innerHeight;
      var elHeight = this.$el.getElementsByTagName('div')[0].offsetHeight; // Fixed Top

      if (elOffset.top - this.top < scrollTop && this.offsetType === 'top' && !affix) {
        this.affix = true;
        this.styles = {
          top: "".concat(this.top, "px"),
          left: "".concat(elOffset.left, "px"),
          width: "".concat(this.$el.offsetWidth, "px"),
          position: 'fixed'
        };

        if (!this.$el.style.height) {
          this.$el.style.height = "".concat(elHeight, "px");
        } else {
          this.containerHeight = this.$el.style.height;
        }

        this.$emit('change', true);
      } else if (elOffset.top - this.top >= scrollTop && this.offsetType === 'top' && affix) {
        this.affix = false;
        this.styles = null;
        this.$el.style.height = this.containerHeight ? "".concat(this.containerHeight, "px") : null;
        this.$emit('change', false);
      } // Fixed Bottom


      if (elOffset.top + this.bottom + elHeight > scrollTop + windowHeight && this.offsetType === 'bottom' && !affix) {
        this.affix = true;
        this.styles = {
          bottom: "".concat(this.bottom, "px"),
          left: "".concat(elOffset.left, "px"),
          width: "".concat(this.$el.offsetWidth, "px"),
          position: 'fixed',
          height: "".concat(elHeight, "px")
        };

        if (!this.$el.style.height) {
          this.$el.style.height = "".concat(elHeight, "px");
        } else {
          this.containerHeight = this.$el.style.height;
        }

        this.$emit('change', true);
      } else if (elOffset.top + this.bottom + elHeight <= scrollTop + windowHeight && this.offsetType === 'bottom' && affix) {
        this.affix = false;
        this.styles = null;
        this.$el.style.height = this.containerHeight ? "".concat(this.containerHeight, "px") : null;
        this.$emit('change', false);
      }
    }
  }
};

/* script */
const __vue_script__$6 = script$6;

/* template */
var __vue_render__$6 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { staticClass: "cmui-affix-warp", class: { warpActive: _vm.affix } },
    [
      _c(
        "div",
        {
          staticClass: "cmui-affix",
          class: { affixActive: _vm.affix },
          style: _vm.styles
        },
        [_vm._t("default")],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$6 = [];
__vue_render__$6._withStripped = true;

  /* style */
  const __vue_inject_styles__$6 = undefined;
  /* scoped */
  const __vue_scope_id__$6 = undefined;
  /* module identifier */
  const __vue_module_identifier__$6 = undefined;
  /* functional template */
  const __vue_is_functional_template__$6 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$6 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
    __vue_inject_styles__$6,
    __vue_script__$6,
    __vue_scope_id__$6,
    __vue_is_functional_template__$6,
    __vue_module_identifier__$6,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$6.install = function (Vue, Maple) {
  Vue.component(__vue_component__$6.name, __vue_component__$6);
};

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$7 = {
  name: 'cmui-captcha',
  props: {
    length: {
      type: Number,
      default: 4,
      intro: '允许输入的最大长度'
    },
    type: {
      type: String,
      default: 'number',
      intro: '输入的类型，可选项为number|string'
    },
    hide: {
      type: Boolean,
      default: false,
      intro: '是否隐藏输入文本并用点表示'
    },
    value: {
      type: String,
      default: '',
      intro: 'v-model绑定的内容'
    }
  },
  data: function data() {
    return {
      activeIndex: -1
    };
  },
  computed: {
    selfValue: {
      get: function get() {
        if (this.type === 'number') {
          if (!/^\d+$/.test(this.value) && this.value.length) {
            return '';
          }
        }

        return this.value;
      },
      set: function set(value) {
        if (this.type === 'number') {
          if (!/^\d+$/.test(value) && value.length) {
            return;
          }
        }

        if (value.length >= this.length) {
          this.inputEnd();
        }

        this.setActiveIndex();
        this.$emit('input', value);
      }
    }
  },
  // watch: {
  //   value: {
  //     immediate: true,
  //     handler (newValue, oldValue) {
  //       if (this.type === 'number') {
  //         if (!/^\d+$/.test(newValue) && newValue.length) {
  //           this.value = /^\d+$/.test(oldValue) ? oldValue : ''
  //           return
  //         }
  //       }
  //       if (newValue.length >= this.length) {
  //         this.inputEnd()
  //       }
  //       this.setActiveIndex()
  //     }
  //   }
  // },
  created: function created() {
    this.setActiveIndex(-1);
  },
  methods: {
    inputStart: function inputStart() {
      this.$refs.input.focus();
      this.setActiveIndex();
    },
    inputEnd: function inputEnd() {
      this.$refs.input.blur();
      this.$emit('inputEnd', this.value, this);
    },
    inputBlur: function inputBlur() {
      this.setActiveIndex(-1);
    },
    setActiveIndex: function setActiveIndex(index) {
      this.activeIndex = index ? -1 : this.value.length;
    }
  }
};

var css_248z$2 = ".cmui-captcha__input[data-v-5fff07ca]{position:absolute;left:-99.99rem;opacity:0;-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";filter:alpha(opacity=0)}.cmui-captcha__item.active .cmui-captcha__line[data-v-5fff07ca]{height:50%;width:1px}";
styleInject(css_248z$2);

/* script */
const __vue_script__$7 = script$7;
/* template */
var __vue_render__$7 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "cmui-captcha" }, [
    _c(
      "div",
      {
        staticClass: "cmui-captcha__warp flex-container center",
        on: { click: _vm.inputStart }
      },
      _vm._l(_vm.length, function(item, index) {
        return _c(
          "div",
          {
            key: index,
            staticClass: "cmui-captcha__item ratio-container pos-r",
            class: { active: index === _vm.activeIndex }
          },
          [
            _c(
              "span",
              { staticClass: "flex-container center" },
              [
                _vm.hide && index < _vm.selfValue.length
                  ? _c("span", { staticClass: "cmui-captcha__dot" })
                  : [_vm._v(_vm._s(_vm.selfValue[index]))],
                _vm._v(" "),
                index === _vm.activeIndex
                  ? _c("span", { staticClass: "cmui-captcha__line" })
                  : _vm._e()
              ],
              2
            )
          ]
        )
      }),
      0
    ),
    _vm._v(" "),
    _c("form", { attrs: { action: "" } }, [
      (_vm.type === "number" ? "tel" : "text") === "checkbox"
        ? _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.selfValue,
                expression: "selfValue"
              }
            ],
            ref: "input",
            staticClass: "cmui-captcha__input",
            attrs: { name: "", type: "checkbox" },
            domProps: {
              checked: Array.isArray(_vm.selfValue)
                ? _vm._i(_vm.selfValue, null) > -1
                : _vm.selfValue
            },
            on: {
              blur: _vm.inputBlur,
              change: function($event) {
                var $$a = _vm.selfValue,
                  $$el = $event.target,
                  $$c = $$el.checked ? true : false;
                if (Array.isArray($$a)) {
                  var $$v = null,
                    $$i = _vm._i($$a, $$v);
                  if ($$el.checked) {
                    $$i < 0 && (_vm.selfValue = $$a.concat([$$v]));
                  } else {
                    $$i > -1 &&
                      (_vm.selfValue = $$a
                        .slice(0, $$i)
                        .concat($$a.slice($$i + 1)));
                  }
                } else {
                  _vm.selfValue = $$c;
                }
              }
            }
          })
        : (_vm.type === "number" ? "tel" : "text") === "radio"
        ? _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.selfValue,
                expression: "selfValue"
              }
            ],
            ref: "input",
            staticClass: "cmui-captcha__input",
            attrs: { name: "", type: "radio" },
            domProps: { checked: _vm._q(_vm.selfValue, null) },
            on: {
              blur: _vm.inputBlur,
              change: function($event) {
                _vm.selfValue = null;
              }
            }
          })
        : _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.selfValue,
                expression: "selfValue"
              }
            ],
            ref: "input",
            staticClass: "cmui-captcha__input",
            attrs: { name: "", type: _vm.type === "number" ? "tel" : "text" },
            domProps: { value: _vm.selfValue },
            on: {
              blur: _vm.inputBlur,
              input: function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.selfValue = $event.target.value;
              }
            }
          })
    ])
  ])
};
var __vue_staticRenderFns__$7 = [];
__vue_render__$7._withStripped = true;

  /* style */
  const __vue_inject_styles__$7 = undefined;
  /* scoped */
  const __vue_scope_id__$7 = "data-v-5fff07ca";
  /* module identifier */
  const __vue_module_identifier__$7 = undefined;
  /* functional template */
  const __vue_is_functional_template__$7 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$7 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
    __vue_inject_styles__$7,
    __vue_script__$7,
    __vue_scope_id__$7,
    __vue_is_functional_template__$7,
    __vue_module_identifier__$7,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$7.install = function (Vue, Maple) {
  Vue.component(__vue_component__$7.name, __vue_component__$7);
};

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$8 = {
  name: 'cmui-collapse',
  componentName: 'CMUICollapse',
  props: {
    onlyone: {
      type: Boolean,
      default: false,
      intro: '是否只打开一个菜单'
    },
    activeIndex: {
      type: [Array, Number],
      default: function _default() {
        return [];
      },
      intro: '需要打开的索引，使用数组可以打开多个'
    }
  },
  data: function data() {
    return {
      activeNames: [].concat(this.activeIndex)
    };
  },
  watch: {
    activeIndex: function activeIndex(value) {
      this.activeNames = [].concat(value);
    }
  },
  created: function created() {
    this.$on('item-click', this.itemClick);
  },
  methods: {
    setActiveNames: function setActiveNames(activeNames) {
      activeNames = [].concat(activeNames); // let value = this.onlyone ? activeNames[0] : activeNames

      this.activeNames = activeNames;
    },
    itemClick: function itemClick(item) {
      if (this.onlyone) {
        this.setActiveNames((this.activeNames[0] || this.activeNames[0] === 0) && this.activeNames[0] === item.name ? '' : item.name);
      } else {
        var activeNames = this.activeNames.slice(0);
        var index = activeNames.indexOf(item.name);

        if (index > -1) {
          activeNames.splice(index, 1);
        } else {
          activeNames.push(item.name);
        }

        this.setActiveNames(activeNames);
      }
    }
  }
};

var css_248z$3 = ".cmui-collapse-item__body[data-v-de034bd4],.cmui-collapse-item__header[data-v-de034bd4]{border:1px solid transparent;margin-bottom:-1px}.cmui-collapse-item:last-child .cmui-collapse-item__body[data-v-de034bd4]{margin-bottom:0}.cmui-collapse-item__bodyWarp[data-v-de034bd4]{will-change:height;overflow:hidden}.collapse-transition[data-v-de034bd4]{-webkit-transition:height .3s ease-in-out;transition:height .3s ease-in-out}";
styleInject(css_248z$3);

/* script */
const __vue_script__$8 = script$8;
/* template */
var __vue_render__$8 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "cmui-collapse" }, [_vm._t("default")], 2)
};
var __vue_staticRenderFns__$8 = [];
__vue_render__$8._withStripped = true;

  /* style */
  const __vue_inject_styles__$8 = undefined;
  /* scoped */
  const __vue_scope_id__$8 = "data-v-de034bd4";
  /* module identifier */
  const __vue_module_identifier__$8 = undefined;
  /* functional template */
  const __vue_is_functional_template__$8 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$8 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
    __vue_inject_styles__$8,
    __vue_script__$8,
    __vue_scope_id__$8,
    __vue_is_functional_template__$8,
    __vue_module_identifier__$8,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$8.install = function (Vue, Maple) {
  Vue.component(__vue_component__$8.name, __vue_component__$8);
};

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $find$1 = _arrayMethods(6);
var KEY$1 = 'findIndex';
var forced$1 = true;
// Shouldn't skip holes
if (KEY$1 in []) Array(1)[KEY$1](function () { forced$1 = false; });
_export(_export.P + _export.F * forced$1, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY$1);

function _broadcast(componentName, eventName, params) {
  this.$children.forEach(function (child) {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      _broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}

var basemixin = {
  methods: {
    dispatch: function dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }

      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast: function broadcast(componentName, eventName, params) {
      _broadcast.call(this, componentName, eventName, params);
    },
    getParent: function getParent(componentName) {
      var parent = this.$parent;

      while (_$1.get(parent, '$options._componentTag') !== componentName) {
        parent = _$1.get(parent, '$parent');

        if (!parent) {
          break;
        }
      }

      return parent;
    }
  }
};

var CollapseTransition = {
  functional: true,
  render: function render(h, context) {
    var data = {
      on: {
        beforeEnter: function beforeEnter(el) {
          el.classList.add('collapse-transition');

          if (!el.dataset) {
            el.dataset = {};
          }

          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.style.height = '0';
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        },
        enter: function enter(el) {
          el.dataset.oldOverflow = el.style.overflow;

          if (el.scrollHeight !== 0) {
            el.style.height = el.scrollHeight + 'px';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.height = '';
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }

          el.style.overflow = 'hidden';
        },
        afterEnter: function afterEnter(el) {
          // for safari: remove class then reset height is necessary
          el.classList.remove('collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
        },
        beforeLeave: function beforeLeave(el) {
          if (!el.dataset) {
            el.dataset = {};
          }

          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.height = el.scrollHeight + 'px';
          el.style.overflow = 'hidden';
        },
        leave: function leave(el) {
          if (el.scrollHeight !== 0) {
            // for safari: add class after set height, or it will jump to zero height suddenly, weired
            el.classList.add('collapse-transition');
            el.style.height = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        },
        afterLeave: function afterLeave(el) {
          el.classList.remove('collapse-transition');
          el.style.height = '';
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
      }
    };
    return h('transition', data, context.children);
  }
};

var script$9 = {
  name: 'cmui-collapse-item',
  componentName: 'CMUICollapseItem',
  components: {
    CollapseTransition: CollapseTransition
  },
  mixins: [basemixin],
  props: {
    title: {
      type: String,
      default: '',
      intro: '标题文本'
    }
  },
  data: function data() {
    var _this = this;

    return {
      name: _$1.findIndex(this.$parent.$children, function (item) {
        return item === _this;
      })
    };
  },
  computed: {
    isActive: function isActive() {
      return this.$parent.activeNames.indexOf(this.name) > -1;
    }
  },
  methods: {
    itemClick: function itemClick() {
      this.dispatch('CMUICollapse', 'item-click', this);
    }
  }
};

/* script */
const __vue_script__$9 = script$9;

/* template */
var __vue_render__$9 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { staticClass: "cmui-collapse-item" },
    [
      _c(
        "div",
        {
          staticClass: "cmui-collapse-item__header flex-container",
          class: { active: _vm.isActive },
          on: { click: _vm.itemClick }
        },
        [
          _c(
            "div",
            [_vm._t("title", [_vm._v("\n" + _vm._s(_vm.title) + "\n")])],
            2
          ),
          _vm._v(" "),
          _c("i", {
            staticClass: "cmui-collapse-item__header__arrow baseIcon",
            class: [_vm.isActive ? "baseIcon-fold" : "baseIcon-unfold"]
          })
        ]
      ),
      _vm._v(" "),
      _c("collapse-transition", [
        _c(
          "div",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.isActive,
                expression: "isActive"
              }
            ],
            staticClass: "cmui-collapse-item__bodyWarp",
            class: { active: _vm.isActive }
          },
          [
            _c(
              "div",
              { staticClass: "cmui-collapse-item__body" },
              [_vm._t("default")],
              2
            )
          ]
        )
      ])
    ],
    1
  )
};
var __vue_staticRenderFns__$9 = [];
__vue_render__$9._withStripped = true;

  /* style */
  const __vue_inject_styles__$9 = undefined;
  /* scoped */
  const __vue_scope_id__$9 = undefined;
  /* module identifier */
  const __vue_module_identifier__$9 = undefined;
  /* functional template */
  const __vue_is_functional_template__$9 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$9 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
    __vue_inject_styles__$9,
    __vue_script__$9,
    __vue_scope_id__$9,
    __vue_is_functional_template__$9,
    __vue_module_identifier__$9,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$9.install = function (Vue, Maple) {
  Vue.component(__vue_component__$9.name, __vue_component__$9);
};

var _stringRepeat = function repeat(count) {
  var str = String(_defined(this));
  var res = '';
  var n = _toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

// https://github.com/tc39/proposal-string-pad-start-end




var _stringPad = function (that, maxLength, fillString, left) {
  var S = String(_defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = _toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

var navigator$1 = _global.navigator;

var _userAgent = navigator$1 && navigator$1.userAgent || '';

// https://github.com/tc39/proposal-string-pad-start-end




// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);

_export(_export.P + _export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

var script$a = {
  name: 'cmui-countdown',
  props: {
    nowTime: {
      type: Number,
      default: +new Date(),
      intro: '用于设置当前的时间，通常取服务器时间，默认取本地时间'
    },
    endTime: {
      type: Number,
      default: 0,
      intro: '倒计时的结束时间'
    },
    showMilli: {
      type: Boolean,
      default: false,
      intro: '是否显示毫秒数，默认不显示'
    },
    showDay: {
      type: Boolean,
      default: false,
      intro: '是否显示天'
    }
  },
  data: function data() {
    return {
      contentList: {
        hour: '00',
        minute: '00',
        sec: '00'
      },
      selfTime: this.nowTime
    };
  },
  watch: {
    selfTime: function selfTime(value) {
      if (this.endTime && this.nowTime) {
        var countDownTime = this.endTime - value;
        this.$emit('update', countDownTime, this);

        if (countDownTime < 0) {
          clearTimeout(this.timer);
          this.contentList = {
            hour: '00',
            minute: '00',
            sec: '00'
          };
          this.$emit('countdownend', this);
        } else {
          var obj = {};
          var day = Math.floor(countDownTime / 3600000 / 24);

          if (this.showDay && day) {
            obj.day = day;
          }

          obj.hour = Math.floor(countDownTime / 3600000 % 24) + (this.showDay ? 0 : day * 24);
          obj.minute = Math.floor(countDownTime / 60000 % 60);
          obj.sec = Math.floor(countDownTime / 1000 % 60);

          if (this.showMilli) {
            obj.millSec = Math.floor(countDownTime / 100 % 10);
          }

          this.contentList = _$1.mapValues(obj, function (item) {
            return _$1.padStart(item, 2, 0);
          });
        }
      }
    },
    endTime: function endTime(value) {
      var vm = this;
      var intervalTime = this.showMilli ? 100 : 1000;

      if (this.endTime && this.selfTime && this.endTime > this.selfTime) {
        clearTimeout(this.timer);
        vm.selfTime += intervalTime;
        this.timer = setInterval(function () {
          vm.selfTime += intervalTime;
        }, intervalTime);
      }
    }
  },
  mounted: function mounted() {
    var vm = this;
    var intervalTime = this.showMilli ? 100 : 1000;

    if (_$1.isNumber(this.endTime) && _$1.isNumber(this.selfTime) && this.endTime > this.selfTime) {
      vm.selfTime += intervalTime;
      this.timer = setInterval(function () {
        vm.selfTime += intervalTime;
      }, intervalTime);
    }
  },
  destroyed: function destroyed() {
    clearTimeout(this.timer);
  }
};

var css_248z$4 = ".countdown-container[data-v-14471999]{background-color:#232323;color:#fff;position:relative}.countdown-container[data-v-14471999]:not(:last-child){margin-right:10px}.countdown-container[data-v-14471999]:not(:last-child):after{content:\":\";color:#232323;position:absolute;left:111%;top:0}";
styleInject(css_248z$4);

/* script */
const __vue_script__$a = script$a;
/* template */
var __vue_render__$a = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { staticClass: "cmui-countdown flex-container" },
    _vm._l(_vm.contentList, function(value, key) {
      return _c(
        "div",
        { key: key, staticClass: "countdown-container", class: key },
        [_c("span", [_vm._v(_vm._s(value))])]
      )
    }),
    0
  )
};
var __vue_staticRenderFns__$a = [];
__vue_render__$a._withStripped = true;

  /* style */
  const __vue_inject_styles__$a = undefined;
  /* scoped */
  const __vue_scope_id__$a = "data-v-14471999";
  /* module identifier */
  const __vue_module_identifier__$a = undefined;
  /* functional template */
  const __vue_is_functional_template__$a = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$a = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
    __vue_inject_styles__$a,
    __vue_script__$a,
    __vue_scope_id__$a,
    __vue_is_functional_template__$a,
    __vue_module_identifier__$a,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$a.install = function (Vue, Maple) {
  Vue.component(__vue_component__$a.name, __vue_component__$a);
};

// 7.2.8 IsRegExp(argument)


var MATCH = _wks('match');
var _isRegexp = function (it) {
  var isRegExp;
  return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
};

// 7.3.20 SpeciesConstructor(O, defaultConstructor)


var SPECIES$2 = _wks('species');
var _speciesConstructor = function (O, D) {
  var C = _anObject(O).constructor;
  var S;
  return C === undefined || (S = _anObject(C)[SPECIES$2]) == undefined ? D : _aFunction(S);
};

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX$1 = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !_fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
_fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!_isRegexp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = _regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX$1];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX$1] === match.index) separatorCopy[LAST_INDEX$1]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = _anObject(regexp);
      var S = String(this);
      var C = _speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = _advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

// https://github.com/tc39/Array.prototype.includes

var $includes = _arrayIncludes(true);

_export(_export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

_addToUnscopables('includes');

// helper for String#{startsWith, endsWith, includes}



var _stringContext = function (that, searchString, NAME) {
  if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(_defined(that));
};

var MATCH$1 = _wks('match');
var _failsIsRegexp = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH$1] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

var INCLUDES = 'includes';

_export(_export.P + _export.F * _failsIsRegexp(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~_stringContext(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var mixin = {
  methods: {
    handleFocus: function handleFocus(event) {
      // console.log(`base handleFocus`)
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('focus', value, this);
      this.cmuiFormItem && this.cmuiFormItem.$emit('form.focus');
    },
    handleInput: function handleInput(event) {
      // console.log(`base handleInput`)
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('input', value, this);
      this.$nextTick(this.rendered);
      this.cmuiFormItem && this.cmuiFormItem.$emit('form.input');
    },
    handleChange: function handleChange(event) {
      // console.log(`base handleChange`)
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('change', value, this);
      this.$emit('input', value, this);
      this.cmuiFormItem && this.cmuiFormItem.$emit('form.change');
    },
    handleBlur: function handleBlur(event) {
      // console.log(`base handleBlur`)
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('blur', value, this);
      this.cmuiFormItem && this.cmuiFormItem.$emit('form.blur');
    },
    rendered: function rendered(event) {
      // console.log(`base rendered`)
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('rendered', value, this);
    },
    getInput: function getInput() {
      return this.$refs.input;
    }
  },
  props: {
    disabled: {
      type: Boolean,
      default: false,
      intro: '是否禁用'
    },
    readonly: {
      type: Boolean,
      default: false,
      intro: '是否设置为只读'
    },
    placeholder: {
      type: String,
      default: '',
      intro: 'placeholder文字'
    },
    value: {
      type: [String, Boolean, Number, Array, Object],
      default: function _default() {
        return '';
      },
      intro: '用于v-model绑定的值'
    },
    name: {
      type: String,
      default: '',
      intro: '表单项名称'
    },
    target: {
      type: Object,
      default: null,
      intro: '可用于存放一个对象在后续操作中使用'
    },
    targetClass: {
      type: String,
      default: '',
      intro: '绑定到表单项上的class，可配合Cyan使用'
    },
    label: {
      type: [String, Number],
      default: '',
      intro: '标签文字'
    },
    align: {
      type: String,
      default: 'left',
      intro: '标签位置，可选项为left或right'
    },
    flex: {
      type: Boolean,
      default: false,
      intro: '是否使用flex布局'
    }
  },
  inject: {
    cmuiForm: {
      default: ''
    },
    cmuiFormItem: {
      default: ''
    }
  }
};

var script$b = {
  name: 'cmui-textarea',
  mixins: [mixin],
  props: {
    auto: {
      type: Boolean,
      default: false,
      intro: '是否自动调整高度'
    },
    max: {
      type: Number,
      default: -1,
      intro: '设置允许输入字符串的长度，-1表示不限制'
    },
    // space: { type: Number, default: 20 ,intro:''},
    width: {
      type: [Number, String],
      default: 0,
      intro: '设置输入框宽度'
    }
  },
  computed: {
    targetStyle: function targetStyle() {
      var style = {};

      if (this.width) {
        style.width = parseInt(this.width) + 'px';
      }

      return style;
    },
    positionClass: function positionClass() {
      if (_$1.includes(this.targetClass.split(' '), 'center')) {
        return '';
      } else if (_$1.includes(this.targetClass.split(' '), 'bottom')) {
        return 'bottom';
      } else {
        return 'top';
      }
    },
    slefValue: {
      get: function get() {
        return this.value;
      },
      set: function set(value) {
        this.$emit('input', value, this.$refs.textarea, this);
      }
    }
  },
  mounted: function mounted() {
    this.setTextAreaHeight();
  },
  methods: {
    rendered: function rendered() {
      this.setTextAreaHeight();
    },
    setTextAreaHeight: function setTextAreaHeight() {
      if (this.auto) {
        var target = this.$refs.textarea;
        var cloneTarget = document.createElement('textarea');
        var style = window.getComputedStyle(target, null);
        ['fontSize', 'lineHeight', 'width', 'border', 'padding'].forEach(function (item) {
          cloneTarget.style[item] = style[item];
        });
        cloneTarget.value = this.slefValue;
        document.body.appendChild(cloneTarget);
        target.style.height = cloneTarget.scrollHeight + 'px';
        document.body.removeChild(cloneTarget);
      }
    },
    handlePaste: function handlePaste(e) {
      var target = this.$refs.textarea;

      if (this.max) {
        target.value = target.value.slice(0, this.max);
      }
    }
  }
};

var css_248z$5 = ".cmui-textarea textarea[data-v-b0e0d92e]{min-height:100px}";
styleInject(css_248z$5);

/* script */
const __vue_script__$b = script$b;
/* template */
var __vue_render__$b = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "cmui-textarea pos-r form flex-container",
      class: _vm.positionClass
    },
    [
      _vm.align === "left" && (_vm.label || _vm.$slots.default)
        ? _c(
            "span",
            {
              staticClass: "cmui-input__label cmui-form__label",
              class: { checked: _vm.slefValue }
            },
            [
              _vm._t("default"),
              _vm._v(" "),
              !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c("div", { staticClass: "pos-r", class: { flex1: !_vm.flex } }, [
        _c("textarea", {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.slefValue,
              expression: "slefValue"
            }
          ],
          ref: "textarea",
          class: [_vm.targetClass, "hide-scrollBar"],
          style: _vm.targetStyle,
          attrs: {
            maxlength: _vm.max,
            name: _vm.name,
            readonly: _vm.readonly,
            placeholder: _vm.placeholder,
            disabled: _vm.disabled
          },
          domProps: { value: _vm.slefValue },
          on: {
            input: [
              function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.slefValue = $event.target.value;
              },
              _vm.handleInput
            ],
            focus: _vm.handleFocus,
            blur: _vm.handleBlur,
            change: _vm.handleChange
          }
        }),
        _vm._v(" "),
        _vm.max >= 0
          ? _c("div", {
              staticClass: "pos-a text-light",
              staticStyle: { right: "12px", bottom: "4px" },
              domProps: {
                textContent: _vm._s(_vm.slefValue.length + "/" + _vm.max)
              }
            })
          : _vm._e()
      ]),
      _vm._v(" "),
      _vm.align === "right" && (_vm.label || _vm.$slots.default)
        ? _c(
            "span",
            {
              staticClass: "cmui-input__label cmui-form__label",
              class: { checked: _vm.slefValue }
            },
            [
              _vm._t("default"),
              _vm._v(" "),
              !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
            ],
            2
          )
        : _vm._e()
    ]
  )
};
var __vue_staticRenderFns__$b = [];
__vue_render__$b._withStripped = true;

  /* style */
  const __vue_inject_styles__$b = undefined;
  /* scoped */
  const __vue_scope_id__$b = "data-v-b0e0d92e";
  /* module identifier */
  const __vue_module_identifier__$b = undefined;
  /* functional template */
  const __vue_is_functional_template__$b = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$b = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
    __vue_inject_styles__$b,
    __vue_script__$b,
    __vue_scope_id__$b,
    __vue_is_functional_template__$b,
    __vue_module_identifier__$b,
    false,
    undefined,
    undefined,
    undefined
  );

var script$c = {
  name: 'cmui-input',
  mixins: [mixin],
  props: {
    type: {
      type: String,
      default: 'text',
      intro: '设置输入框类型'
    },
    reset: {
      type: Boolean,
      default: false,
      intro: '是否显示清除的icon'
    },
    prepend: {
      type: String,
      default: '',
      intro: '前置文本内容'
    },
    append: {
      type: String,
      default: '',
      intro: '后置文本内容'
    },
    width: {
      type: [Number, String],
      default: 0,
      intro: '设置输入框的宽度，单位为PX'
    },
    prependDisabled: {
      type: Boolean,
      default: false,
      intro: '禁用前置文本'
    },
    appendDisabled: {
      type: Boolean,
      default: false,
      intro: '禁用后置文本'
    },
    changeType: {
      type: Boolean,
      default: false,
      intro: '在类型为password的时候是否显示切换类型按钮'
    }
  },
  computed: {
    inputStyle: function inputStyle() {
      var style = {};

      if (this.$slots.prepend || this.prepend || this.reverse) {
        style.borderTopLeftRadius = '0px';
        style.borderBottomLeftRadius = '0px';
      }

      if (this.$slots.append || this.append || this.reverse) {
        style.borderTopRightRadius = '0px';
        style.borderBottomRightRadius = '0px';
      }

      if (this.reset) {
        style.paddingRight = '40px';
      }

      if (this.type === 'search') {
        style.paddingLeft = '40px';
      }

      if (this.width) {
        style.width = this.width + 'px';
      }

      return style;
    },
    selfType: function selfType() {
      return this.type === 'number' ? 'tel' : this.type;
    }
  },
  methods: {
    resetInput: function resetInput() {
      var target = this.$refs.input;
      target.value = '';
      target.focus();
      this.$emit('reset', target, this);
      this.$emit('input', '', target, this);
    },
    handleInput: function handleInput(event) {
      console.log("input handleInput");
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;

      if (this.type === 'number') {
        var rs = /(-)?\d+\.?(\d+)?/.exec(value);
        value = rs ? rs[0] : '';
      } // target.value=value;


      this.$emit('input', value, target, this);
      this.$nextTick(this.rendered);
    }
  }
};

var css_248z$6 = ".cmui-input .cmui-input__append[data-v-60d05a90],.cmui-input .cmui-input__prepend[data-v-60d05a90]{background-color:#eee;border:1px solid #ccc}.cmui-input .cmui-input__append.reverse[data-v-60d05a90],.cmui-input .cmui-input__prepend.reverse[data-v-60d05a90]{border-color:transparent transparent #ccc;background-color:initial}.cmui-input .cmui-input__append.disabled[data-v-60d05a90],.cmui-input .cmui-input__prepend.disabled[data-v-60d05a90]{color:#bbb}.cmui-input .cmui-input__append>[data-v-60d05a90],.cmui-input .cmui-input__prepend>[data-v-60d05a90]{line-height:26px}.cmui-input .cmui-input__append>[data-v-60d05a90]:not(:first-child),.cmui-input .cmui-input__prepend>[data-v-60d05a90]:not(:first-child){border-left:1px solid #ccc;padding-left:10px}.cmui-input .cmui-input__append select[data-v-60d05a90],.cmui-input .cmui-input__prepend select[data-v-60d05a90]{border:none}.cmui-input .cmui-input__append .cmui-select select[data-v-60d05a90],.cmui-input .cmui-input__prepend .cmui-select select[data-v-60d05a90]{padding:0;padding-right:16px!important;background-position-x:right}.cmui-input .cmui-input__prepend[data-v-60d05a90]{border-top-right-radius:0;border-bottom-right-radius:0;margin-right:-1px}.cmui-input .cmui-input__append[data-v-60d05a90]{margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}";
styleInject(css_248z$6);

/* script */
const __vue_script__$c = script$c;
/* template */
var __vue_render__$c = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "pos-r cmui-input form flex-container" }, [
    _vm.align === "left" && (_vm.label || _vm.$slots.default)
      ? _c(
          "span",
          { staticClass: "cmui-input__label cmui-form__label" },
          [
            _vm._t("default"),
            _vm._v(" "),
            !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
          ],
          2
        )
      : _vm._e(),
    _vm._v(" "),
    _c("div", { staticClass: "flex-container", class: { flex1: !_vm.flex } }, [
      _vm.$slots.prepend || _vm.prepend
        ? _c(
            "div",
            {
              staticClass: "cmui-input__prepend flex-container",
              class: [_vm.targetClass, { disabled: _vm.prependDisabled }]
            },
            [
              _vm.$slots.prepend ? _vm._t("prepend") : _vm._e(),
              _vm._v(" "),
              _vm.prepend ? _c("span", [_vm._v(_vm._s(_vm.prepend))]) : _vm._e()
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "cmui-input__main pos-r flex-container",
          class: { flex1: !_vm.label || !_vm.$slots.default }
        },
        [
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model.lazy",
                value: _vm.value,
                expression: "value",
                modifiers: { lazy: true }
              }
            ],
            ref: "input",
            class: _vm.targetClass,
            style: _vm.inputStyle,
            attrs: {
              type: _vm.selfType,
              name: _vm.name,
              readonly: _vm.readonly,
              placeholder: _vm.placeholder,
              disabled: _vm.disabled
            },
            domProps: { value: _vm.value },
            on: {
              input: _vm.handleInput,
              focus: _vm.handleFocus,
              blur: _vm.handleBlur,
              change: [
                function($event) {
                  _vm.value = $event.target.value;
                },
                _vm.handleChange
              ]
            }
          }),
          _vm._v(" "),
          _vm.type === "search"
            ? _c("div", {
                staticClass: "input-search",
                style: { display: _vm.type === "search" ? "block" : "none" }
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.reset === true && !_vm.disabled
            ? _c("div", {
                staticClass: "input-reset",
                style: { display: _vm.value.length ? "block" : "none" },
                on: {
                  click: function($event) {
                    return _vm.resetInput()
                  }
                }
              })
            : _vm._e()
        ]
      ),
      _vm._v(" "),
      _vm.$slots.append || _vm.append
        ? _c(
            "div",
            {
              staticClass: "cmui-input__append flex-container",
              class: [_vm.targetClass, { disabled: _vm.appendDisabled }]
            },
            [
              _vm.$slots.append ? _vm._t("append") : _vm._e(),
              _vm._v(" "),
              _vm.append
                ? _c("span", { domProps: { textContent: _vm._s(_vm.append) } })
                : _vm._e()
            ],
            2
          )
        : _vm._e()
    ]),
    _vm._v(" "),
    _vm.align === "right" && (_vm.label || _vm.$slots.default)
      ? _c(
          "span",
          { staticClass: "cmui-input__label cmui-form__label" },
          [
            _vm._t("default"),
            _vm._v(" "),
            !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
          ],
          2
        )
      : _vm._e()
  ])
};
var __vue_staticRenderFns__$c = [];
__vue_render__$c._withStripped = true;

  /* style */
  const __vue_inject_styles__$c = undefined;
  /* scoped */
  const __vue_scope_id__$c = "data-v-60d05a90";
  /* module identifier */
  const __vue_module_identifier__$c = undefined;
  /* functional template */
  const __vue_is_functional_template__$c = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$c = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
    __vue_inject_styles__$c,
    __vue_script__$c,
    __vue_scope_id__$c,
    __vue_is_functional_template__$c,
    __vue_module_identifier__$c,
    false,
    undefined,
    undefined,
    undefined
  );

var _arrayFill = function fill(value /* , start = 0, end = @length */) {
  var O = _toObject(this);
  var length = _toLength(O.length);
  var aLen = arguments.length;
  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


_export(_export.P, 'Array', { fill: _arrayFill });

_addToUnscopables('fill');

/**
 * SSR Window 2.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: May 12, 2020
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target, src) {
    if (target === void 0) { target = {}; }
    if (src === void 0) { src = {}; }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

var doc$1 = typeof document !== 'undefined' ? document : {};
var ssrDocument = {
    body: {},
    addEventListener: function () { },
    removeEventListener: function () { },
    activeElement: {
        blur: function () { },
        nodeName: '',
    },
    querySelector: function () {
        return null;
    },
    querySelectorAll: function () {
        return [];
    },
    getElementById: function () {
        return null;
    },
    createEvent: function () {
        return {
            initEvent: function () { },
        };
    },
    createElement: function () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function () { },
            getElementsByTagName: function () {
                return [];
            },
        };
    },
    createElementNS: function () {
        return {};
    },
    importNode: function () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
extend(doc$1, ssrDocument);

var win$1 = typeof window !== 'undefined' ? window : {};
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState: function () { },
        pushState: function () { },
        go: function () { },
        back: function () { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function () { },
    removeEventListener: function () { },
    getComputedStyle: function () {
        return {
            getPropertyValue: function () {
                return '';
            },
        };
    },
    Image: function () { },
    Date: function () { },
    screen: {},
    setTimeout: function () { },
    clearTimeout: function () { },
    matchMedia: function () {
        return {};
    },
};
extend(win$1, ssrWindow);

/**
 * Dom7 2.1.5
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * http://framework7.io/docs/dom.html
 *
 * Copyright 2020, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: May 15, 2020
 */

class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = doc$1.createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [doc$1.getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || doc$1).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === win$1 || selector === doc$1) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$.fn = Dom7.prototype;
$.Class = Dom7;
$.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}

// Classes and attributes
function addClass(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
function data(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
// Transforms
// eslint-disable-next-line
function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let evt;
      try {
        evt = new win$1.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = doc$1.createEvent('Event');
        evt.initEvent(event, true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      el.dispatchEvent(evt);
      el.dom7EventData = [];
      delete el.dom7EventData;
    }
  }
  return this;
}
function transitionEnd(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = doc$1.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === win$1 ? win$1.scrollY : el.scrollTop;
    const scrollLeft = el === win$1 ? win$1.scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function styles() {
  if (this[0]) return win$1.getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return win$1.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
// eslint-disable-next-line
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is$1(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === doc$1) return el === doc$1;
  else if (selector === win$1) return el === win$1;

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = doc$1.createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = doc$1.createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $(unique(parents));
}
function closest(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function add(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}

/**
 * Swiper 5.4.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: June 16, 2020
 */

const Methods = {
  addClass,
  removeClass,
  hasClass,
  toggleClass,
  attr,
  removeAttr,
  data,
  transform,
  transition: transition,
  on,
  off,
  trigger,
  transitionEnd: transitionEnd,
  outerWidth,
  outerHeight,
  offset,
  css,
  each,
  html,
  text,
  is: is$1,
  index,
  eq,
  append,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest,
  find,
  children,
  filter,
  remove,
  add,
  styles,
};

Object.keys(Methods).forEach((methodName) => {
  $.fn[methodName] = $.fn[methodName] || Methods[methodName];
});

const Utils = {
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  now() {
    return Date.now();
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = win$1.getComputedStyle(el, null);

    if (win$1.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map((a) => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new win$1.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (win$1.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (win$1.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || win$1.location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter((paramsPart) => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
      }
    }
    return query;
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  extend(...args) {
    const to = Object(args[0]);
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const Support = (function Support() {
  return {
    touch: !!(('ontouchstart' in win$1) || (win$1.DocumentTouch && doc$1 instanceof win$1.DocumentTouch)),

    pointerEvents: !!win$1.PointerEvent && ('maxTouchPoints' in win$1.navigator) && win$1.navigator.maxTouchPoints >= 0,

    observer: (function checkObserver() {
      return ('MutationObserver' in win$1 || 'WebkitMutationObserver' in win$1);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          },
        });
        win$1.addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in win$1;
    }()),
  };
}());

class SwiperClass {
  constructor(params = {}) {
    const self = this;
    self.params = params;

    // Events
    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }

  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
      handler.apply(self, args);
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }

  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }

  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      const moduleParams = modulesParams[moduleName] || {};
      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }

  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }

  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }

  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach((m) => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

function updateSize () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}

function updateSlides () {
  const swiper = this;
  const params = swiper.params;

  const {
    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  function slidesForMargin(slideIndex) {
    if (!params.cssMode) return true;
    if (slideIndex === slides.length - 1) {
      return false;
    }
    return true;
  }

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        const groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        const slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        const columnsInGroup = groupIndex === 0
          ? params.slidesPerGroup
          : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;

        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - (column * slidesPerColumn);
        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide.css(
        `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
        (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
      );
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      const slideStyles = win$1.getComputedStyle(slide[0], null);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal()
          ? slide.outerWidth(true)
          : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        if (swiper.isHorizontal()) {
          const width = parseFloat(slideStyles.getPropertyValue('width'));
          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
          }
        } else {
          const height = parseFloat(slideStyles.getPropertyValue('height'));
          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = height + marginTop + marginBottom;
          } else {
            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
          }
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.filter(slidesForMargin).css({ marginLeft: `${spaceBetween}px` });
      else slides.filter(slidesForMargin).css({ marginRight: `${spaceBetween}px` });
    } else slides.filter(slidesForMargin).css({ marginBottom: `${spaceBetween}px` });
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight (speed) {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each((index, slide) => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length) break;
        activeSlides.push(swiper.slides.eq(index)[0]);
      }
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtlTranslate: rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress = (
      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
    ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
                || (slideAfter > 1 && slideAfter <= swiper.size)
                || (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = $(swiper.visibleSlides);
}

function updateProgress (translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses () {
  const swiper = this;

  const {
    slides, params, $wrapperEl, activeIndex, realIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
}

function updateActiveIndex (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

function updateClickedSlide (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = $(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = $(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const {
    params, rtlTranslate: rtl, translate, $wrapperEl,
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
}

function setTranslate (translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress,
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate () {
  return (-this.snapGrid[0]);
}

function maxTranslate () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
}

function translateTo (translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;

  const {
    params,
    wrapperEl,
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
  else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: -newTranslate,
          behavior: 'smooth',
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }
    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

var translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo,
};

function setTransition (duration, byController) {
  const swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

function transitionStart (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function transitionEnd$1 (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, previousIndex, params } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

var transition$1 = {
  setTransition,
  transitionStart,
  transitionEnd: transitionEnd$1,
};

function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;

  const {
    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl,
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';
  else if (slideIndex < activeIndex) direction = 'prev';
  else direction = 'reset';


  // Update Index
  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    let t = -translate;
    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: t,
          behavior: 'smooth',
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }
    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params, animating, snapGrid, slidesGrid, rtlTranslate,
  } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  const normalizedSlidesGrid = slidesGrid.map((val) => normalize(val));

  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach((snap) => {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }
  let prevIndex;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest (speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);

  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if ((translate - prevSnap) <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);

  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};

function loopCreate () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = $(doc$1.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index, el) => {
    const slide = $(el);
    if (index < swiper.loopedSlides) appendSlides.push(el);
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix () {
  const swiper = this;

  swiper.emit('beforeLoopFix');

  const {
    activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;

  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();

  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  swiper.emit('loopFix');
}

function loopDestroy () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

function setGrabCursor (moving) {
  const swiper = this;
  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor () {
  const swiper = this;
  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
  swiper.el.style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

function appendSlide (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
}

function prependSlide (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide (index, slides) {
  const swiper = this;
  const { $wrapperEl, params, activeIndex } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

var manipulation = {
  appendSlide,
  prependSlide,
  addSlide,
  removeSlide,
  removeAllSlides,
};

const Device = (function Device() {
  const platform = win$1.navigator.platform;
  const ua = win$1.navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    iphone: false,
    ipod: false,
    ipad: false,
    edge: false,
    ie: false,
    firefox: false,
    macos: false,
    windows: false,
    cordova: !!(win$1.cordova || win$1.phonegap),
    phonegap: !!(win$1.cordova || win$1.phonegap),
    electron: false,
  };

  const screenWidth = win$1.screen.width;
  const screenHeight = win$1.screen.height;

  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
  const edge = ua.indexOf('Edge/') >= 0;
  const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
  const windows = platform === 'Win32';
  const electron = ua.toLowerCase().indexOf('electron') >= 0;
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  if (!ipad
    && macos
    && Support.touch
    && (
      (screenWidth === 1024 && screenHeight === 1366) // Pro 12.9
      || (screenWidth === 834 && screenHeight === 1194) // Pro 11
      || (screenWidth === 834 && screenHeight === 1112) // Pro 10.5
      || (screenWidth === 768 && screenHeight === 1024) // other
    )
  ) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    macos = false;
  }

  device.ie = ie;
  device.edge = edge;
  device.firefox = firefox;

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.ipod = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Webview
  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win$1.navigator.standalone))
    || (win$1.matchMedia && win$1.matchMedia('(display-mode: standalone)').matches);
  device.webview = device.webView;
  device.standalone = device.webView;

  // Desktop
  device.desktop = !(device.ios || device.android) || electron;
  if (device.desktop) {
    device.electron = electron;
    device.macos = macos;
    device.windows = windows;
    if (device.macos) {
      device.os = 'macos';
    }
    if (device.windows) {
      device.os = 'windows';
    }
  }

  // Pixel Ratio
  device.pixelRatio = win$1.devicePixelRatio || 1;

  // Export object
  return device;
}());

function onTouchStart (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const $targetEl = $(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (
    edgeSwipeDetection
    && ((startX <= edgeSwipeThreshold)
    || (startX >= win$1.screen.width - edgeSwipeThreshold))
  ) {
    return;
  }

  Utils.extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if ($targetEl.is(data.formElements)) preventDefault = false;
    if (
      doc$1.activeElement
      && $(doc$1.activeElement).is(data.formElements)
      && doc$1.activeElement !== $targetEl[0]
    ) {
      doc$1.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}

function onTouchMove (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches, rtlTranslate: rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type !== 'touchmove') return;
  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = Utils.now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (
      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data.isTouchEvent && doc$1.activeElement) {
    if (e.target === doc$1.activeElement && $(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = pageX;
  touches.currentY = pageY;

  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if ((diffX * diffX) + (diffY * diffY) >= 25) {
        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;

  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime,
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd (event) {
  const swiper = this;
  const data = swiper.touchEventsData;

  const {
    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
  } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;

      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {
    const increment = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize () {
  const swiper = this;

  const { params, el } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  swiper.updateSlidesClasses();
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll () {
  const swiper = this;
  const { wrapperEl, rtlTranslate } = swiper;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = ((wrapperEl.scrollWidth - wrapperEl.offsetWidth) - wrapperEl.scrollLeft);
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === -0) swiper.translate = 0;

  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();

  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

let dummyEventAttached = false;
function dummyEventListener() {}

function attachEvents() {
  const swiper = this;
  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);

  const capture = !!params.nested;

  // Touch Events
  if (!Support.touch && Support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    doc$1.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    doc$1.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (Support.touch) {
      const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
      if (!dummyEventAttached) {
        doc$1.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }
    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      doc$1.addEventListener('mousemove', swiper.onTouchMove, capture);
      doc$1.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
  } else {
    swiper.on('observerUpdate', onResize, true);
  }
}

function detachEvents() {
  const swiper = this;

  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  const capture = !!params.nested;

  // Touch Events
  if (!Support.touch && Support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    doc$1.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    doc$1.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (Support.touch) {
      const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }
    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      doc$1.removeEventListener('mousemove', swiper.onTouchMove, capture);
      doc$1.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
}

var events = {
  attachEvents,
  detachEvents,
};

function setBreakpoint () {
  const swiper = this;
  const {
    activeIndex, initialized, loopedSlides = 0, params, $el,
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);

  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    if (breakpointOnlyParams) {
      ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach((param) => {
        const paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === 'undefined') return;
        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
          breakpointOnlyParams[param] = 'auto';
        } else if (param === 'slidesPerView') {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }

    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = params.slidesPerColumn > 1;
    const isMultiRow = breakpointParams.slidesPerColumn > 1;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}multirow ${params.containerModifierClass}multirow-column`);
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}multirow`);
      if (breakpointParams.slidesPerColumnFill === 'column') {
        $el.addClass(`${params.containerModifierClass}multirow-column`);
      }
    }

    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    Utils.extend(swiper.params, breakpointParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }
}

function getBreakpoint (breakpoints) {
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;

  const points = Object.keys(breakpoints).map((point) => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = win$1.innerHeight * minRatio;
      return { value, point };
    }
    return { value: point, point };
  });

  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const { point, value } = points[i];
    if (value <= win$1.innerWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = { setBreakpoint, getBreakpoint };

function addClasses () {
  const swiper = this;
  const {
    classNames, params, rtl, $el,
  } = swiper;
  const suffixes = [];

  suffixes.push('initialized');
  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
    if (params.slidesPerColumnFill === 'column') {
      suffixes.push('multirow-column');
    }
  }
  if (Device.android) {
    suffixes.push('android');
  }
  if (Device.ios) {
    suffixes.push('ios');
  }

  if (params.cssMode) {
    suffixes.push('css-mode');
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
}

function removeClasses () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
}

var classes = { addClasses, removeClasses };

function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  const isPicture = $(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new win$1.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
}

var images = {
  loadImage,
  preloadImages,
};

function checkOverflow() {
  const swiper = this;
  const params = swiper.params;
  const wasLocked = swiper.isLocked;
  const lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;

  // events
  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation) swiper.navigation.update();
  }
}

var checkOverflow$1 = { checkOverflow };

var defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  //
  preventInteractionOnTransition: false,

  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,

  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

/* eslint no-param-reassign: "off" */

const prototypes = {
  update,
  translate,
  transition: transition$1,
  slide,
  loop,
  grabCursor,
  manipulation,
  events,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images,
};

const extendedDefaults = {};

class Swiper extends SwiperClass {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!Swiper.prototype[protoMethod]) {
          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;
    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object'
          && !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Save Dom lib
    swiper.$ = $;

    // Find el
    const $el = $(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    let $wrapperEl;
    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
      $wrapperEl = $(el.shadowRoot.querySelector(`.${swiper.params.wrapperClass}`));
      // Children needs to return slot items
      $wrapperEl.children = (options) => $el.children(options);
    } else {
      $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);
    }
    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: $(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (Support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3],
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2],
        };
        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video, label',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }

  slidesPerViewDynamic() {
    const swiper = this;
    const {
      params, slides, slidesGrid, size: swiperSize, activeIndex,
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const { snapGrid, params } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
      return swiper;
    }

    swiper.$el
      .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)
      .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

    swiper.params.direction = newDirection;

    swiper.slides.each((slideIndex, slideEl) => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });

    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();

    return swiper;
  }

  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params, $el, $wrapperEl, slides,
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
    }
    swiper.destroyed = true;

    return null;
  }

  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults;
  }

  static get Class() {
    return SwiperClass;
  }

  static get $() {
    return $;
  }
}

var Device$1 = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
};

var Support$1 = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

const Browser = (function Browser() {
  function isSafari() {
    const ua = win$1.navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isEdge: !!win$1.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win$1.navigator.userAgent),
  };
}());

var Browser$1 = {
  name: 'browser',
  proto: {
    browser: Browser,
  },
  static: {
    browser: Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      win$1.addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      win$1.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      win$1.removeEventListener('resize', swiper.resize.resizeHandler);
      win$1.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer = {
  func: win$1.MutationObserver || win$1.WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer.func;
    const observer = new ObserverFunc((mutations) => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (win$1.requestAnimationFrame) {
        win$1.requestAnimationFrame(observerUpdate);
      } else {
        win$1.setTimeout(observerUpdate, 0);
      }
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer.init.bind(swiper),
        attach: Observer.attach.bind(swiper),
        destroy: Observer.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
      slidesBefore = slidesPerGroup + addSlidesAfter;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach((index) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  },
  renderSlide(slide, index) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    const $slideEl = params.renderSlide
      ? $(params.renderSlide.call(swiper, slide, index))
      : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide(slides) {
    const swiper = this;
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    swiper.virtual.update(true);
  },
  prependSlide(slides) {
    const swiper = this;
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        const $cachedEl = cache[cachedIndex];
        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide(slidesIndexes) {
    const swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides() {
    const swiper = this;
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      addSlidesBefore: 0,
      addSlidesAfter: 0,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        removeSlide: Virtual.removeSlide.bind(swiper),
        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      const overwriteParams = {
        watchSlidesProgress: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Keyboard = {
  handle(event) {
    const swiper = this;
    const { rtlTranslate: rtl } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    // Directions locks
    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && isArrowRight) || (swiper.isVertical() && isArrowDown) || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (doc$1.activeElement && doc$1.activeElement.nodeName && (doc$1.activeElement.nodeName.toLowerCase() === 'input' || doc$1.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const windowWidth = win$1.innerWidth;
      const windowHeight = win$1.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [
        [swiperOffset.left, swiperOffset.top],
        [swiperOffset.left + swiper.width, swiperOffset.top],
        [swiperOffset.left, swiperOffset.top + swiper.height],
        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
      ];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (
          point[0] >= 0 && point[0] <= windowWidth
          && point[1] >= 0 && point[1] <= windowHeight
        ) {
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl)) swiper.slideNext();
      if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl)) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable() {
    const swiper = this;
    if (swiper.keyboard.enabled) return;
    $(doc$1).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable() {
    const swiper = this;
    if (!swiper.keyboard.enabled) return;
    $(doc$1).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  },
};

var Keyboard$1 = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      keyboard: {
        enabled: false,
        enable: Keyboard.enable.bind(swiper),
        disable: Keyboard.disable.bind(swiper),
        handle: Keyboard.handle.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    },
  },
};

function isEventSupported() {
  const eventName = 'onwheel';
  let isSupported = eventName in doc$1;

  if (!isSupported) {
    const element = doc$1.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported
    && doc$1.implementation
    && doc$1.implementation.hasFeature
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && doc$1.implementation.hasFeature('', '') !== true
  ) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = doc$1.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}
const Mousewheel = {
  lastScrollTime: Utils.now(),
  lastEventBeforeSnap: undefined,
  recentWheelEvents: [],
  event() {
    if (win$1.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  },
  normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;

    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else { // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = (pX < 1) ? -1 : 1;
    }
    if (pY && !sY) {
      sY = (pY < 1) ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  },
  handleMouseEnter() {
    const swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave() {
    const swiper = this;
    swiper.mouseEntered = false;
  },
  handle(event) {
    let e = event;
    const swiper = this;
    const params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;

    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;

    const data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
      else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;

    if (params.invert) delta = -delta;

    if (!swiper.params.freeMode) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: Utils.now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event,
      };

      // Keep the most recent events
      const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          swiper.mousewheel.animateSlider(newEvent);
        }
      } else {
        swiper.mousewheel.animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (swiper.mousewheel.releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
      const { lastEventBeforeSnap } = swiper.mousewheel;
      const ignoreWheelEvents = lastEventBeforeSnap
        && newEvent.time < lastEventBeforeSnap.time + 500
        && newEvent.delta <= lastEventBeforeSnap.delta
        && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        swiper.mousewheel.lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }
        let position = swiper.getTranslate() + (delta * params.sensitivity);
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;

        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeModeSticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = undefined;
          const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15
              && newEvent.time - firstEvent.time < 500
              && firstEvent.delta - newEvent.delta >= 1
              && newEvent.delta <= 6
          ) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            swiper.mousewheel.lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            swiper.mousewheel.timeout = Utils.nextTick(() => {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }
          if (!swiper.mousewheel.timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            swiper.mousewheel.timeout = Utils.nextTick(() => {
              const snapToThreshold = 0.5;
              swiper.mousewheel.lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) swiper.emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    return false;
  },
  animateSlider(newEvent) {
    const swiper = this;
    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        swiper.emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      swiper.emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    swiper.mousewheel.lastScrollTime = (new win$1.Date()).getTime();
    // Return false as a default
    return false;
  },
  releaseScroll(newEvent) {
    const swiper = this;
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  },
  enable() {
    const swiper = this;
    const event = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
      return true;
    }
    if (!event) return false;
    if (swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable() {
    const swiper = this;
    const event = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
      return true;
    }
    if (!event) return false;
    if (!swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $(swiper.params.mousewheel.eventsTarged);
    }
    target.off(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  },
};

var Mousewheel$1 = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarged: 'container',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      mousewheel: {
        enabled: false,
        enable: Mousewheel.enable.bind(swiper),
        disable: Mousewheel.disable.bind(swiper),
        handle: Mousewheel.handle.bind(swiper),
        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
        animateSlider: Mousewheel.animateSlider.bind(swiper),
        releaseScroll: Mousewheel.releaseScroll.bind(swiper),
        lastScrollTime: Utils.now(),
        lastEventBeforeSnap: undefined,
        recentWheelEvents: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        swiper.mousewheel.disable();
      }
      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy() {
      const swiper = this;
      if (swiper.params.cssMode) {
        swiper.mousewheel.enable();
      }
      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  onPrevClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = $(params.nextEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.nextEl === 'string'
        && $nextEl.length > 1
        && swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = $(params.prevEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.prevEl === 'string'
        && $prevEl.length > 1
        && swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
        onNextClick: Navigation.onNextClick.bind(swiper),
        onPrevClick: Navigation.onPrevClick.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick
        && !$(e.target).is($prevEl)
        && !$(e.target).is($nextEl)
      ) {
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          swiper.emit('navigationShow', swiper);
        } else {
          swiper.emit('navigationHide', swiper);
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }
        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
      if ($el.length > 1) {
        bullets.each((index, bullet) => {
          const $bullet = $(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
            }
            if (bulletIndex === lastIndex) {
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }
              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              $firstDisplayedBullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
              $lastDisplayedBullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          } else {
            $firstDisplayedBullet
              .prev()
              .addClass(`${params.bulletActiveClass}-prev`)
              .prev()
              .addClass(`${params.bulletActiveClass}-prev-prev`);
            $lastDisplayedBullet
              .next()
              .addClass(`${params.bulletActiveClass}-next`)
              .next()
              .addClass(`${params.bulletActiveClass}-next-next`);
          }
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
    }
    if (params.type === 'progressbar') {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>`
        + ' / '
        + `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = $(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements
      && typeof params.el === 'string'
      && $el.length > 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      swiper.pagination.dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index = $(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable', // NEW
      lockClass: 'swiper-pagination-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
        dynamicBulletIndex: 0,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el
        && swiper.params.pagination.hideOnClick
        && swiper.pagination.$el.length > 0
        && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          swiper.emit('paginationShow', swiper);
        } else {
          swiper.emit('paginationHide', swiper);
        }
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtlTranslate: rtl, progress } = swiper;
    const {
      dragSize, trackSize, $dragEl, $el,
    } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  getPointerPosition(e) {
    const swiper = this;
    if (swiper.isHorizontal()) {
      return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);
    }
    return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar, rtlTranslate: rtl } = swiper;
    const {
      $el,
      dragSize,
      trackSize,
      dragStartPos,
    } = scrollbar;

    let positionRatio;
    positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
      - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
      ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      doc$1.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      doc$1.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      doc$1.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      doc$1.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl } = swiper;
    const params = swiper.params.scrollbar;

    let $el = $(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = $(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const {
      $el, slides, progress, snapGrid,
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, parallaxEl) => {
        const $parallaxEl = $(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;
    if (!Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (Support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
        return;
      }
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (Device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal()
        && (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } if (
        !swiper.isHorizontal()
        && (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }
      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      zoom.currentScale = 1;

      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    const slideSelector = `.${swiper.params.slideClass}`;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    }

    // Move image
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    const slideSelector = `.${swiper.params.slideClass}`;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    }

    // Move image
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };

    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });

    let scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get() {
        return scale;
      },
      set(value) {
        if (scale !== value) {
          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }
        scale = value;
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy = {
  loadInSlide(index, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
      : swiper.slides.eq(index);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = $(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');
      const $pictureEl = $imageEl.parent('picture');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if ($pictureEl.length) {
            $pictureEl.children('source').each((sourceIndex, sourceEl) => {
              const $source = $(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const {
      $wrapperEl, params: swiperParams, slides, activeIndex,
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;
      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return $(slideEl).attr('data-swiper-slide-index');
      }
      return $(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy.load.bind(swiper),
        loadInSlide: Lazy.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.cssMode) {
        swiper.lazy.load();
      }
    },
  },
};

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

const Controller = {
  LinearSpline: function LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop
        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          Utils.nextTick(() => {
            c.updateAutoHeight();
          });
        }
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = $(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop || !swiper.navigation) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
        swiper.a11y.makeElNotFocusable($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
        swiper.a11y.makeElFocusable($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
        swiper.a11y.makeElNotFocusable($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
        swiper.a11y.makeElFocusable($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = $(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

const History = {
  init() {
    const swiper = this;
    if (!swiper.params.history) return;
    if (!win$1.history || !win$1.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    const history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues();
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      win$1.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy() {
    const swiper = this;
    if (!swiper.params.history.replaceState) {
      win$1.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState() {
    const swiper = this;
    swiper.history.paths = History.getPathValues();
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues() {
    const pathArray = win$1.location.pathname.slice(1).split('/').filter((part) => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return { key, value };
  },
  setHistory(key, index) {
    const swiper = this;
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    const slide = swiper.slides.eq(index);
    let value = History.slugify(slide.attr('data-history'));
    if (!win$1.location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    const currentState = win$1.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      win$1.history.replaceState({ value }, null, value);
    } else {
      win$1.history.pushState({ value }, null, value);
    }
  },
  slugify(text) {
    return text.toString()
      .replace(/\s+/g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  },
  scrollToSlide(speed, value, runCallbacks) {
    const swiper = this;
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = History.slugify(slide.attr('data-history'));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  },
};

var History$1 = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      replaceState: false,
      key: 'slides',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      history: {
        init: History.init.bind(swiper),
        setHistory: History.setHistory.bind(swiper),
        setHistoryPopState: History.setHistoryPopState.bind(swiper),
        scrollToSlide: History.scrollToSlide.bind(swiper),
        destroy: History.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.history.initialized && swiper.params.cssMode) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
  },
};

const HashNavigation = {
  onHashCange() {
    const swiper = this;
    swiper.emit('hashChange');
    const newHash = doc$1.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash() {
    const swiper = this;
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
    if (swiper.params.hashNavigation.replaceState && win$1.history && win$1.history.replaceState) {
      win$1.history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
      swiper.emit('hashSet');
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      doc$1.location.hash = hash || '';
      swiper.emit('hashSet');
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
    swiper.hashNavigation.initialized = true;
    const hash = doc$1.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      $(win$1).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.params.hashNavigation.watchState) {
      $(win$1).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
};
var HashNavigation$1 = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      hashNavigation: {
        initialized: false,
        init: HashNavigation.init.bind(swiper),
        destroy: HashNavigation.destroy.bind(swiper),
        setHash: HashNavigation.setHash.bind(swiper),
        onHashCange: HashNavigation.onHashCange.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
        swiper.hashNavigation.setHash();
      }
    },
  },
};

/* eslint no-underscore-dangle: "off" */

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
        onVisibilityChange() {
          if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
            swiper.autoplay.pause();
          }
          if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
            swiper.autoplay.run();
            swiper.autoplay.paused = false;
          }
        },
        onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          swiper.autoplay.paused = false;
          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd() {
      const swiper = this;
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade
        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const {
      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (Browser.isSafari || Browser.isWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides, rtlTranslate: rtl } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      // eslint-disable-next-line
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const {
      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = ((parseFloat(params.stretch) / 100) * slideSize);
      }
      let translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);
      let translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;

      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (Support.pointerEvents || Support.prefixedPointerEvents) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

const Thumbs = {
  init() {
    const swiper = this;
    const { thumbs: thumbsParams } = swiper.params;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Utils.extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
      Utils.extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
    } else if (Utils.isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      }));
      swiper.thumbs.swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
  },
  onThumbClick() {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
      else slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  },
  update(initial) {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;

    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
      ? thumbsSwiper.slidesPerViewDynamic()
      : thumbsSwiper.params.slidesPerView;

    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          // eslint-disable-next-line
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        // Find actual thumbs index to slide to
        const prevThumbsIndex = thumbsSwiper.slides
          .eq(currentThumbsIndex)
          .prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
          .index();
        const nextThumbsIndex = thumbsSwiper.slides
          .eq(currentThumbsIndex)
          .nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
          .index();
        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;
        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;
        else newThumbsIndex = prevThumbsIndex;
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex) {
          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);

    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
  },
};
var Thumbs$1 = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      thumbs: {
        swiper: null,
        init: Thumbs.init.bind(swiper),
        update: Thumbs.update.bind(swiper),
        onThumbClick: Thumbs.onThumbClick.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      const { thumbs } = swiper.params;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition(duration) {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy() {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    },
  },
};

// Swiper Class

const components = [
  Device$1,
  Support$1,
  Browser$1,
  Resize,
  Observer$1,
  Virtual$1,
  Keyboard$1,
  Mousewheel$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$1,
  Controller$1,
  A11y,
  History$1,
  HashNavigation$1,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow,
  Thumbs$1
];

if (typeof Swiper.use === 'undefined') {
  Swiper.use = Swiper.Class.use;
  Swiper.installModule = Swiper.Class.installModule;
}

Swiper.use(components);

function formatWheelData(wheelData, lengthStore) {
  lengthStore.maxLen = _$1.max([lengthStore.maxLen, lengthStore.tempLen]);
  return _$1.map(wheelData, function (item) {
    if (_$1.isPlainObject(item)) {
      if (_$1.isArray(item.children) && item.children.length) {
        lengthStore.tempLen++;
        item.text = String(item.text);
        item.children = formatWheelData(item.children, lengthStore);
      }

      lengthStore.tempLen = 0;
      return item;
    } else {
      lengthStore.tempLen = 0;
      return {
        text: item.toString(),
        value: item
      };
    }
  });
}

function formatData(data) {
  var lengthStore = {
    maxLen: 0
  };
  return _$1.map(data, function (whleeData, index) {
    return formatWheelData(whleeData, _$1.assign(lengthStore, {
      tempLen: index + 1
    }));
  }).concat(_$1.fill(Array(lengthStore.maxLen - data.length), [{
    text: '',
    value: undefined
  }]));
}

function getInitData(data, value) {
  console.log('innit');
  var pickerData = formatData(_$1.every(data, _$1.isArray) ? data : [data]);
  var valueList = _$1.isArray(value) ? value : [value];
  var pickerSelectIndex = [];
  var wheelStore = [pickerData[0]];

  var _loop = function _loop(index) {
    var item = pickerData[index];

    var activeIndex = _$1.findIndex(item, function (item) {
      return _$1.isEqual(item.value, valueList[index]);
    });

    activeIndex = ~activeIndex ? activeIndex : 0;
    pickerSelectIndex[index] = activeIndex;

    var chiildrenData = _$1.get(item, "[".concat(activeIndex, "].children"));

    if (chiildrenData) {
      wheelStore[index + 1] = pickerData[index + 1] || [];
      pickerData[index + 1] = chiildrenData;
    } else if (index < pickerData.length - 1) {
      wheelStore[index + 1] = pickerData[index + 1] || [];
    }
  };

  for (var index = 0; index < pickerData.length; index++) {
    _loop(index);
  }

  return {
    pickerData: pickerData,
    pickerSelectIndex: pickerSelectIndex,
    wheelStore: wheelStore
  };
}

var script$d = {
  name: 'cmui-picker',
  methodName: 'picker',
  argumentsRole: function argumentsRole(options, args) {
    options.title = _$1.find(args, _$1.isString);
    options.data = _$1.find(args, _$1.isArray);
    options.rightFn = _$1.find(args, _$1.isFunction);
    options.leftFn = _$1.filter(args, _$1.isFunction)[1];
  },
  components: {
    cmuiPopup: __vue_component__
  },
  props: {
    data: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '要展示的数据'
    },
    visible: {
      type: Boolean,
      default: false,
      intro: '是否可见需要配合sync使用'
    },
    rightFn: {
      type: Function,
      default: null,
      intro: '点击右侧文字时的事件'
    },
    leftFn: {
      type: Function,
      default: null,
      intro: '点击左侧文字时的事件'
    },
    title: {
      type: String,
      default: '',
      intro: '标题文字'
    },
    leftText: {
      type: String,
      default: '取消',
      intro: '左侧文字'
    },
    rightText: {
      type: String,
      default: '确定',
      intro: '右侧文字'
    },
    value: {
      type: [String, Object, Number, Array],
      default: function _default() {
        return '';
      },
      intro: 'v-model绑定的值'
    }
  },
  data: function data() {
    return getInitData(this.data, this.value);
  },
  computed: {
    selfVisible: {
      get: function get() {
        this.visible && this.setData(this.data);
        return this.visible;
      },
      set: function set(value) {
        var _this2 = this;

        this.wheels = this.wheels || [];

        if (value && !this.wheels.length) {
          this.$nextTick(function () {
            _$1.forEach(_this2.pickerData, function (item, index) {
              _this2.initWheel(index);
            });
          });
        }

        this.$emit('update:visible', value);
      }
    }
  },
  watch: {
    data: function data(value) {
      this.setData(value);
    }
  },
  methods: {
    initWheel: function initWheel() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var _this = this;

      var initialSlide = this.pickerSelectIndex[index] || 0;
      var isInit = true;
      var wheelWrapper = this.$refs.wheelWrapper;
      _this.wheels[index] = new Swiper(wheelWrapper.children[index], {
        direction: 'vertical',
        centeredSlides: true,
        slidesPerView: 'auto',
        initialSlide: initialSlide,
        freeModeSticky: true,
        // 自动贴合
        freeMode: true,
        freeModeMomentumRatio: 0.7,
        // 当释放slide时的滑动时间
        freeModeMomentumVelocityRatio: 0.3,
        // 释放后滑动速度
        freeModeMomentumBounceRatio: 2,
        // 边界反弹效果
        on: {
          transitionEnd: function transitionEnd() {
            if (!isInit) {
              _this.updateData(index, this.activeIndex);

              _this.updataWheels(index + 1);
            } else {
              isInit = false;
            }
          }
        }
      });
    },
    updateData: function updateData(index, active) {
      if (index >= this.pickerSelectIndex.length) {
        return;
      } // if(!_.get(this,`pickerData[${index}][${active}]`)){
      //   active=0;
      // }


      this.pickerSelectIndex[index] = active;

      var children = _$1.get(this, "pickerData[".concat(index, "][").concat(active, "].children"));

      if (children) {
        if (!_$1.isEqual(this.pickerData[index + 1], children)) {
          this.pickerData.splice(index + 1, 1, children);
        } else {
          index++;
        }

        this.updateData(index + 1, this.pickerSelectIndex[index + 1]);
      } else {
        while (this.pickerData[++index]) {
          this.pickerData.splice(index, 1, this.wheelStore[index]);
        }
      }
    },
    updataWheels: function updataWheels() {
      var _this3 = this;

      var fromIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.$nextTick(function () {
        for (var item; item = _this3.wheels[fromIndex++];) {
          item.updateSlides();
          item.slideTo(_this3.pickerSelectIndex[fromIndex - 1], false);
        }
      });
    },
    destroyWheels: function destroyWheels() {
      _$1.forEach(this.wheels, function (item) {
        item.destroy(false, false);
      });

      this.wheels = [];
    },
    getData: function getData() {
      var _this = this;

      return _$1.map(this.wheels, function (item, index) {
        return {
          text: _this.pickerData[index][item.activeIndex].text,
          value: _this.pickerData[index][item.activeIndex].value
        };
      });
    },
    setData: function setData(data) {
      var _this4 = this;

      _$1.delay(function () {
        _this4.destroyWheels();

        _$1.assign(_this4, getInitData(data, _this4.value));

        _this4.$nextTick(function () {
          _$1.forEach(_this4.pickerData, function (item, index) {
            _this4.initWheel(index);
          });
        });
      });
    },
    _ok: function _ok() {
      var data = this.getData();

      if (_$1.isFunction(this.rightFn)) {
        if (this.rightFn(data, this) !== false) {
          this.selfVisible = false;
        }
      } else {
        this.selfVisible = false;
      }

      this.$emit('input', _$1.isArray(this.value) ? data.map(function (item) {
        return item.value;
      }) : data.map(function (item) {
        return item.value;
      })[0]);
      this.$emit('select', data, this);
    },
    _cancel: function _cancel() {
      if (_$1.isFunction(this.leftFn)) {
        if (this.leftFn(this) !== false) {
          this.selfVisible = false;
        }
      } else {
        this.selfVisible = false;
      }

      this.$emit('cancel', this);
    }
  }
};

var css_248z$7 = ".cmui-picker__wrapper{height:200px}.cmui-picker__item{font-size:20px;line-height:1.5}.cmui-picker__lineb,.cmui-picker__linet{height:84.5px;position:absolute;pointer-events:none;z-index:9}.cmui-picker__linet{border-bottom:1px solid #ccc;background-image:-webkit-linear-gradient(#fff,hsla(0,0%,100%,0));background-image:-webkit-linear-gradient(white, rgba(255, 255, 255, 0));background-image:linear-gradient(#fff,hsla(0,0%,100%,0))}.cmui-picker__lineb{border-top:1px solid #ccc;background-image:-webkit-linear-gradient(hsla(0,0%,100%,0),#fff);background-image:-webkit-linear-gradient(rgba(255, 255, 255, 0), white);background-image:linear-gradient(hsla(0,0%,100%,0),#fff)}";
styleInject(css_248z$7);

/* script */
const __vue_script__$d = script$d;
/* template */
var __vue_render__$d = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-popup",
    {
      staticClass: "cmui-picker",
      attrs: {
        position: "bottom",
        visible: _vm.selfVisible,
        "target-class": "cmui-picker__container"
      },
      on: {
        "update:visible": function($event) {
          _vm.selfVisible = $event;
        }
      }
    },
    [
      _c("div", { staticClass: "flex-container cmui-picker__head" }, [
        _c("div", { staticClass: "cmui-picker__cancel" }, [
          _c(
            "div",
            {
              staticClass: "cmui-picker__btn",
              on: {
                click: function($event) {
                  return _vm._cancel()
                }
              }
            },
            [_vm._v("\n            " + _vm._s(_vm.leftText) + "\n            ")]
          )
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "flex1 text-center cmui-picker__title" }, [
          _vm._v("\n        " + _vm._s(_vm.title) + "\n        ")
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "cmui-picker__ok" }, [
          _c(
            "div",
            {
              staticClass: "cmui-picker__btn",
              on: {
                click: function($event) {
                  return _vm._ok()
                }
              }
            },
            [
              _vm._v(
                "\n            " + _vm._s(_vm.rightText) + "\n            "
              )
            ]
          )
        ])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "pos-r cmui-picker__content" }, [
        _c(
          "div",
          {
            ref: "wheelWrapper",
            staticClass: "cmui-picker__wrapper flex-container vfull overflow-h"
          },
          _vm._l(_vm.pickerData, function(item, index) {
            return _c(
              "div",
              { key: index, staticClass: "flex1 swiper-container" },
              [
                _c(
                  "ul",
                  { staticClass: "cmui-picker__scroll swiper-wrapper" },
                  _vm._l(item, function(inner, indexInner) {
                    return _c(
                      "li",
                      {
                        key: indexInner,
                        staticClass:
                          "cmui-picker__item text-center swiper-slide text-limit1",
                        staticStyle: { height: "auto" }
                      },
                      [
                        _vm._v(
                          "\n                    " +
                            _vm._s(inner.text) +
                            "\n                    "
                        )
                      ]
                    )
                  }),
                  0
                )
              ]
            )
          }),
          0
        ),
        _vm._v(" "),
        _c("div", { staticClass: "cmui-picker__linet abs-top" }),
        _vm._v(" "),
        _c("div", { staticClass: "cmui-picker__lineb abs-bottom" })
      ])
    ]
  )
};
var __vue_staticRenderFns__$d = [];
__vue_render__$d._withStripped = true;

  /* style */
  const __vue_inject_styles__$d = undefined;
  /* scoped */
  const __vue_scope_id__$d = undefined;
  /* module identifier */
  const __vue_module_identifier__$d = undefined;
  /* functional template */
  const __vue_is_functional_template__$d = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$d = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
    __vue_inject_styles__$d,
    __vue_script__$d,
    __vue_scope_id__$d,
    __vue_is_functional_template__$d,
    __vue_module_identifier__$d,
    false,
    undefined,
    undefined,
    undefined
  );

function formateData(data) {
  if (!_$1.isArray(data)) {
    return [];
  } else {
    return data.map(function (item) {
      if (_$1.isPlainObject(item)) {
        return _$1.defaults(item, {
          text: '',
          value: undefined
        });
      } else {
        return {
          text: item.toString(),
          value: item.valueOf()
        };
      }
    });
  }
}

var script$e = {
  name: 'cmui-select',
  components: {
    cmuiPicker: __vue_component__$d
  },
  mixins: [mixin],
  props: {
    reset: {
      type: Boolean,
      default: true,
      intro: '是否显示充值按钮'
    },
    prepend: {
      type: String,
      default: '',
      intro: '前置文本内容'
    },
    append: {
      type: String,
      default: '',
      intro: '后置文本内容'
    },
    prependDisabled: {
      type: Boolean,
      default: false,
      intro: '是否禁用前置文本'
    },
    appendDisabled: {
      type: Boolean,
      default: false,
      intro: '是否禁用后置文本'
    },
    data: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '需要绑定的数据'
    },
    picker: {
      type: Boolean,
      default: false,
      intro: '是否启用picker模式'
    },
    width: {
      type: [Number, String],
      default: 0,
      intro: '设置宽度'
    }
  },
  data: function data() {
    return {
      visible: false
    };
  },
  computed: {
    inputStyle: function inputStyle() {
      var style = {};

      if (this.$slots.prepend || this.prepend || this.reverse) {
        style.borderTopLeftRadius = '0px';
        style.borderBottomLeftRadius = '0px';
      }

      if (this.$slots.append || this.append || this.reverse) {
        style.borderTopRightRadius = '0px';
        style.borderBottomRightRadius = '0px';
      }

      if (this.reset) {
        style.paddingRight = '40px';
      }

      if (this.type === 'search') {
        style.paddingLeft = '40px';
      }

      if (this.width) {
        style.width = this.width + 'px';
      }

      return style;
    },
    selfData: function selfData() {
      return formateData(this.data);
    },
    selfValue: {
      get: function get() {
        return this.value;
      },
      set: function set(value) {
        var target = this.$refs.select;
        this.$emit('change', value, target, this);
        this.$emit('input', value, target, this);
      }
    }
  },
  methods: {
    select: function select(data) {
      this.selfValue = data[0].value;
    }
  }
};

var css_248z$8 = ".cmui-select .cmui-select__append[data-v-e7d4bec8],.cmui-select .cmui-select__prepend[data-v-e7d4bec8]{background-color:#eee;border:1px solid #ccc}.cmui-select .cmui-select__append.reverse[data-v-e7d4bec8],.cmui-select .cmui-select__prepend.reverse[data-v-e7d4bec8]{border-color:transparent transparent #ccc;background-color:initial}.cmui-select .cmui-select__append.disabled[data-v-e7d4bec8],.cmui-select .cmui-select__prepend.disabled[data-v-e7d4bec8]{color:#bbb}.cmui-select .cmui-select__append>[data-v-e7d4bec8]:not(:first-child),.cmui-select .cmui-select__prepend>[data-v-e7d4bec8]:not(:first-child){border-left:1px solid #ccc;padding-left:10px}.cmui-select .cmui-select__append select[data-v-e7d4bec8],.cmui-select .cmui-select__prepend select[data-v-e7d4bec8]{border:none}.cmui-select .cmui-select__append .cmui-select select[data-v-e7d4bec8],.cmui-select .cmui-select__prepend .cmui-select select[data-v-e7d4bec8]{padding:0;padding-right:16px!important;background-position-x:right}.cmui-select .cmui-select__prepend[data-v-e7d4bec8]{margin-right:-1px}.cmui-select .cmui-select__prepend.radius[data-v-e7d4bec8]{border-radius:4px 0 0 4px}.cmui-select .cmui-select__prepend.radius.reverse[data-v-e7d4bec8]{border-radius:0}.cmui-select .cmui-select__append[data-v-e7d4bec8]{margin-left:-1px}.cmui-select .cmui-select__append.radius[data-v-e7d4bec8]{border-radius:0 4px 4px 0}.cmui-select .cmui-select__append.radius.reverse[data-v-e7d4bec8]{border-radius:0}";
styleInject(css_248z$8);

/* script */
const __vue_script__$e = script$e;
/* template */
var __vue_render__$e = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "pos-r cmui-select form flex-container" }, [
    _vm.align === "left" && (_vm.label || _vm.$slots.default)
      ? _c(
          "span",
          {
            staticClass: "cmui-select__label cmui-form__label",
            class: { checked: _vm.value }
          },
          [
            _vm._t("default"),
            _vm._v(" "),
            !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
          ],
          2
        )
      : _vm._e(),
    _vm._v(" "),
    _c("div", { staticClass: "flex-container", class: { flex1: !_vm.flex } }, [
      _vm.$slots.prepend || _vm.prepend
        ? _c(
            "div",
            {
              staticClass: "cmui-select__prepend flex-container",
              class: [_vm.targetClass, { disabled: _vm.prependDisabled }]
            },
            [
              _vm.$slots.prepend ? _vm._t("prepend") : _vm._e(),
              _vm._v(" "),
              _vm.prepend ? _c("span", [_vm._v(_vm._s(_vm.prepend))]) : _vm._e()
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "cmui-select__main pos-r",
          class: { flex1: !_vm.label || !_vm.$slots.default }
        },
        [
          _c(
            "select",
            {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.selfValue,
                  expression: "selfValue"
                }
              ],
              ref: "select",
              class: _vm.targetClass,
              style: _vm.inputStyle,
              attrs: {
                name: _vm.name,
                readonly: _vm.readonly,
                placeholder: _vm.placeholder,
                disabled: _vm.disabled
              },
              on: {
                focus: _vm.handleFocus,
                blur: _vm.handleBlur,
                change: function($event) {
                  var $$selectedVal = Array.prototype.filter
                    .call($event.target.options, function(o) {
                      return o.selected
                    })
                    .map(function(o) {
                      var val = "_value" in o ? o._value : o.value;
                      return val
                    });
                  _vm.selfValue = $event.target.multiple
                    ? $$selectedVal
                    : $$selectedVal[0];
                }
              }
            },
            _vm._l(_vm.selfData, function(item, index) {
              return _c("option", {
                key: index,
                domProps: { value: item.value, textContent: _vm._s(item.text) }
              })
            }),
            0
          ),
          _vm._v(" "),
          _vm.picker && !_vm.disabled
            ? _c("div", {
                staticClass: "abs-full",
                on: {
                  click: function($event) {
                    _vm.visible = !_vm.visible;
                  }
                }
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.picker && !_vm.disabled
            ? _c("cmui-picker", {
                attrs: { visible: _vm.visible, data: _vm.data },
                on: {
                  "update:visible": function($event) {
                    _vm.visible = $event;
                  },
                  select: _vm.select
                },
                model: {
                  value: _vm.selfValue,
                  callback: function($$v) {
                    _vm.selfValue = $$v;
                  },
                  expression: "selfValue"
                }
              })
            : _vm._e()
        ],
        1
      ),
      _vm._v(" "),
      _vm.$slots.append || _vm.append
        ? _c(
            "div",
            {
              staticClass: "cmui-select__append flex-container",
              class: [_vm.targetClass, { disabled: _vm.appendDisabled }]
            },
            [
              _vm.$slots.append ? _vm._t("append") : _vm._e(),
              _vm._v(" "),
              _vm.append
                ? _c("span", { domProps: { textContent: _vm._s(_vm.append) } })
                : _vm._e()
            ],
            2
          )
        : _vm._e()
    ]),
    _vm._v(" "),
    _vm.align === "right" && (_vm.label || _vm.$slots.default)
      ? _c(
          "span",
          {
            staticClass: "cmui-select__label cmui-form__label",
            class: { checked: _vm.value }
          },
          [
            _vm._t("default"),
            _vm._v(" "),
            !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e()
          ],
          2
        )
      : _vm._e()
  ])
};
var __vue_staticRenderFns__$e = [];
__vue_render__$e._withStripped = true;

  /* style */
  const __vue_inject_styles__$e = undefined;
  /* scoped */
  const __vue_scope_id__$e = "data-v-e7d4bec8";
  /* module identifier */
  const __vue_module_identifier__$e = undefined;
  /* functional template */
  const __vue_is_functional_template__$e = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$e = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
    __vue_inject_styles__$e,
    __vue_script__$e,
    __vue_scope_id__$e,
    __vue_is_functional_template__$e,
    __vue_module_identifier__$e,
    false,
    undefined,
    undefined,
    undefined
  );

var script$f = {
  name: 'cmui-number',
  components: {
    cmuiInput: __vue_component__$c
  },
  mixins: [mixin],
  props: {
    max: {
      type: Number,
      default: Infinity,
      intro: '允许输入的最大值'
    },
    min: {
      type: Number,
      default: -Infinity,
      intro: '允许输入的最小值'
    },
    canAdd: {
      type: Boolean,
      default: true,
      intro: '加号按钮是否可以点击'
    },
    canSub: {
      type: Boolean,
      default: true,
      intro: '减号按钮是否可以点击'
    },
    beforeChange: {
      type: Function,
      default: null,
      intro: '输入框内容发生变化前要执行的函数'
    },
    width: {
      type: [Number, String],
      default: '',
      intro: '设置宽度'
    },
    step: {
      type: Number,
      default: 1,
      intro: '设置步长'
    },
    precision: {
      type: Number,
      default: 0,
      intro: '设置精度'
    }
  },
  data: function data() {
    return {
      canSubSelf: this.canSub,
      canAddSelf: this.canAdd,
      selfValue: (+this.value).toFixed(this.precision)
    };
  },
  computed: {
    canMax: function canMax() {
      if (this.max || this.max === 0) {
        return this.value < this.max;
      } else {
        return true;
      }
    },
    canMin: function canMin() {
      if (this.min || this.min === 0) {
        return this.value > this.min;
      } else {
        return true;
      }
    }
  },
  watch: {
    value: function value(_value) {
      this.setBtnState();
      this.selfValue = (+_value).toFixed(this.precision);
      console.log(arguments);
    },
    max: function max() {
      this.setBtnState();
    },
    min: function min() {
      this.setBtnState();
    },
    canSub: function canSub(value) {
      this.canSubSelf = !!value;
    },
    canAdd: function canAdd(value) {
      this.canAddSelf = !!value;
    }
  },
  created: function created() {
    this.setBtnState(true); // this.setBtnState.call(this, true)
  },
  methods: {
    changeNumber: function changeNumber() {
      var _this = this;

      var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (!(this.canAddSelf && this.canAdd) && num === 1 || !(this.canSubSelf && this.canSub) && num === -1) {
        return;
      }

      var value = this.selfValue;
      var beforeChangeEvent = this.$listeners['before-change'];
      var targetValue = +value + num * this.step;
      targetValue = targetValue.toFixed(this.precision);
      targetValue = _$1.min([this.max, targetValue]);
      targetValue = _$1.max([this.min, targetValue]);

      if (_$1.isFunction(beforeChangeEvent)) {
        this.canAddSelf = this.canSubSelf = false;
        new Promise(function (resolve, reject) {
          beforeChangeEvent(targetValue, resolve, reject, _this);
        }).then(function () {
          _this.selfValue = targetValue;

          _this.setBtnState();

          _this.$emit('input', _this.selfValue, _this);
        }, function () {
          _this.setBtnState();

          _this.$emit('input', _this.selfValue, _this);
        });
      } else {
        this.selfValue = targetValue;
        this.setBtnState();
        this.$emit('input', this.selfValue, this);
      }
    },
    setBtnState: function setBtnState() {
      var isFirst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.canAddSelf = this.canSubSelf = true;

      switch (true) {
        case this.selfValue === this.max:
          this.canAddSelf = false;
          !isFirst && this.$emit('max', this.selfValue, this);
          break;

        case this.selfValue === this.min:
          this.canSubSelf = false;
          !isFirst && this.$emit('min', this.selfValue, this);
          break;

        case this.selfValue > this.max:
          this.selfValue = this.max;
          break;

        case this.selfValue < this.min:
          this.selfValue = this.min;
          break;
      }
    },
    handleBlur: function handleBlur() {
      console.log("number handleBlur");
      var target = event.target;
      var value = target.value;
      this.changeNumber(0);
      this.$emit('blur', value, this);
    },
    handleInput: function handleInput(event) {
      console.log("number handleInput");
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('input', value, this);
      this.$nextTick(this.rendered);
      this.setBtnState();
    },
    handleChange: function handleChange(event) {
      console.log("number handleChange");
      var evt = window.event || event;
      var target = evt.target || evt.srcElement;
      var value = target.value;
      this.$emit('change', value, this);
      this.$emit('input', value, this);
      this.setBtnState();
    },
    getInput: function getInput() {
      return this.$children[0].$refs.input;
    }
  }
};

/* script */
const __vue_script__$f = script$f;

/* template */
var __vue_render__$f = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-input",
    {
      ref: "input",
      attrs: {
        type: "number",
        name: _vm.name,
        readonly: _vm.readonly,
        placeholder: _vm.placeholder,
        disabled: _vm.disabled,
        "target-class": _vm.targetClass,
        label: _vm.label,
        align: _vm.align,
        reset: false,
        "prepend-disabled": !(_vm.canSubSelf && _vm.canSub),
        "append-disabled": !(_vm.canAddSelf && _vm.canAdd),
        flex: _vm.flex,
        width: _vm.width
      },
      on: {
        input: _vm.handleInput,
        focus: _vm.handleFocus,
        blur: _vm.handleBlur,
        change: _vm.handleChange
      },
      model: {
        value: _vm.selfValue,
        callback: function($$v) {
          _vm.selfValue = $$v;
        },
        expression: "selfValue"
      }
    },
    [
      _c(
        "span",
        {
          attrs: { slot: "prepend" },
          on: {
            click: function($event) {
              return _vm.changeNumber(-1)
            }
          },
          slot: "prepend"
        },
        [_vm._v("-")]
      ),
      _vm._v(" "),
      _c(
        "span",
        {
          attrs: { slot: "append" },
          on: {
            click: function($event) {
              return _vm.changeNumber(1)
            }
          },
          slot: "append"
        },
        [_vm._v("+")]
      ),
      _vm._v(" "),
      _vm._t("default")
    ],
    2
  )
};
var __vue_staticRenderFns__$f = [];
__vue_render__$f._withStripped = true;

  /* style */
  const __vue_inject_styles__$f = undefined;
  /* scoped */
  const __vue_scope_id__$f = undefined;
  /* module identifier */
  const __vue_module_identifier__$f = undefined;
  /* functional template */
  const __vue_is_functional_template__$f = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$f = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
    __vue_inject_styles__$f,
    __vue_script__$f,
    __vue_scope_id__$f,
    __vue_is_functional_template__$f,
    __vue_module_identifier__$f,
    false,
    undefined,
    undefined,
    undefined
  );

var script$g = {
  name: 'cmui-checkbox',
  mixins: [mixin],
  props: {
    path: {
      type: String,
      default: '',
      intro: '当v-model设置为数组的时候用于指定匹配项的路径'
    },
    value: {
      type: [Object, String, Number, Boolean, Array],
      default: false
    },
    label: {
      type: [String, Number, Boolean],
      default: ''
    }
  },
  inject: {
    cmuiCheckboxGroup: {
      default: ''
    }
  },
  data: function data() {
    return {
      indeterminate: false,
      innerDisabled: false,
      isBtn: !!~(this.cmuiCheckboxGroup.targetClass || this.targetClass).split(' ').indexOf('btn'),
      isExceedLimit: false
    };
  },
  computed: {
    model: {
      get: function get() {
        var _this = this;

        var value = this.value;

        if (_$1.isArray(value)) {
          var allTrue = _$1.every(this.value, function (item) {
            return (_$1.isObject(item) ? _$1.get(item, _this.path) : item) === true;
          });

          var allFalse = _$1.every(this.value, function (item) {
            return (_$1.isObject(item) ? _$1.get(item, _this.path) : item) === false;
          });

          this.indeterminate = !(allTrue || allFalse);
          return allTrue;
        } else {
          return this.inGroup ? this.cmuiCheckboxGroup.value : !!value;
        }
      },
      set: function set(value) {
        if (this.inGroup) {
          var _this$cmuiCheckboxGro = this.cmuiCheckboxGroup,
              min = _this$cmuiCheckboxGro.min,
              max = _this$cmuiCheckboxGro.max;
          this.isExceedLimit = !_$1.inRange(value.length, min - 1, max + 1);
          this.isExceedLimit === false && this.cmuiCheckboxGroup.$emit('input', value);
        }
      }
    },
    selfValue: function selfValue() {
      var _this$$options$propsD = this.$options.propsData,
          value = _this$$options$propsD.value,
          label = _this$$options$propsD.label;
      return value ? _$1.isPlainObject(value) && value.value ? value.value : value : label || this.label;
    },
    selfLabel: function selfLabel() {
      var _this$$options$propsD2 = this.$options.propsData,
          value = _this$$options$propsD2.value,
          label = _this$$options$propsD2.label;
      return _$1.isPlainObject(value) && value.label ? value.label : label || this.label;
    },
    inGroup: function inGroup() {
      return !!this.cmuiCheckboxGroup;
    },
    isLimitDisabled: function isLimitDisabled() {
      if (!this.inGroup) {
        return false;
      } else {
        var _this$cmuiCheckboxGro2 = this.cmuiCheckboxGroup,
            max = _this$cmuiCheckboxGro2.max,
            min = _this$cmuiCheckboxGro2.min;
        return !!(max || min) && (this.model.length >= max && !this.isChecked || this.model.length <= min && this.isChecked);
      }
    },
    isDisabled: function isDisabled() {
      return this.disabled || this.innerDisabled || this.isLimitDisabled || (this.cmuiForm || {}).disabled || (this.cmuiCheckboxGroup || {}).disabled;
    },
    isChecked: function isChecked() {
      if (_$1.isBoolean(this.model)) {
        return this.model;
      } else if (_$1.isArray(this.model)) {
        return _$1.includes(this.model, this.label);
      }

      return false;
    }
  },
  watch: {
    indeterminate: function indeterminate(value) {
      var dom = this.$refs.checkbox;

      if (dom) {
        dom.indeterminate = value;
      }
    }
  },
  methods: {
    handleChange: function handleChange(event) {
      var _this2 = this;

      if (this.isExceedLimit) return;
      var target = event.target;
      var value = target.checked;
      var beforeChangeEvent = this.$listeners['before-change'];

      if (_$1.isFunction(beforeChangeEvent)) {
        this.innerDisabled = true;
        new Promise(function (resolve, reject) {
          beforeChangeEvent(value, resolve, reject, _this2);
        }).then(function () {
          if (_$1.isArray(_this2.value)) {
            var length = _this2.value.length;

            if (_$1.every(_this2.value, _$1.isBoolean)) {
              _this2.value = new Array(length).fill(value);
            } else {
              _$1.forEach(_this2.value, function (item) {
                _$1.set(item, _this2.path, value);
              });
            }
          }

          _this2.$emit('input', value, _this2);

          _this2.$emit('change', value, _this2);

          _this2.innerDisabled = false;
        }, function () {
          target.checked = !target.checked;
          _this2.innerDisabled = false;
        });
      } else {
        if (_$1.isArray(this.value)) {
          var length = this.value.length;

          if (_$1.every(this.value, _$1.isBoolean)) {
            this.$emit('input', new Array(length).fill(value), this);
          } else {
            this.value.forEach(function (item) {
              return _$1.set(item, _this2.path, value);
            });
          }
        } else {
          this.$emit('input', value, this);
        }

        this.$emit('change', value, this);
      }

      this.cmuiFormItem && this.cmuiFormItem.$emit('form.change');
    }
  }
};

var css_248z$9 = ".cmui-check__label.checked[data-v-fb6228f4]{color:#00baba}";
styleInject(css_248z$9);

/* script */
const __vue_script__$g = script$g;
/* template */
var __vue_render__$g = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "label",
    {
      staticClass: "cmui-checkbox",
      class: {
        "flex-container": _vm.flex && !_vm.isBtn,
        "dis-i": !_vm.flex || _vm.isBtn,
        "cmui-checkbox__disabled": _vm.isDisabled
      },
      attrs: { for: _vm._uid }
    },
    [
      _vm.align === "left" && !_vm.isBtn
        ? _c(
            "span",
            {
              staticClass: "cmui-check__label",
              class: { checked: _vm.isChecked }
            },
            [
              _vm._t("default"),
              _vm._v(" "),
              !_vm.$slots.default ? [_vm._v(_vm._s(_vm.selfLabel))] : _vm._e()
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.model,
            expression: "model"
          }
        ],
        ref: "checkbox",
        class: [_vm.cmuiCheckboxGroup.targetClass, _vm.targetClass],
        attrs: {
          id: _vm._uid,
          type: "checkbox",
          name: _vm.name,
          readonly: _vm.readonly,
          disabled: _vm.isDisabled,
          label: _vm.isBtn ? _vm.selfLabel : ""
        },
        domProps: {
          value: _vm.selfValue,
          checked: Array.isArray(_vm.model)
            ? _vm._i(_vm.model, _vm.selfValue) > -1
            : _vm.model
        },
        on: {
          change: [
            function($event) {
              var $$a = _vm.model,
                $$el = $event.target,
                $$c = $$el.checked ? true : false;
              if (Array.isArray($$a)) {
                var $$v = _vm.selfValue,
                  $$i = _vm._i($$a, $$v);
                if ($$el.checked) {
                  $$i < 0 && (_vm.model = $$a.concat([$$v]));
                } else {
                  $$i > -1 &&
                    (_vm.model = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
                }
              } else {
                _vm.model = $$c;
              }
            },
            _vm.handleChange
          ]
        }
      }),
      _vm._v(" "),
      _vm.align === "right" && !_vm.isBtn
        ? _c(
            "span",
            {
              staticClass: "cmui-check__label",
              class: { checked: _vm.isChecked }
            },
            [
              _vm._t("default"),
              _vm._v(" "),
              !_vm.$slots.default ? [_vm._v(_vm._s(_vm.selfLabel))] : _vm._e()
            ],
            2
          )
        : _vm._e()
    ]
  )
};
var __vue_staticRenderFns__$g = [];
__vue_render__$g._withStripped = true;

  /* style */
  const __vue_inject_styles__$g = undefined;
  /* scoped */
  const __vue_scope_id__$g = "data-v-fb6228f4";
  /* module identifier */
  const __vue_module_identifier__$g = undefined;
  /* functional template */
  const __vue_is_functional_template__$g = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$g = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
    __vue_inject_styles__$g,
    __vue_script__$g,
    __vue_scope_id__$g,
    __vue_is_functional_template__$g,
    __vue_module_identifier__$g,
    false,
    undefined,
    undefined,
    undefined
  );

var script$h = {
  name: 'cmuiCheckboxGroup',
  inject: {
    cmuiFormItem: {
      default: ''
    },
    cmuiForm: {
      default: ''
    }
  },
  provide: function provide() {
    return {
      cmuiCheckboxGroup: this
    };
  },
  props: {
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: Infinity
    },
    targetClass: {
      type: String,
      default: ''
    }
  },
  computed: {
    isBtn: function isBtn() {
      return _$1.includes(this.targetClass, 'btn');
    }
  },
  watch: {
    value: function value(_value) {
      this.cmuiFormItem && this.cmuiFormItem.$emit('form.change', _value);
    }
  }
};

var css_248z$a = ".cmui-checkbox-group.group .cmui-checkbox{margin-right:0}.cmui-checkbox-group.group .cmui-checkbox:not(:first-child):not(:last-child) input{border-radius:0}.cmui-checkbox-group.group .cmui-checkbox:first-child input{border-top-right-radius:0;border-bottom-right-radius:0}.cmui-checkbox-group.group .cmui-checkbox:last-child input{border-top-left-radius:0;border-bottom-left-radius:0}";
styleInject(css_248z$a);

/* script */
const __vue_script__$h = script$h;
/* template */
var __vue_render__$h = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "cmui-checkbox-group",
      class: { form: !_vm.cmuiForm, "btn-group": _vm.isBtn }
    },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$h = [];
__vue_render__$h._withStripped = true;

  /* style */
  const __vue_inject_styles__$h = undefined;
  /* scoped */
  const __vue_scope_id__$h = undefined;
  /* module identifier */
  const __vue_module_identifier__$h = undefined;
  /* functional template */
  const __vue_is_functional_template__$h = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$h = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
    __vue_inject_styles__$h,
    __vue_script__$h,
    __vue_scope_id__$h,
    __vue_is_functional_template__$h,
    __vue_module_identifier__$h,
    false,
    undefined,
    undefined,
    undefined
  );

var script$i = {
  name: 'cmui-radio',
  mixins: [mixin],
  inject: {
    cmuiRadioGroup: {
      default: ''
    },
    cmuiForm: {
      default: ''
    }
  },
  data: function data() {
    return {
      radioValue: this.value,
      isBtn: !!~(this.cmuiRadioGroup.targetClass || this.targetClass).split(' ').indexOf('btn')
    };
  },
  computed: {
    isDisabled: function isDisabled() {
      return this.disabled || (this.cmuiForm || {}).disabled || (this.cmuiRadioGroup || {}).disabled;
    },
    inGroup: function inGroup() {
      return !!this.cmuiRadioGroup;
    },
    model: {
      get: function get() {
        return this.inGroup ? this.cmuiRadioGroup.value : this.value;
      },
      set: function set(value) {
        if (this.inGroup) {
          this.cmuiRadioGroup.$emit('input', value);
        } else {
          this.$emit('input', value);
        }

        this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);
      }
    },
    labelStyle: function labelStyle() {
      var style = {};

      if (this.isDisabled) {
        style.color = '#ccc';
      }

      return style;
    },
    selflabel: function selflabel() {
      return this.isBtn ? _.get(this, '$slots.default[0].text', this.label) : '';
    }
  }
};

/* script */
const __vue_script__$i = script$i;

/* template */
var __vue_render__$i = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "label",
    {
      staticClass: "cmui-radio",
      class: {
        "flex-container": _vm.flex && !_vm.isBtn,
        "dis-i": !_vm.flex || _vm.isBtn,
        "cmui-checkbox__disabled": _vm.isDisabled
      }
    },
    [
      _vm.align === "left"
        ? _c(
            "span",
            {
              staticClass: "cmui-radio__label",
              class: { checked: _vm.model === _vm.label },
              style: _vm.labelStyle
            },
            [
              !_vm.isBtn ? _vm._t("default") : _vm._e(),
              _vm._v(" "),
              !_vm.$slots.default && !_vm.isBtn
                ? [_vm._v(_vm._s(_vm.label))]
                : _vm._e()
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.model,
            expression: "model"
          }
        ],
        ref: "radio",
        class: [_vm.cmuiRadioGroup.targetClass, _vm.targetClass],
        attrs: {
          type: "radio",
          name: _vm.name,
          readonly: _vm.readonly,
          disabled: _vm.isDisabled,
          label: _vm.selflabel
        },
        domProps: { value: _vm.label, checked: _vm._q(_vm.model, _vm.label) },
        on: {
          change: [
            function($event) {
              _vm.model = _vm.label;
            },
            _vm.handleChange
          ]
        }
      }),
      _vm._v(" "),
      _vm.align === "right"
        ? _c(
            "span",
            {
              staticClass: "cmui-radio__label",
              class: { checked: _vm.label === _vm.model },
              style: _vm.labelStyle
            },
            [
              !_vm.isBtn ? _vm._t("default") : _vm._e(),
              _vm._v(" "),
              !_vm.$slots.default && !_vm.isBtn
                ? [_vm._v(_vm._s(_vm.label))]
                : _vm._e()
            ],
            2
          )
        : _vm._e()
    ]
  )
};
var __vue_staticRenderFns__$i = [];
__vue_render__$i._withStripped = true;

  /* style */
  const __vue_inject_styles__$i = undefined;
  /* scoped */
  const __vue_scope_id__$i = undefined;
  /* module identifier */
  const __vue_module_identifier__$i = undefined;
  /* functional template */
  const __vue_is_functional_template__$i = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$i = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i },
    __vue_inject_styles__$i,
    __vue_script__$i,
    __vue_scope_id__$i,
    __vue_is_functional_template__$i,
    __vue_module_identifier__$i,
    false,
    undefined,
    undefined,
    undefined
  );

var script$j = {
  name: 'cmuiRadioGroup',
  inject: {
    cmuiFormItem: {
      default: ''
    },
    cmuiForm: {
      default: ''
    }
  },
  provide: function provide() {
    return {
      cmuiRadioGroup: this
    };
  },
  props: {
    value: {
      type: [String, Number, Boolean],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    targetClass: {
      type: String,
      default: ''
    }
  },
  computed: {
    isBtn: function isBtn() {
      return _$1.includes(this.targetClass, 'btn');
    }
  },
  watch: {
    value: function value(_value) {
      this.cmuiFormItem && this.cmuiFormItem.$emit('form.change', _value);
    }
  }
};

var css_248z$b = ".cmui-radio-group.group .cmui-radio{margin-right:0}.cmui-radio-group.group .cmui-radio:not(:first-child):not(:last-child) input{border-radius:0}.cmui-radio-group.group .cmui-radio:first-child input{border-top-right-radius:0;border-bottom-right-radius:0}.cmui-radio-group.group .cmui-radio:last-child input{border-top-left-radius:0;border-bottom-left-radius:0}";
styleInject(css_248z$b);

/* script */
const __vue_script__$j = script$j;
/* template */
var __vue_render__$j = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "cmui-radio-group",
      class: { form: !_vm.cmuiForm, "btn-group": _vm.isBtn }
    },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$j = [];
__vue_render__$j._withStripped = true;

  /* style */
  const __vue_inject_styles__$j = undefined;
  /* scoped */
  const __vue_scope_id__$j = undefined;
  /* module identifier */
  const __vue_module_identifier__$j = undefined;
  /* functional template */
  const __vue_is_functional_template__$j = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$j = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j },
    __vue_inject_styles__$j,
    __vue_script__$j,
    __vue_scope_id__$j,
    __vue_is_functional_template__$j,
    __vue_module_identifier__$j,
    false,
    undefined,
    undefined,
    undefined
  );

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var script$k = {
  name: 'cmui-form',
  provide: function provide() {
    return {
      cmuiForm: this
    };
  },
  props: {
    model: {
      type: Object,
      default: null,
      intro: '表单数据对象'
    },
    rules: {
      type: Object,
      default: null,
      intro: '表单验证规则'
    },
    labelPosition: {
      type: String,
      default: 'right',
      intro: '表单域标签的位置，如果值为 left 或者 right 时，则需要设置 label-width'
    },
    labelWidth: {
      type: String,
      default: '',
      intro: '表单标签的宽度，如100px'
    },
    itemSpace: {
      type: String,
      default: '22px',
      intro: '每个item之间的间距，默认为22，如果需要使用targetClass自行设置，可以将该值设置为空'
    },
    inlineMessage: {
      type: Boolean,
      default: false,
      intro: '是否以行内形式展示校验信息'
    },
    statusIcon: {
      type: Boolean,
      default: false,
      intro: '是否在输入框中显示校验结果反馈图标'
    },
    showMessage: {
      type: Boolean,
      default: true,
      intro: '是否显示校验错误信息'
    },
    size: {
      type: String,
      default: '',
      intro: '用于控制该表单内组件的尺寸'
    },
    disabled: {
      type: Boolean,
      default: false,
      intro: '是否禁用该表单内的所有组件'
    },
    validateOnRuleChange: {
      type: Boolean,
      default: true,
      intro: '是否在 rules 属性改变后立即触发一次验证'
    },
    hideRequiredAsterisk: {
      type: Boolean,
      default: false,
      intro: '是否显示必填字段的标签旁边的红色星号'
    }
  },
  data: function data() {
    return {
      fields: [],
      potentialLabelWidthArr: []
    };
  },
  computed: {
    autoLabelWidth: function autoLabelWidth() {
      if (!this.potentialLabelWidthArr.length) return 0;
      var max = Math.max.apply(Math, _toConsumableArray(this.potentialLabelWidthArr));
      return max ? "".concat(max, "px") : '';
    }
  },
  watch: {
    rules: function rules() {
      this.fields.forEach(function (field) {
        field.removeValidateEvents();
        field.addValidateEvents();
      });

      if (this.validateOnRuleChange) {
        this.validate(function () {});
      }
    }
  },
  methods: {
    addField: function addField(field) {
      this.fields.push(field);
    },
    removeField: function removeField(field) {
      _$1.remove(this.fields, function (item) {
        return item === field;
      });
    },
    resetFields: function resetFields() {
      if (!this.model) {
        console.warn('model is required for resetFields to work.');
        return;
      }

      this.fields.forEach(function (field) {
        field.resetField();
      });
    },
    clearValidate: function clearValidate() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var fields = props.length ? typeof props === 'string' ? this.fields.filter(function (field) {
        return props === field.prop;
      }) : this.fields.filter(function (field) {
        return props.indexOf(field.prop) > -1;
      }) : this.fields;
      fields.forEach(function (field) {
        field.clearValidate();
      });
    },
    validate: function validate(callback) {
      var _this = this;

      if (!this.model) {
        console.warn('model is required for validate to work!');
        return;
      }

      var promise;

      if (typeof callback !== 'function' && window.Promise) {
        promise = new window.Promise(function (resolve, reject) {
          callback = function callback(valid) {
            valid ? resolve(valid) : reject(valid);
          };
        });
      }

      var valid = true;
      var count = 0;

      if (this.fields.length === 0 && callback) {
        callback.call(this, true);
      }

      var invalidFields = {};
      this.fields.forEach(function (field) {
        field.validate('', function (message, field) {
          if (message) {
            valid = false;
          }

          invalidFields = _$1.assign({}, invalidFields, field);

          if (typeof callback === 'function' && ++count === _this.fields.length) {
            callback(valid, invalidFields);
          }
        });
      });

      if (promise) {
        return promise;
      }
    },
    validateField: function validateField(props, cb) {
      props = [].concat(props);
      var fields = this.fields.filter(function (field) {
        return props.indexOf(field.prop) !== -1;
      });

      if (!fields.length) {
        console.warn('please pass correct props!');
        return;
      }

      fields.forEach(function (field) {
        field.validate('', cb);
      });
    },
    getLabelWidthIndex: function getLabelWidthIndex(width) {
      var index = this.potentialLabelWidthArr.indexOf(width);

      if (index === -1) {
        throw new Error('unpected width ', width);
      }

      return index;
    },
    registerLabelWidth: function registerLabelWidth(val, oldVal) {
      if (val && oldVal) {
        var index = this.getLabelWidthIndex(oldVal);
        this.potentialLabelWidthArr.splice(index, 1, val);
      } else if (val) {
        this.potentialLabelWidthArr.push(val);
      }
    },
    deregisterLabelWidth: function deregisterLabelWidth(val) {
      var index = this.getLabelWidthIndex(val);
      this.potentialLabelWidthArr.splice(index, 1);
    }
  }
};

/* script */
const __vue_script__$k = script$k;

/* template */
var __vue_render__$k = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "form",
    {
      staticClass: "form cmui-form",
      class: ["cmui-form-label" + _vm.labelPosition],
      attrs: { action: "" }
    },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$k = [];
__vue_render__$k._withStripped = true;

  /* style */
  const __vue_inject_styles__$k = undefined;
  /* scoped */
  const __vue_scope_id__$k = undefined;
  /* module identifier */
  const __vue_module_identifier__$k = undefined;
  /* functional template */
  const __vue_is_functional_template__$k = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$k = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k },
    __vue_inject_styles__$k,
    __vue_script__$k,
    __vue_scope_id__$k,
    __vue_is_functional_template__$k,
    __vue_module_identifier__$k,
    false,
    undefined,
    undefined,
    undefined
  );

var max$1 = Math.max;
var min$2 = Math.min;
var floor$1 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
_fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = _anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = _regexpExecAbstract(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max$1(min$2(_toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = _toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor$1(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/* eslint no-console:0 */
var formatRegExp = /%[sdj%]/g;
var warning = function warning() {}; // don't print warning message when in production env or node runtime

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn) {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function (error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var i = 1;
  var f = args[0];
  var len = args.length;

  if (typeof f === 'function') {
    return f.apply(null, args.slice(1));
  }

  if (typeof f === 'string') {
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });
    return str;
  }

  return f;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}

var AsyncValidationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncValidationError, _Error);

  function AsyncValidationError(errors, fields) {
    var _this;

    _this = _Error.call(this, 'Async Validation Error') || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }

  return AsyncValidationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback) {
  if (option.first) {
    var _pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve();
      };

      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });

    _pending["catch"](function (e) {
      return e;
    });

    return _pending;
  }

  var firstFields = option.firstFields || [];

  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }

  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function (resolve, reject) {
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve();
      }
    };

    if (!objArrKeys.length) {
      callback(results);
      resolve();
    }

    objArrKeys.forEach(function (key) {
      var arr = objArr[key];

      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function (e) {
    return e;
  });
  return pending;
}
function complementError(rule) {
  return function (oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }

    return {
      message: typeof oe === 'function' ? oe() : oe,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if (typeof value === 'object' && typeof target[s] === 'object') {
          target[s] = _extends(_extends({}, target[s]), value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}

/**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
}

/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
}

/* eslint max-len:0 */

var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return typeof value === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === 'string' && !!value.match(pattern.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern.hex);
  }
};
/**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    required(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
}

/**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}

var ENUM = 'enum';
/**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];

  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
  }
}

/**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function pattern$1(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}

var rules = {
  required: required,
  whitespace: whitespace,
  type: type,
  range: range,
  "enum": enumerable,
  pattern: pattern$1
};

/**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
}

/**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (value === '') {
      value = undefined;
    }

    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'array') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'array');

    if (!isEmptyValue(value, 'array')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

var ENUM$1 = 'enum';
/**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable$1(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules[ENUM$1](rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function pattern$2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      rules.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value, 'date') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'date')) {
      var dateObject;

      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }

      rules.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
}

function required$1(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value;
  rules.required(rule, value, source, errors, options, type);
  callback(errors);
}

function type$1(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

/**
 *  Performs validation for any type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function any(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);
  }

  callback(errors);
}

var validators = {
  string: string,
  method: method,
  number: number,
  "boolean": _boolean,
  regexp: regexp,
  integer: integer,
  "float": floatFn,
  array: array,
  object: object,
  "enum": enumerable$1,
  pattern: pattern$2,
  date: date,
  url: type$1,
  hex: type$1,
  email: type$1,
  required: required$1,
  any: any
};

function newMessages() {
  return {
    "default": 'Validation error on field %s',
    required: '%s is required',
    "enum": '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();

/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

function Schema(descriptor) {
  this.rules = null;
  this._messages = messages;
  this.define(descriptor);
}

Schema.prototype = {
  messages: function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  },
  define: function define(rules) {
    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if (typeof rules !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    var z;
    var item;

    for (z in rules) {
      if (rules.hasOwnProperty(z)) {
        item = rules[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_, o, oc) {
    var _this = this;

    if (o === void 0) {
      o = {};
    }

    if (oc === void 0) {
      oc = function oc() {};
    }

    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }

      return Promise.resolve();
    }

    function complete(results) {
      var i;
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          var _errors;

          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }

      for (i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        fields = convertFieldsError(errors);
      }

      callback(errors, fields);
    }

    if (options.messages) {
      var messages$1 = this.messages();

      if (messages$1 === messages) {
        messages$1 = newMessages();
      }

      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }

    var arr;
    var value;
    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      arr = _this.rules[z];
      value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = _extends({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }

        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);

        if (!rule.validator) {
          return;
        }

        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullfield(key, schema) {
        return _extends(_extends({}, schema), {}, {
          fullField: rule.fullField + "." + key
        });
      }

      function cb(e) {
        if (e === void 0) {
          e = [];
        }

        var errors = e;

        if (!Array.isArray(errors)) {
          errors = [errors];
        }

        if (!options.suppressWarning && errors.length) {
          Schema.warning('async-validator:', errors);
        }

        if (errors.length && rule.message) {
          errors = [].concat(rule.message);
        }

        errors = errors.map(complementError(rule));

        if (options.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }

        if (!deep) {
          doIt(errors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message) {
              errors = [].concat(rule.message).map(complementError(rule));
            } else if (options.error) {
              errors = [options.error(rule, format(options.messages.required, rule.field))];
            }

            return doIt(errors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }

          fieldsSchema = _extends(_extends({}, fieldsSchema), data.rule.fields);

          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }

          var schema = new Schema(fieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            var finalErrors = [];

            if (errors && errors.length) {
              finalErrors.push.apply(finalErrors, errors);
            }

            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }

            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }

      var res;

      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options);

        if (res === true) {
          cb();
        } else if (res === false) {
          cb(rule.message || rule.field + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return validators.required;
    }

    return validators[this.getType(rule)] || false;
  }
};

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  validators[type] = validator;
};

Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

var script$l = {
  props: {
    isAutoWidth: {
      type: Boolean,
      defalut: false
    },
    updateAll: {
      type: Boolean,
      defalut: false
    }
  },
  inject: ['cmuiForm', 'cmuiFormItem'],
  data: function data() {
    return {
      computedWidth: 0
    };
  },
  watch: {
    computedWidth: function computedWidth(val, oldVal) {
      if (this.updateAll) {
        this.cmuiForm.registerLabelWidth(val, oldVal);
        this.cmuiFormItem.updateComputedLabelWidth(val);
      }
    }
  },
  mounted: function mounted() {
    this.updateLabelWidth('update');
  },
  updated: function updated() {
    this.updateLabelWidth('update');
  },
  beforeDestroy: function beforeDestroy() {
    this.updateLabelWidth('remove');
  },
  methods: {
    getLabelWidth: function getLabelWidth() {
      if (this.$el && this.$el.firstElementChild) {
        var computedWidth = window.getComputedStyle(this.$el.firstElementChild).width;
        return Math.ceil(parseFloat(computedWidth));
      } else {
        return 0;
      }
    },
    updateLabelWidth: function updateLabelWidth() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'update';

      if (this.$slots.default && this.isAutoWidth && this.$el.firstElementChild) {
        if (action === 'update') {
          this.computedWidth = this.getLabelWidth();
        } else if (action === 'remove') {
          this.cmuiForm.deregisterLabelWidth(this.computedWidth);
        }
      }
    }
  },
  render: function render(h) {
    var slots = this.$slots.default;
    if (!slots) return null;

    if (this.isAutoWidth) {
      var autoLabelWidth = this.cmuiForm.autoLabelWidth;
      var style = {};

      if (autoLabelWidth && autoLabelWidth !== 'auto') {
        var marginLeft = parseInt(autoLabelWidth, 10) - this.computedWidth;

        if (marginLeft) {
          style.marginLeft = marginLeft + 'px';
        }
      }

      return h('div', {
        className: 'cmui-form-item__label-wrap',
        style: style
      }, slots);
    } else {
      return slots[0];
    }
  }
};

var css_248z$c = ".cmui-form-item__label[data-v-2e5e1ab8]{padding-right:12px}";
styleInject(css_248z$c);

/* script */
const __vue_script__$l = script$l;
/* template */

  /* style */
  const __vue_inject_styles__$l = undefined;
  /* scoped */
  const __vue_scope_id__$l = "data-v-2e5e1ab8";
  /* module identifier */
  const __vue_module_identifier__$l = undefined;
  /* functional template */
  const __vue_is_functional_template__$l = undefined;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$l = /*#__PURE__*/normalizeComponent(
    {},
    __vue_inject_styles__$l,
    __vue_script__$l,
    __vue_scope_id__$l,
    __vue_is_functional_template__$l,
    __vue_module_identifier__$l,
    false,
    undefined,
    undefined,
    undefined
  );

function getPropByPath(obj, path, strict) {
  var tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');
  var keyArr = path.split('.');
  var i = 0;

  for (var len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    var key = keyArr[i];

    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }

      break;
    }
  }

  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
}
var script$m = {
  name: 'cmui-form-item',
  components: {
    LabelWrap: __vue_component__$l
  },
  mixins: [basemixin],
  provide: function provide() {
    return {
      cmuiFormItem: this
    };
  },
  inject: ['cmuiForm'],
  props: {
    label: {
      type: String,
      default: '',
      intro: '标签文本'
    },
    labelWidth: {
      type: String,
      default: '',
      intro: '标签宽度'
    },
    prop: {
      type: String,
      default: '',
      intro: '表单域 model 字段，在使用 validate、resetFields 方法的情况下，该属性是必填的'
    },
    required: {
      type: Boolean,
      default: undefined,
      intro: '是否必填'
    },
    rules: {
      type: [Object, Array],
      default: function _default() {
        return null;
      },
      intro: '表单验证规'
    },
    error: {
      type: String,
      default: '',
      intro: '表单域验证错误信息, 设置该值会使表单验证状态变为error，并显示该错误信息'
    },
    validateStatus: {
      type: String,
      default: '',
      intro: '表单验证状态，通常不需要设置'
    },
    for: {
      type: String,
      default: '',
      intro: 'label标签的for属性'
    },
    inlineMessage: {
      type: [String, Boolean],
      default: '',
      intro: '以行内形式展示校验信息'
    },
    showMessage: {
      type: Boolean,
      default: true,
      intro: '是否显示校验错误信息'
    },
    targetClass: {
      type: String,
      default: '',
      intro: '设置到label标签上的样式'
    }
  },
  data: function data() {
    return {
      validateState: '',
      validateMessage: '',
      validateDisabled: false,
      validator: {},
      isNested: false,
      computedLabelWidth: ''
    };
  },
  computed: {
    labelFor: function labelFor() {
      return this.for || this.prop;
    },
    labelStyle: function labelStyle() {
      var ret = {};
      var labelWidth = this.labelWidth || this.cmuiForm.labelWidth;

      if (this.cmuiForm.labelPosition !== 'top') {
        ret.float = 'left';
      }

      ret.textAlign = this.cmuiForm.labelPosition === 'left' ? 'left' : 'right';

      if (labelWidth) {
        ret.width = labelWidth;
      }

      return ret;
    },
    itemStyle: function itemStyle() {
      if (this.cmuiForm.itemSpace) {
        return {
          marginBottom: this.cmuiForm.itemSpace
        };
      }

      return {};
    },
    contentStyle: function contentStyle() {
      var ret = {};
      var label = this.label;
      if (this.cmuiForm.labelPosition === 'top') return ret;
      if (!label && !this.labelWidth && this.isNested) return ret;
      var labelWidth = this.labelWidth || this.cmuiForm.labelWidth;

      if (labelWidth === 'auto') {
        if (this.labelWidth === 'auto') {
          ret.marginLeft = this.computedLabelWidth;
        } else if (this.cmuiForm.labelWidth === 'auto') {
          ret.marginLeft = this.cmuiForm.autoLabelWidth;
        }
      } else {
        ret.marginLeft = labelWidth;
      }

      return ret;
    },
    fieldValue: function fieldValue() {
      var model = this.cmuiForm.model;

      if (!model || !this.prop) {
        return;
      }

      var path = this.prop;

      if (path.indexOf(':') !== -1) {
        path = path.replace(/:/, '.');
      }

      return getPropByPath(model, path, true).v;
    },
    isRequired: function isRequired() {
      var rules = this.getRules();
      var isRequired = false;

      if (rules && rules.length) {
        rules.every(function (rule) {
          if (rule.required) {
            isRequired = true;
            return false;
          }

          return true;
        });
      }

      return isRequired;
    }
  },
  watch: {
    error: {
      immediate: true,
      handler: function handler(value) {
        this.validateMessage = value;
        this.validateState = value ? 'error' : '';
      }
    },
    validateStatus: function validateStatus(value) {
      this.validateState = value;
    }
  },
  mounted: function mounted() {
    if (this.prop) {
      this.cmuiForm.addField(this);
      var initialValue = this.fieldValue;

      if (Array.isArray(initialValue)) {
        initialValue = [].concat(initialValue);
      }

      Object.defineProperty(this, 'initialValue', {
        value: initialValue
      });
      this.addValidateEvents();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.cmuiForm.removeField(this);
  },
  methods: {
    validate: function validate(trigger) {
      var _this = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      this.validateDisabled = false;
      var rules = this.getFilteredRule(trigger);

      if ((!rules || rules.length === 0) && this.required === undefined) {
        callback();
        return true;
      }

      this.validateState = 'validating';
      var descriptor = {};

      if (rules && rules.length > 0) {
        rules.forEach(function (rule) {
          delete rule.trigger;
        });
      }

      descriptor[this.prop] = rules;
      var validator = new Schema(descriptor);
      var model = {};
      model[this.prop] = this.fieldValue;
      validator.validate(model, {
        firstFields: true
      }, function (errors, invalidFields) {
        _this.validateState = !errors ? 'success' : 'error';
        _this.validateMessage = errors ? errors[0].message : '';
        callback(_this.validateMessage, invalidFields);
        _this.cmuiForm && _this.cmuiForm.$emit('validate', _this.prop, !errors, _this.validateMessage || null);
      });
    },
    clearValidate: function clearValidate() {
      this.validateState = '';
      this.validateMessage = '';
      this.validateDisabled = false;
    },
    resetField: function resetField() {
      var _this2 = this;

      this.validateState = '';
      this.validateMessage = '';
      var model = this.cmuiForm.model;
      var value = this.fieldValue;
      var path = this.prop;

      if (path.indexOf(':') !== -1) {
        path = path.replace(/:/, '.');
      }

      var prop = getPropByPath(model, path, true);
      this.validateDisabled = true;

      if (Array.isArray(value)) {
        prop.o[prop.k] = [].concat(this.initialValue);
      } else {
        prop.o[prop.k] = this.initialValue;
      } // reset validateDisabled after onFieldChange triggered


      this.$nextTick(function () {
        _this2.validateDisabled = false;
      });
      this.broadcast('ElTimeSelect', 'fieldReset', this.initialValue);
    },
    getRules: function getRules() {
      var formRules = this.cmuiForm.rules;
      var selfRules = this.rules;
      var requiredRule = this.required !== undefined ? {
        required: !!this.required
      } : [];
      var prop = getPropByPath(formRules, this.prop || '');
      formRules = formRules ? prop.o[this.prop || ''] || prop.v : [];
      return [].concat(selfRules || formRules || []).concat(requiredRule);
    },
    getFilteredRule: function getFilteredRule(trigger) {
      var rules = this.getRules();
      return rules.filter(function (rule) {
        if (!rule.trigger || trigger === '') return true;

        if (Array.isArray(rule.trigger)) {
          return rule.trigger.indexOf(trigger) > -1;
        } else {
          return rule.trigger === trigger;
        }
      }).map(function (rule) {
        return _$1.assign({}, rule);
      });
    },
    onFieldBlur: function onFieldBlur() {
      this.validate('blur');
    },
    onFieldChange: function onFieldChange() {
      if (this.validateDisabled) {
        this.validateDisabled = false;
        return;
      }

      this.validate('change');
    },
    updateComputedLabelWidth: function updateComputedLabelWidth(width) {
      this.computedLabelWidth = width ? "".concat(width, "px") : '';
    },
    addValidateEvents: function addValidateEvents() {
      var rules = this.getRules();

      if (rules.length || this.required !== undefined) {
        this.$on('form.blur', this.onFieldBlur);
        this.$on('form.change', this.onFieldChange);
      }
    },
    removeValidateEvents: function removeValidateEvents() {
      this.$off();
    }
  }
};

var css_248z$d = ".cmui-form-item.is-error input[data-v-099e646d]{border-color:#f56c6c}.cmui-form-item__error[data-v-099e646d]{color:#f56c6c;font-size:12px;line-height:1;padding-top:4px;position:absolute;top:100%;left:0}";
styleInject(css_248z$d);

/* script */
const __vue_script__$m = script$m;
/* template */
var __vue_render__$l = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "cmui-form-item",
      class: [
        {
          "cmui-form-item--feedback": _vm.cmuiForm && _vm.cmuiForm.statusIcon,
          "is-error": _vm.validateState === "error",
          "is-validating": _vm.validateState === "validating",
          "is-success": _vm.validateState === "success",
          "is-required": _vm.isRequired || _vm.required,
          "is-no-asterisk": _vm.cmuiForm && _vm.cmuiForm.hideRequiredAsterisk
        }
      ],
      style: _vm.itemStyle
    },
    [
      _c(
        "label-wrap",
        {
          attrs: {
            "is-auto-width": _vm.labelStyle && _vm.labelStyle.width === "auto",
            "update-all": _vm.cmuiForm.labelWidth === "auto"
          }
        },
        [
          _vm.label || _vm.$slots.label
            ? _c(
                "label",
                {
                  staticClass: "cmui-form-item__label",
                  class: _vm.targetClass,
                  style: _vm.labelStyle,
                  attrs: { for: _vm.labelFor }
                },
                [_vm._t("label", [_vm._v(_vm._s(_vm.label))])],
                2
              )
            : _vm._e()
        ]
      ),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "cmui-form-item__content pos-r",
          style: _vm.contentStyle
        },
        [
          _vm._t("default"),
          _vm._v(" "),
          _c(
            "transition",
            { attrs: { name: "cmui-zoom-in-top" } },
            [
              _vm.validateState === "error" &&
              _vm.showMessage &&
              _vm.cmuiForm.showMessage
                ? _vm._t(
                    "error",
                    [
                      _c(
                        "div",
                        {
                          staticClass: "cmui-form-item__error",
                          class: {
                            "cmui-form-item__error--inline":
                              typeof _vm.inlineMessage === "boolean"
                                ? _vm.inlineMessage
                                : (_vm.cmuiForm &&
                                    _vm.cmuiForm.inlineMessage) ||
                                  false
                          }
                        },
                        [
                          _vm._v(
                            "\n                        " +
                              _vm._s(_vm.validateMessage) +
                              "\n                    "
                          )
                        ]
                      )
                    ],
                    { error: _vm.validateMessage }
                  )
                : _vm._e()
            ],
            2
          )
        ],
        2
      )
    ],
    1
  )
};
var __vue_staticRenderFns__$l = [];
__vue_render__$l._withStripped = true;

  /* style */
  const __vue_inject_styles__$m = undefined;
  /* scoped */
  const __vue_scope_id__$m = "data-v-099e646d";
  /* module identifier */
  const __vue_module_identifier__$m = undefined;
  /* functional template */
  const __vue_is_functional_template__$m = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$m = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$l, staticRenderFns: __vue_staticRenderFns__$l },
    __vue_inject_styles__$m,
    __vue_script__$m,
    __vue_scope_id__$m,
    __vue_is_functional_template__$m,
    __vue_module_identifier__$m,
    false,
    undefined,
    undefined,
    undefined
  );

var formList = [__vue_component__$g, __vue_component__$h, __vue_component__$c, __vue_component__$f, __vue_component__$i, __vue_component__$j, __vue_component__$e, __vue_component__$b, __vue_component__$k, __vue_component__$m];
formList.forEach(function (Component) {
  Component.install = function (Vue) {
    Vue.component(Component.name, Component);
  };
});

dialogInstall(__vue_component__$d);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var base = {
};
var themeList = {
	base: base
};

var sliderMethodsList = ['disableMousewheelControl', 'enableMousewheelControl', 'enableKeyboardControl', 'disableKeyboardControl', 'slideNext', 'slidePrev', 'slideTo', 'startAutoplay', 'stopAutoplay', 'destroy', 'getWrapperTranslate', 'setWrapperTranslate', 'removeSlide', 'removeAllSlides', 'updateContainerSize', 'updateSlidesSize', 'updateProgress', 'updatePagination', 'updateClasses', 'update', 'onResize', 'detachEvents', 'attachEvents', 'appendSlide', 'prependSlide', 'on', 'once', 'off', 'lockSwipes', 'lockSwipeToNext', 'lockSwipeToPrev', 'reLoop', 'disableTouchControl', 'enableTouchControl', 'unsetGrabCursor', 'setGrabCursor'];
var sliderPropsList = ['activeIndex', 'realIndex', 'previousIndex', 'width', 'height', 'touches', 'params', 'container', 'wrapper', 'slides', 'bullets', 'translate', 'progress', 'isBeginning', 'isEnd', 'autoplaying', 'animating', 'clickedIndex', 'clickedSlide', 'prevButton', 'nextButton'];

function SliderList() {
  this.length = 0;
}

sliderMethodsList.forEach(function (item) {
  SliderList.prototype[item] = function (arg) {
    var _this = this;

    _$1.times(this.length).forEach(function (index) {
      if (_this[index] instanceof Swiper) {
        _this[index][item](arg);
      }
    });

    return this;
  };
});
sliderPropsList.forEach(function (item) {
  SliderList.prototype[item] = function () {
    return _$1.get(this, '[0]' + item);
  };
});

SliderList.prototype.add = function (item) {
  if (item instanceof Swiper) {
    this[this.length++] = item;
  }

  return this;
};

SliderList.prototype.remove = function () {
  var _this2 = this;

  _$1.times(this.length, function (index) {
    var swiper = _this2[index];

    if (swiper instanceof Swiper) {
      var container = swiper.container;

      var baseIndex = _$1.findKey(sliderList, swiper);

      swiper.destroy(false, true);
      container.remove();
      _this2[index] = null;

      if (_this2 !== sliderList) {
        sliderList[baseIndex] = null;
      }
    }
  });

  return this;
};

SliderList.prototype.eq = function () {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var temp = new SliderList();
  return temp.add(this[index]);
};

var sliderList = new SliderList();

function optionsMaker(options, themeName) {
  var _this = this;

  var themeOptions = _$1.get(themeList, themeName);

  var propOptions = {}; // set slidesPerView as col

  if (this.col === 0) {
    propOptions.slidesPerView = 'auto';
  } else {
    propOptions.slidesPerView = this.col;
  } // set scrollbar


  if (this.scrollbar) {
    propOptions.scrollbar = {
      el: '.swiper-scrollbar'
    };
  } // set pagination as page


  if (this.page) {
    var tempOption = {
      el: '.swiper-pagination'
    };

    if (_$1.isString(this.page)) {
      if (this.page === 'progress') {
        tempOption.type = 'progressbar';
      } else if (this.page === 'number') {
        tempOption.type = 'fraction';
      }
    } else if (_$1.isNumber(this.page)) {
      tempOption.dynamicBullets = true;
      tempOption.dynamicMainBullets = parseInt(this.page) || 1;
    }

    _$1.set(propOptions, 'pagination', tempOption);
  } // set navigation as nav


  if (this.nav) {
    _$1.set(propOptions, 'navigation', {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev'
    });
  } // set spaceBetween as space


  if (this.space) {
    propOptions.spaceBetween = this.space;
  } // 提取常用属性方便使用


  ['loop', 'autoplay', 'direction', 'freeMode'].forEach(function (item) {
    propOptions[item] = _this[item];
  });

  var rsOptions = _$1.defaultsDeep(options, propOptions, themeOptions);

  if (rsOptions.slidesPerView === 'auto') {
    var pos = rsOptions.direction === 'vertical' ? 'height' : 'width';
    this.$children.forEach(function (item) {
      item.$el.style[pos] = item.$el.style[pos] || 'auto';
    });
  }

  return rsOptions;
}

var DEFAULT_EVENTS = ['beforeDestroy', 'slideChange', 'slideChangeTransitionStart', 'slideChangeTransitionEnd', 'slideNextTransitionStart', 'slideNextTransitionEnd', 'slidePrevTransitionStart', 'slidePrevTransitionEnd', 'transitionStart', 'transitionEnd', 'touchStart', 'touchMove', 'touchMoveOpposite', 'sliderMove', 'touchEnd', 'click', 'tap', 'doubleTap', 'imagesReady', 'progress', 'reachBeginning', 'reachEnd', 'fromEdge', 'setTranslate', 'setTransition', 'resize'];
var sliderObserve = new ( /*#__PURE__*/function () {
  function _class() {
    _classCallCheck(this, _class);

    this.controlList = {};
    this.refList = [];
    this.subscribeList = [];
  }

  _createClass(_class, [{
    key: "observeControl",
    value: function observeControl(vm) {
      var _this2 = this;

      var controlName = vm.control;

      if (controlName && _$1.isString(controlName)) {
        this.refList.forEach(function (item) {
          if (item.name === controlName) {
            _this2.bindControl(vm.swiper, item.vm.swiper);
          }
        });
        this.controlList[controlName] = vm.swiper;
        this.subscribeList.push(function (swiper, ref) {
          if (_this2.controlList[ref]) {
            _this2.bindControl(_this2.controlList[ref], swiper);
          }
        });
      }

      var refName = _$1.get(vm, '$vnode.data.ref');

      if (refName) {
        this.refList.push({
          vm: vm,
          name: refName
        });
        this.publish(vm.swiper, refName);
      }
    }
  }, {
    key: "bindControl",
    value: function bindControl(controlSwiper, targetSwiper) {
      targetSwiper.controller.control = controlSwiper;
    }
  }, {
    key: "publish",
    value: function publish(swiper, refName) {
      this.subscribeList.forEach(function (item) {
        return item(swiper, refName);
      });
    }
  }]);

  return _class;
}())();
var script$n = {
  name: 'cmui-slider',
  props: {
    id: {
      type: String,
      default: _$1.uniqueId('cmui-slider_'),
      intro: '默认ID'
    },
    watch: {
      type: [Object, Array],
      default: function _default() {
        return {};
      },
      intro: '要监控的对象，当对象改变时slider将重新渲染'
    },
    theme: {
      type: Number,
      default: 0,
      intro: ''
    },
    options: {
      type: Object,
      default: null,
      intro: 'Swiper初始化传递的选项详见官方文档'
    },
    loop: {
      type: Boolean,
      default: false,
      intro: '是否循环播放'
    },
    autoplay: {
      type: Boolean,
      default: false,
      intro: '是否自动播放'
    },
    col: {
      type: Number,
      default: 1,
      intro: '列数'
    },
    page: {
      type: [Boolean, String, Number],
      default: false,
      intro: '是否显示page'
    },
    direction: {
      type: String,
      default: 'horizontal',
      intro: '水平轮播还是垂直轮播'
    },
    height: {
      type: String,
      default: '',
      intro: '固定轮播的高度'
    },
    nav: {
      type: Boolean,
      default: false,
      intro: '是否显示左右箭头'
    },
    space: {
      type: Number,
      default: 0,
      intro: '两个item之间的距离'
    },
    freeMode: {
      type: Boolean,
      default: false,
      intro: '是否使用自由模式'
    },
    scrollbar: {
      type: Boolean,
      default: false,
      intro: '是否显示滚动条'
    },
    control: {
      type: String,
      default: '',
      intro: '控制器对应的ref'
    }
  },
  data: function data() {
    return {
      visible: true
    };
  },
  computed: {
    containerStyle: function containerStyle() {
      var rs = {};

      if (this.height) {
        rs.height = this.height;
      }

      return rs;
    }
  },
  watch: {
    watch: {
      immediate: false,
      handler: function handler(newValue, oldValue) {
        if (this.loop) {
          _$1.differenceWith(newValue, oldValue, _$1.isEqual).length && this.resetSwiper();
        } else {
          !_$1.isEqual(newValue, oldValue) && this.resetSwiper();
        }
      }
    },
    options: {
      deep: true,
      handler: function handler(newOptions, oldOptions) {
        if (!_$1.isEqual(newOptions, oldOptions)) {
          this.resetSwiper();
        }
      }
    }
  },
  mounted: function mounted() {
    this.resetSwiper();
  },
  methods: {
    destroy: function destroy() {
      this.swiper && this.swiper.destroy(true, false);
      this.visible = false;
    },
    resetSwiper: function resetSwiper() {
      var _this3 = this;

      this.$nextTick(function () {
        var hasInit = !!_this3.swiper;

        if (hasInit) {
          _this3.swiper.destroy(false, false);
        } else {
          _this3.swiperIndex = sliderList.length;
        }

        _$1.delay(function () {
          _this3.swiper = new Swiper(_this3.$refs['swiper-container'], optionsMaker.call(_this3, _this3.options), _this3.theme);
          sliderObserve.observeControl(_this3);

          if (hasInit) {
            sliderList[_this3.swiperIndex] = _this3.swiper;
          } else {
            sliderList.add(_this3.swiper);
          }

          _this3.bindEvents();

          _this3.$emit('rendered', _this3);
        }, 0);
      });
    },
    update: function update() {
      if (this.swiper) {
        this.swiper.update && this.swiper.update();
        this.swiper.navigation && this.swiper.navigation.update();
        this.swiper.pagination && this.swiper.pagination.render();
        this.swiper.pagination && this.swiper.pagination.update();
      }
    },
    bindEvents: function bindEvents() {
      var _this4 = this;

      var vm = this;
      DEFAULT_EVENTS.forEach(function (eventName) {
        _this4.swiper.on(eventName, function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          vm.$emit.apply(vm, [eventName].concat(args, [vm.swiper]));
          vm.$emit.apply(vm, [eventName.replace(/([A-Z])/g, '-$1').toLowerCase()].concat(args, [vm.swiper]));
        });
      });
    }
  }
};

var css_248z$e = ".swiper-scrollbar:empty{display:none}";
styleInject(css_248z$e);

/* script */
const __vue_script__$n = script$n;
/* template */
var __vue_render__$m = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _vm.visible
    ? _c("div", { staticClass: "cmui-slider" }, [
        _c(
          "div",
          {
            ref: "swiper-container",
            staticClass: "swiper-container",
            style: _vm.containerStyle,
            attrs: { id: _vm.id }
          },
          [
            _c(
              "div",
              { staticClass: "swiper-wrapper" },
              [_vm._t("default")],
              2
            ),
            _vm._v(" "),
            _vm.nav
              ? _c("div", { staticClass: "swiper-button-next" })
              : _vm._e(),
            _vm._v(" "),
            _vm.nav
              ? _c("div", { staticClass: "swiper-button-prev" })
              : _vm._e(),
            _vm._v(" "),
            _c("div", { staticClass: "swiper-pagination" }),
            _vm._v(" "),
            _c("div", { staticClass: "swiper-scrollbar" })
          ]
        )
      ])
    : _vm._e()
};
var __vue_staticRenderFns__$m = [];
__vue_render__$m._withStripped = true;

  /* style */
  const __vue_inject_styles__$n = undefined;
  /* scoped */
  const __vue_scope_id__$n = undefined;
  /* module identifier */
  const __vue_module_identifier__$n = undefined;
  /* functional template */
  const __vue_is_functional_template__$n = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$n = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$m, staticRenderFns: __vue_staticRenderFns__$m },
    __vue_inject_styles__$n,
    __vue_script__$n,
    __vue_scope_id__$n,
    __vue_is_functional_template__$n,
    __vue_module_identifier__$n,
    false,
    undefined,
    undefined,
    undefined
  );

//
//
//
//
//
var script$o = {
  name: 'cmui-slider-item'
};

/* script */
const __vue_script__$o = script$o;

/* template */
var __vue_render__$n = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "swiper-slide" }, [_vm._t("default")], 2)
};
var __vue_staticRenderFns__$n = [];
__vue_render__$n._withStripped = true;

  /* style */
  const __vue_inject_styles__$o = undefined;
  /* scoped */
  const __vue_scope_id__$o = undefined;
  /* module identifier */
  const __vue_module_identifier__$o = undefined;
  /* functional template */
  const __vue_is_functional_template__$o = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$o = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$n, staticRenderFns: __vue_staticRenderFns__$n },
    __vue_inject_styles__$o,
    __vue_script__$o,
    __vue_scope_id__$o,
    __vue_is_functional_template__$o,
    __vue_module_identifier__$o,
    false,
    undefined,
    undefined,
    undefined
  );

function ImagePreView(ImageList) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var vm = this;

  var id = _$1.uniqueId('preView_');

  var tpl = "\n        <transition name=\"fade\" id=\"".concat(id, "\">\n\t\t    <div class=\"fixed-full cmui-image-preView flex-container\" v-if=\"show\" @click=\"preViewListClick($event)\" @touchmove.stop.prevent=\"function(){}\">\n\t\t        <cmui-slider :watch=\"preViewList_temp\" :page=\"true\" :auto=\"0\" :loop=\"preViewList_temp.length>1\" :options=\"options\" style=\"width:100%\">\n\t\t            <cmui-slider-item v-for=\"item in preViewList_temp\" >\n\t\t                <img :src=\"item\" alt=\"\" style=\"max-height: 100vh\">\n\t\t            </cmui-slider-item>\n\t\t        </cmui-slider>\n\t\t    </div>\n\t    </transition>\n\t");
  var dom = document.createElement('div');
  document.body.appendChild(dom);
  var Vue = this.$root.constructor;
  return new Vue({
    components: {
      cmuiSlider: __vue_component__$n,
      cmuiSliderItem: __vue_component__$o
    },
    data: {
      preViewList_temp: [].concat(ImageList),
      show: false,
      options: _$1.assign({
        initialSlide: index
      }, options)
    },
    mounted: function mounted() {
      var _this = this;

      _$1.defer(function () {
        _this.show = true;
        vm.$emit('preview', true);
      });
    },
    methods: {
      preViewListClick: function preViewListClick(event) {
        event.stopPropagation();

        if (!_$1.includes(_$1.get(event, 'target.classList'), 'swiper-pagination-bullet') && _$1.get(this, '$children[0]')) {
          this.$children[0].$destroy();
          this.show = false;
          this.$nextTick(function () {
            vm.$emit('preview', false);
          });
        }
      }
    },
    template: tpl
  }).$mount(dom);
}

var ssr = typeof document === 'undefined' || typeof window === 'undefined';
var isInView = ssr ? function () {} : function (dom) {
  var _dom$getBoundingClien = dom.getBoundingClientRect(),
      top = _dom$getBoundingClien.top,
      left = _dom$getBoundingClien.left,
      bottom = _dom$getBoundingClien.bottom,
      right = _dom$getBoundingClien.right;

  var _window = window,
      innerHeight = _window.innerHeight,
      innerWidth = _window.innerWidth; // let offsetY = top - (document.body.scrollTop || document.documentElement.scrollTop)
  // let offsetX = left - (document.body.scrollLeft || document.documentElement.scrollLeft)
  // let inY = offsetY >= 0 && offsetY < height
  // let inX = offsetX >= 0 && offsetX < width

  return top < innerHeight && bottom > 0 && left < innerWidth && right > 0;
};
var ready = ssr ? function () {} : function (fn) {
  if (!window || !document) {
    return;
  }

  if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', function () {
      // document.removeEventListener('DOMContentLoaded',arguments.callee, false);
      fn(window);
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent('onreadystatechange', function () {
      if (document.readyState === 'complete') {
        // document.detachEvent('onreadystatechange', arguments.callee);
        fn(window);
      }
    });
  }
};

var lazyLoadList = [];
var windowHeight;
var checkFinish = true;

var checkLazyLoadImage = _$1.debounce(function () {
  if (checkFinish) {
    checkFinish = false;

    for (var i = 0; i < lazyLoadList.length; i++) {
      var _lazyLoadList$i = lazyLoadList[i],
          $el = _lazyLoadList$i.$el,
          src = _lazyLoadList$i.src;
      var inView = isInView($el);

      if (inView) {
        $el.src = src;
        lazyLoadList.splice(i--, 1);
        continue;
      } else if ($el.getBoundingClientRect().top > windowHeight) {
        break;
      }
    }

    checkFinish = true;
  }
}, 500);

ready(function (window) {
  if (window) {
    window.addEventListener('scroll', checkLazyLoadImage);
    window.addEventListener('resize', function () {
      windowHeight = window.innerHeight;
    });
    windowHeight = window.innerHeight;
  }
});
var base64Data = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==';
var script$p = {
  name: 'cmui-img',
  props: {
    src: {
      type: String,
      default: base64Data,
      intro: '图片地址'
    },
    lazyLoad: {
      type: Boolean,
      default: false,
      intro: '是否启用延迟加载'
    },
    lazySrc: {
      type: String,
      default: base64Data,
      intro: '延迟加载时所用的展位图'
    },
    errorSrc: {
      type: String,
      default: base64Data,
      intro: '图片加载失败后使用的图片'
    },
    preView: {
      type: Boolean,
      default: false,
      intro: '是否开启图片预览'
    },
    preViewList: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '预览图地址列表'
    },
    preViewIndex: {
      type: Number,
      default: 0,
      intro: '预览索引'
    },
    preViewOptions: {
      type: Object,
      default: function _default() {
        return {};
      },
      intro: '预览选项，和slider组件相同'
    }
  },
  data: function data() {
    return {
      realSrc: this.lazyLoad ? this.lazySrc : this.src
    };
  },
  created: function created() {
    lazyLoadList.push(this);
  },
  mounted: function mounted() {
    checkLazyLoadImage();
  },
  destroyed: function destroyed() {
    _$1.remove(lazyLoadList, this);
  },
  methods: {
    imgClick: function imgClick() {
      if (this.preView) {
        var list = this.preViewList.length ? this.preViewList : this.src;
        var index = this.preViewIndex;
        ImagePreView.call(this, list, index, this.preViewOptions);
      }
    },
    srcError: function srcError() {
      this[this.lazyLoad ? 'lazySrc' : 'realSrc'] = this.errorSrc;
    }
  }
};

var css_248z$f = ".fade-enter-active,.fade-leave-active{-webkit-transition:opacity .5s;transition:opacity .5s}.fade-enter,.fade-leave-to{opacity:0}.slide-enter-active,.slide-leave-active{-webkit-transition:all .5s;transition:all .5s}.slide-enter,.slide-leave-to{-webkit-transform:translateY(100%);transform:translateY(100%);opacity:0}";
styleInject(css_248z$f);

/* script */
const __vue_script__$p = script$p;
/* template */
var __vue_render__$o = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("img", {
    staticClass: "cmui-img",
    attrs: { src: _vm.realSrc, alt: "" },
    on: {
      click: function($event) {
        return _vm.imgClick()
      },
      error: function($event) {
        return _vm.srcError()
      }
    }
  })
};
var __vue_staticRenderFns__$o = [];
__vue_render__$o._withStripped = true;

  /* style */
  const __vue_inject_styles__$p = undefined;
  /* scoped */
  const __vue_scope_id__$p = undefined;
  /* module identifier */
  const __vue_module_identifier__$p = undefined;
  /* functional template */
  const __vue_is_functional_template__$p = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$p = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$o, staticRenderFns: __vue_staticRenderFns__$o },
    __vue_inject_styles__$p,
    __vue_script__$p,
    __vue_scope_id__$p,
    __vue_is_functional_template__$p,
    __vue_module_identifier__$p,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$p.install = function (Vue, Maple) {
  Vue.component(__vue_component__$p.name, __vue_component__$p);
};

__vue_component__$n.install = function (Vue, Maple) {
  Vue.component(__vue_component__$n.name, __vue_component__$n);
};

__vue_component__$o.install = function (Vue, Maple) {
  Vue.component(__vue_component__$o.name, __vue_component__$o);
};

var script$q = {
  name: 'cmui-list',
  mixins: [basemixin],
  props: {
    col: {
      type: [Number, Array],
      default: 1,
      intro: '如果是数字代表列表的列数，如果数组，数组的长度表示列数，数组的每一项表示改该列所占的比例，如[1,2]表示两列，比例为1：2'
    },
    space: {
      type: Number,
      default: 0,
      intro: '每一列之间的间距'
    },
    border: {
      type: [Boolean, String],
      default: false,
      intro: '布尔类型表示每个item是否带有边框，如果space为0，则边框会自动重合，如果是string类型，表示边框的颜色值'
    },
    target: {
      type: Object,
      default: function _default() {
        return {};
      },
      intro: '用于存放后续需要的暂存对象'
    },
    index: {
      type: [Boolean, Function],
      default: false,
      intro: '是否使用索引，可以和cmui-list-group联合使用'
    }
  },
  data: function data() {
    var defaultBorderColor = '#eeeeee';
    var isColor = /^#[a-fA-F0-9]{6}$/.test(this.border);
    var borderColor = isColor ? this.border : defaultBorderColor;
    return {
      borderColor: borderColor,
      groupList: [],
      activeIndex: 0,
      indexItemHeight: 0,
      startIndex: 0,
      listEventStartY: 0,
      useRem: !!/iphone|ipad|android|micromessenger/i.test(win.navigator.userAgent)
    };
  },
  provide: function provide() {
    return {
      bus: {
        parent: this,
        children: []
      }
    };
  },
  computed: {
    realSpace: function realSpace() {
      var value = parseInt(this.space) / (this.useRem ? 150 : 2) || 0;
      return value ? value + (this.useRem ? 'rem' : 'px') : 0;
    },
    realCol: function realCol() {
      var value = this.col;

      if (_$1.isNumber(value)) {
        if (_$1.inRange(value, 0, 11)) {
          return parseInt(value) || 1;
        } else {
          return 1;
        }
      } else if (_$1.isArray(value) && _$1.every(value, _$1.isNumber)) {
        return value.map(function (item) {
          return parseInt(item) || 1;
        });
      } else {
        return parseInt(value) || 1;
      }
    },
    containerStyle: function containerStyle() {
      return {
        margin: this.realSpace ? "-".concat(this.realSpace) : undefined
      };
    },
    boxShadow: function boxShadow() {
      if (this.border && !this.realSpace) {
        return '0px 0px 0px 1px ' + this.borderColor;
      }

      return '';
    },
    noPaddingbFrom: function noPaddingbFrom() {
      var itemLen = this.$slots.default.filter(function (item) {
        return _$1.get(item, 'componentOptions.tag') === 'cmui-list-item';
      }).length;
      var col = _$1.isArray(this.realCol) ? this.realCol.length : this.realCol;
      return itemLen - (itemLen % col || col);
    }
  },
  mounted: function mounted() {
    if (!this.index) {
      return;
    } // let parentNode = this.$el
    // let baseNode = this.$el.firstChild
    // while (parentNode.clientHeight >= baseNode.clientHeight) {
    //   if (parentNode === document.body) {
    //     parentNode = document
    //     break
    //   }
    //   parentNode = parentNode.parentNode
    // }


    var _this = this;

    document.addEventListener('scroll', _$1.throttle(function () {
      _this.activeIndex = _this.groupList.filter(function (item) {
        return item.vm.$el.getBoundingClientRect().top < 0;
      }).length;
    }, 500), {
      passive: true
    });
  },
  methods: {
    indexFormat: function indexFormat(value) {
      if (_$1.isFunction(this.index)) {
        return this.index(value);
      }

      return value.toString()[0];
    },
    scrollToGroup: function scrollToGroup(i) {
      this.preventScroll = true;
      this.groupList[i].vm.$el.scrollIntoView();
      this.activeIndex = i;
    },
    indexEvent: function indexEvent(event, index) {
      this.activeIndex = index;
      this.startIndex = index;
      this.listEventStartY = event.touches[0].clientY;

      function outHeight(dom) {
        var propObj = win.getComputedStyle(dom);
        return ['marginTop', 'marginBottom', 'borderTopWidth', 'borderBottomWidth', 'height'].reduce(function (rs, prop) {
          return rs += parseInt(propObj[prop]);
        }, 0);
      }

      this.indexItemHeight = this.indexItemHeight || outHeight(event.target);
      this.scrollToGroup(index);
    },
    scrollOnIndex: function scrollOnIndex(e) {
      var disY = e.touches[0].clientY - this.listEventStartY;
      var disCount = parseInt(disY / this.indexItemHeight);
      var activeIndex = this.startIndex + disCount;

      if (this.activeIndex !== activeIndex && this.groupList[activeIndex]) {
        this.scrollToGroup(activeIndex);
      }
    }
  }
};

/* script */
const __vue_script__$q = script$q;

/* template */
var __vue_render__$p = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "cmui-list", style: [_vm.boxShadow] }, [
    _c(
      "div",
      { staticClass: "clearfix", style: _vm.containerStyle },
      [
        _vm.index
          ? _c(
              "div",
              {
                staticClass:
                  "fixed-right flex-container center cmui-list-index",
                staticStyle: { "z-index": "21" }
              },
              [
                _c(
                  "div",
                  {
                    staticClass:
                      "indexWarp flex-container-col scroll-container-y"
                  },
                  _vm._l(_vm.groupList, function(item, i) {
                    return _c("span", {
                      key: i,
                      class: { active: i === _vm.activeIndex },
                      domProps: {
                        textContent: _vm._s(_vm.indexFormat(item.title))
                      },
                      on: {
                        touchstart: function($event) {
                          return _vm.indexEvent($event, i)
                        },
                        touchmove: function($event) {
                          $event.stopPropagation();
                          $event.preventDefault();
                          return _vm.scrollOnIndex($event)
                        }
                      }
                    })
                  }),
                  0
                )
              ]
            )
          : _vm._e(),
        _vm._v(" "),
        _vm._t("default")
      ],
      2
    )
  ])
};
var __vue_staticRenderFns__$p = [];
__vue_render__$p._withStripped = true;

  /* style */
  const __vue_inject_styles__$q = undefined;
  /* scoped */
  const __vue_scope_id__$q = undefined;
  /* module identifier */
  const __vue_module_identifier__$q = undefined;
  /* functional template */
  const __vue_is_functional_template__$q = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$q = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$p, staticRenderFns: __vue_staticRenderFns__$p },
    __vue_inject_styles__$q,
    __vue_script__$q,
    __vue_scope_id__$q,
    __vue_is_functional_template__$q,
    __vue_module_identifier__$q,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$q.install = function (Vue, Maple) {
  Vue.component(__vue_component__$q.name, __vue_component__$q);
};

//
var script$r = {
  name: 'cmui-list-item',
  // mixins:[baseMixin],
  inject: ['bus'],
  props: {
    title: {
      type: String,
      default: '',
      intro: '标题文本'
    },
    bgcolor: {
      type: String,
      default: '',
      intro: '背景色'
    },
    border: {
      type: Boolean,
      default: true,
      intro: '是否显示边框'
    }
  },
  data: function data() {
    return {
      position: {},
      index: 0
    };
  },
  computed: {
    itemContainerStyle: function itemContainerStyle() {
      var boxShadow;
      var parent = this.bus.parent;

      if (this.border && parent.border && parent.realSpace !== 0) {
        boxShadow = '0px 0px 0px 1px ' + parent.borderColor;
      }

      return {
        boxShadow: boxShadow
      };
    }
  },
  created: function created() {
    this.index = this.bus.children.push(this) - 1;
  },
  destroyed: function destroyed() {
    _$1.remove(this.bus.children, this);
  },
  methods: {
    itemStyle: function itemStyle() {
      var width;
      var col = this.bus.parent.realCol;
      var colCount = (_$1.isArray(col) ? col.length : col) || 1;
      var clear = this.index % colCount === 0 ? 'left' : undefined;
      var padding = this.bus.parent.realSpace;
      var boxShadow = this.bus.parent.boxShadow;
      var backgroundColor = this.bgcolor;

      if (_$1.isNumber(col) && col !== 1) {
        width = 100 / col + '%';
      } else if (_$1.isArray(col)) {
        var total = col.reduce(function (pre, next) {
          return pre + next;
        });
        width = 100 * col[this.index % col.length] / total + '%';
      }

      return {
        width: width,
        clear: clear,
        padding: padding,
        boxShadow: boxShadow,
        backgroundColor: backgroundColor
      };
    }
  }
};

var css_248z$g = ".cmui-list-item{float:left;position:relative;min-height:1px;width:100%}.cmui-list-item-title{position:-webkit-sticky;position:sticky;top:0;z-index:20}";
styleInject(css_248z$g);

/* script */
const __vue_script__$r = script$r;
/* template */
var __vue_render__$q = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { ref: "listItem", staticClass: "cmui-list-item", style: _vm.itemStyle() },
    [
      _vm.$slots.title || _vm.title
        ? _c(
            "div",
            { staticClass: "cmui-list-item-title" },
            [
              _vm._t("title"),
              _vm._v(" "),
              !_vm.$slots.title
                ? [_vm._v("\n" + _vm._s(_vm.title) + "\n")]
                : _vm._e()
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "cmui-list-item-container",
          style: _vm.itemContainerStyle
        },
        [_vm._t("default")],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$q = [];
__vue_render__$q._withStripped = true;

  /* style */
  const __vue_inject_styles__$r = undefined;
  /* scoped */
  const __vue_scope_id__$r = undefined;
  /* module identifier */
  const __vue_module_identifier__$r = undefined;
  /* functional template */
  const __vue_is_functional_template__$r = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$r = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$q, staticRenderFns: __vue_staticRenderFns__$q },
    __vue_inject_styles__$r,
    __vue_script__$r,
    __vue_scope_id__$r,
    __vue_is_functional_template__$r,
    __vue_module_identifier__$r,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$r.install = function (Vue, Maple) {
  Vue.component(__vue_component__$r.name, __vue_component__$r);
};

//
var script$s = {
  name: 'cmui-list-group',
  inject: ['bus'],
  components: {
    cmuiListItem: __vue_component__$r,
    cmuiList: __vue_component__$q
  },
  props: {
    title: {
      type: String,
      default: '',
      intro: '标题文本'
    }
  },
  data: function data() {
    var parent = this.bus.parent;
    return {
      border: parent.border
    };
  },
  created: function created() {
    var parent = this.bus.parent;

    if (parent.index) {
      parent.groupList.push({
        title: this.title,
        vm: this
      });
    }
  },
  destroyed: function destroyed() {
    var _this = this;

    var parent = this.bus.parent;

    if (parent.index) {
      _$1.remove(parent.groupList, function (item) {
        return item.vm === _this;
      });
    }
  }
};

/* script */
const __vue_script__$s = script$s;

/* template */
var __vue_render__$r = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-list-item",
    { staticClass: "cmui-list-group", attrs: { border: false } },
    [
      _c(
        "cmui-list",
        { attrs: { border: _vm.border } },
        [
          _c("div", { staticClass: "cmui-list-item-title" }, [
            _vm._v("\n" + _vm._s(_vm.title) + "\n")
          ]),
          _vm._v(" "),
          _vm._t("default")
        ],
        2
      )
    ],
    1
  )
};
var __vue_staticRenderFns__$r = [];
__vue_render__$r._withStripped = true;

  /* style */
  const __vue_inject_styles__$s = undefined;
  /* scoped */
  const __vue_scope_id__$s = undefined;
  /* module identifier */
  const __vue_module_identifier__$s = undefined;
  /* functional template */
  const __vue_is_functional_template__$s = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$s = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$r, staticRenderFns: __vue_staticRenderFns__$r },
    __vue_inject_styles__$s,
    __vue_script__$s,
    __vue_scope_id__$s,
    __vue_is_functional_template__$s,
    __vue_module_identifier__$s,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$s.install = function (Vue, Maple) {
  Vue.component(__vue_component__$s.name, __vue_component__$s);
};

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$t = {
  name: 'cmui-progress',
  props: {
    value: {
      type: Number,
      default: 0,
      intro: '进度条数值范围为0-100'
    },
    color: {
      type: String,
      default: 'red',
      intro: '进度条颜色，如果需要使用渐变色可以使用数组，数组的每一项为一个表示颜色的字符串'
    },
    bgcolor: {
      type: String,
      default: '#cccccc',
      intro: '背景色'
    },
    lineWidth: {
      type: Number,
      default: 2,
      intro: '线宽'
    },
    type: {
      type: String,
      default: 'line',
      intro: '进度条样式可选项：line top circle'
    },
    // line top circle
    radius: {
      type: Boolean,
      default: true,
      intro: '进度条是否使用圆角'
    },
    text: {
      type: String,
      default: '',
      intro: '内容文字'
    },
    size: {
      type: Number,
      default: 20,
      intro: '环形进度条尺寸，仅在type为circle时生效'
    }
  },
  computed: {
    warpStyle: function warpStyle() {
      return {
        height: this.lineWidth + 'px',
        backgroundColor: this.bgcolor,
        'border-radius': this.radius ? '100px' : 'none'
      };
    },
    progressStyle: function progressStyle() {
      var width = Math.max(this.value, 0);
      width = Math.min(this.value, 100);
      return {
        height: this.lineWidth + 'px',
        width: width + '%',
        'border-radius': this.radius ? '100px 0 0 100px' : 'none'
      };
    },
    bgStyle: function bgStyle() {
      var rs = {};
      rs.backgroundColor = this.color.split(/\s+/g)[0];
      rs.backgroundImage = 'linear-gradient(to right, ' + this.color.replace(/\s+/g, ',') + ')';
      var width = Math.max(this.value, 0);
      width = Math.min(this.value, 100);
      rs.width = 10000 / width + '%';
      return rs;
    },
    sd: function sd() {
      return (this.size - this.lineWidth) * Math.PI * this.value / 100 + ' 1024';
    }
  }
};

var css_248z$h = ".cmui-progress_warp{overflow:hidden}.cmui-progress_warp .cmui-progress_bar{-webkit-transition:width 1s;transition:width 1s;overflow:hidden;position:relative}.cmui-progress_warp .cmui-progress_bar .cmui-progress_bg{height:100%}.cmui-progress_warp .cmui-progress_bar .cmui-progress_info{color:#fff}";
styleInject(css_248z$h);

/* script */
const __vue_script__$t = script$t;
/* template */
var __vue_render__$s = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "cmui-progress" }, [
    _vm.type === "line" || _vm.type === "top"
      ? _c("div", { staticClass: "cmui-progress_warp", style: _vm.warpStyle }, [
          _c(
            "div",
            { staticClass: "cmui-progress_bar", style: _vm.progressStyle },
            [
              _c("div", {
                staticClass: "cmui-progress_bg",
                style: _vm.bgStyle
              }),
              _vm._v(" "),
              !_vm.$slots.default || _vm.text
                ? _c(
                    "div",
                    { staticClass: "cmui-progress_info fullcenter" },
                    [
                      _vm._t("default"),
                      _vm._v(" "),
                      !_vm.$slots.default
                        ? [
                            _vm._v(
                              "\n            " +
                                _vm._s(_vm.text) +
                                "\n          "
                            )
                          ]
                        : _vm._e()
                    ],
                    2
                  )
                : _vm._e()
            ]
          )
        ])
      : _vm._e(),
    _vm._v(" "),
    _vm.type === "circle"
      ? _c(
          "div",
          { staticClass: "ratio-container", style: { width: _vm.size + "px" } },
          [
            _c("svg", { attrs: { width: _vm.size, height: _vm.size } }, [
              _c(
                "g",
                { attrs: { transform: "matrix(0,-1,1,0,0," + _vm.size + ")" } },
                [
                  _c("circle", {
                    attrs: {
                      cx: _vm.size / 2,
                      cy: _vm.size / 2,
                      r: (_vm.size - _vm.lineWidth) / 2,
                      "stroke-width": _vm.lineWidth,
                      stroke: _vm.bgcolor,
                      fill: "none",
                      "stroke-dasharray": "1069 1069"
                    }
                  }),
                  _vm._v(" "),
                  _c("circle", {
                    attrs: {
                      cx: _vm.size / 2,
                      cy: _vm.size / 2,
                      r: (_vm.size - _vm.lineWidth) / 2,
                      "stroke-width": _vm.lineWidth,
                      stroke: _vm.color.split(/\s+/g)[0],
                      fill: "none",
                      "stroke-dasharray": _vm.sd
                    }
                  })
                ]
              )
            ]),
            _vm._v(" "),
            !_vm.$slots.default || _vm.text
              ? _c(
                  "div",
                  { staticClass: "fullcenter flex-container center" },
                  [
                    _vm._t("default"),
                    _vm._v(" "),
                    !_vm.$slots.default
                      ? [_vm._v("\n  " + _vm._s(_vm.text) + "\n")]
                      : _vm._e()
                  ],
                  2
                )
              : _vm._e()
          ]
        )
      : _vm._e()
  ])
};
var __vue_staticRenderFns__$s = [];
__vue_render__$s._withStripped = true;

  /* style */
  const __vue_inject_styles__$t = undefined;
  /* scoped */
  const __vue_scope_id__$t = undefined;
  /* module identifier */
  const __vue_module_identifier__$t = undefined;
  /* functional template */
  const __vue_is_functional_template__$t = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$t = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$s, staticRenderFns: __vue_staticRenderFns__$s },
    __vue_inject_styles__$t,
    __vue_script__$t,
    __vue_scope_id__$t,
    __vue_is_functional_template__$t,
    __vue_module_identifier__$t,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$t.install = function (Vue, Maple) {
  Vue.component(__vue_component__$t.name, __vue_component__$t);
};

var dayjs_min = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,function(){var t="millisecond",e="second",n="minute",r="hour",i="day",s="week",u="month",a="quarter",o="year",h=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,f=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},d={s:c,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+c(r,2,"0")+":"+c(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.add(r,u),s=n-i<0,a=e.add(r+(s?-1:1),u);return +(-(r+(n-i)/(s?i-a:a-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return {M:u,y:o,w:s,d:i,D:"date",h:r,m:n,s:e,ms:t,Q:a}[h]||String(h||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},$={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},l="en",m={};m[l]=$;var y=function(t){return t instanceof v},M=function(t,e,n){var r;if(!t)return l;if("string"==typeof t)m[t]&&(r=t),e&&(m[t]=e,r=t);else {var i=t.name;m[i]=t,r=i;}return !n&&r&&(l=r),r||!n&&l},g=function(t,e){if(y(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new v(n)},D=d;D.l=M,D.i=y,D.w=function(t,e){return g(t,{locale:e.$L,utc:e.$u,$offset:e.$offset})};var v=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0),this.parse(t);}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(D.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(h);if(r){var i=r[2]-1||0;return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)}}return new Date(e)}(t),this.init();},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},d.$utils=function(){return D},d.isValid=function(){return !("Invalid Date"===this.$d.toString())},d.isSame=function(t,e){var n=g(t);return this.startOf(e)<=n&&n<=this.endOf(e)},d.isAfter=function(t,e){return g(t)<this.startOf(e)},d.isBefore=function(t,e){return this.endOf(e)<g(t)},d.$g=function(t,e,n){return D.u(t)?this[e]:this.set(n,t)},d.year=function(t){return this.$g(t,"$y",o)},d.month=function(t){return this.$g(t,"$M",u)},d.day=function(t){return this.$g(t,"$W",i)},d.date=function(t){return this.$g(t,"$D","date")},d.hour=function(t){return this.$g(t,"$H",r)},d.minute=function(t){return this.$g(t,"$m",n)},d.second=function(t){return this.$g(t,"$s",e)},d.millisecond=function(e){return this.$g(e,"$ms",t)},d.unix=function(){return Math.floor(this.valueOf()/1e3)},d.valueOf=function(){return this.$d.getTime()},d.startOf=function(t,a){var h=this,f=!!D.u(a)||a,c=D.p(t),d=function(t,e){var n=D.w(h.$u?Date.UTC(h.$y,e,t):new Date(h.$y,e,t),h);return f?n:n.endOf(i)},$=function(t,e){return D.w(h.toDate()[t].apply(h.toDate("s"),(f?[0,0,0,0]:[23,59,59,999]).slice(e)),h)},l=this.$W,m=this.$M,y=this.$D,M="set"+(this.$u?"UTC":"");switch(c){case o:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,v=(l<g?l+7:l)-g;return d(f?y-v:y+(6-v),m);case i:case"date":return $(M+"Hours",0);case r:return $(M+"Minutes",1);case n:return $(M+"Seconds",2);case e:return $(M+"Milliseconds",3);default:return this.clone()}},d.endOf=function(t){return this.startOf(t,!1)},d.$set=function(s,a){var h,f=D.p(s),c="set"+(this.$u?"UTC":""),d=(h={},h[i]=c+"Date",h.date=c+"Date",h[u]=c+"Month",h[o]=c+"FullYear",h[r]=c+"Hours",h[n]=c+"Minutes",h[e]=c+"Seconds",h[t]=c+"Milliseconds",h)[f],$=f===i?this.$D+(a-this.$W):a;if(f===u||f===o){var l=this.clone().set("date",1);l.$d[d]($),l.init(),this.$d=l.set("date",Math.min(this.$D,l.daysInMonth())).$d;}else d&&this.$d[d]($);return this.init(),this},d.set=function(t,e){return this.clone().$set(t,e)},d.get=function(t){return this[D.p(t)]()},d.add=function(t,a){var h,f=this;t=Number(t);var c=D.p(a),d=function(e){var n=g(f);return D.w(n.date(n.date()+Math.round(e*t)),f)};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===i)return d(1);if(c===s)return d(7);var $=(h={},h[n]=6e4,h[r]=36e5,h[e]=1e3,h)[c]||1,l=this.$d.getTime()+t*$;return D.w(l,this)},d.subtract=function(t,e){return this.add(-1*t,e)},d.format=function(t){var e=this;if(!this.isValid())return "Invalid Date";var n=t||"YYYY-MM-DDTHH:mm:ssZ",r=D.z(this),i=this.$locale(),s=this.$H,u=this.$m,a=this.$M,o=i.weekdays,h=i.months,c=function(t,r,i,s){return t&&(t[r]||t(e,n))||i[r].substr(0,s)},d=function(t){return D.s(s%12||12,t,"0")},$=i.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:D.s(a+1,2,"0"),MMM:c(i.monthsShort,a,h,3),MMMM:c(h,a),D:this.$D,DD:D.s(this.$D,2,"0"),d:String(this.$W),dd:c(i.weekdaysMin,this.$W,o,2),ddd:c(i.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:D.s(s,2,"0"),h:d(1),hh:d(2),a:$(s,u,!0),A:$(s,u,!1),m:String(u),mm:D.s(u,2,"0"),s:String(this.$s),ss:D.s(this.$s,2,"0"),SSS:D.s(this.$ms,3,"0"),Z:r};return n.replace(f,function(t,e){return e||l[t]||r.replace(":","")})},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[o]=y/12,c[u]=y,c[a]=y/3,c[s]=(m-l)/6048e5,c[i]=(m-l)/864e5,c[r]=m/36e5,c[n]=m/6e4,c[e]=m/1e3,c)[d]||m,f?y:D.a(y)},d.daysInMonth=function(){return this.endOf(u).$D},d.$locale=function(){return m[this.$L]},d.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=M(t,e,!0);return r&&(n.$L=r),n},d.clone=function(){return D.w(this.$d,this)},d.toDate=function(){return new Date(this.valueOf())},d.toJSON=function(){return this.isValid()?this.toISOString():null},d.toISOString=function(){return this.$d.toISOString()},d.toString=function(){return this.$d.toUTCString()},c}();return g.prototype=v.prototype,g.extend=function(t,e){return t(e,v,g),g},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t)},g.en=m[l],g.Ls=m,g});
});

var script$u = {
  name: 'cmui-date-picker',
  components: {
    cmuiList: __vue_component__$q,
    cmuiListItem: __vue_component__$r,
    cmuiPopup: __vue_component__
  },
  props: {
    from: {
      type: Number,
      default: 1970,
      intro: '能选择的最早的时间'
    },
    to: {
      type: Number,
      default: new Date().getFullYear(),
      intro: '能选择的最晚的时间'
    },
    now: {
      type: Number,
      default: function _default() {
        return +new Date();
      },
      intro: '本地时间(时间戳)'
    },
    border: {
      type: [String, Boolean],
      default: true,
      intro: '是否显示分割线，支持颜色字符串'
    },
    visible: {
      type: Boolean,
      default: false,
      intro: '组件是否显示需要配合sync'
    }
  },
  data: function data() {
    return {
      showYearList: false,
      showMonthList: false,
      selfDate: new Date(this.now)
    };
  },
  computed: {
    yearList: function yearList() {
      var _this = this;

      return _$1.times(this.to - this.from, function (index) {
        return _this.from + index;
      });
    },
    year: function year() {
      return new Date(this.selfDate).getFullYear();
    },
    month: function month() {
      return new Date(this.selfDate).getMonth();
    },
    dayList: function dayList() {
      var NOW = dayjs_min(this.selfDate);
      var NOWMONTH = NOW.$M;
      var preMonthDay = 8 + NOW.$W - NOW.$D % 7;
      preMonthDay = preMonthDay > 7 ? preMonthDay % 7 : preMonthDay;
      var STARTDAY = NOW.subtract(preMonthDay + NOW.$D - 1, 'days');
      return _$1.times(42, function (index) {
        var DATE = STARTDAY.add(index, 'day');
        var className = ["week".concat(DATE.$W)];

        if (index > preMonthDay - 1 && DATE.$M === NOWMONTH) {
          className.push('thisMonth');
        }

        return {
          string: DATE.$D,
          className: className,
          value: DATE
        };
      });
    },
    selfVisible: {
      get: function get() {
        return this.visible;
      },
      set: function set(value) {
        this.$emit('update:visible', value);
      }
    }
  },
  methods: {
    setYear: function setYear(year) {
      this.selfDate = new Date(this.selfDate).setFullYear(year);
      this.showYearList = false;
    },
    setMonth: function setMonth(month) {
      this.selfDate = new Date(this.selfDate).setMonth(month);
      this.showMonthList = false;
    },
    addYear: function addYear() {
      this.setYear(this.year + 1);
    },
    subYear: function subYear() {
      this.setYear(this.year - 1);
    },
    addMonth: function addMonth() {
      this.setMonth(this.month + 1);
    },
    subMonth: function subMonth() {
      this.setMonth(this.month - 1);
    },
    select: function select(item) {
      this.$emit('select', item.value);
    }
  }
};

/* script */
const __vue_script__$u = script$u;

/* template */
var __vue_render__$t = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "cmui-popup",
    {
      staticClass: "cmui-datePicker",
      attrs: {
        position: "bottom",
        visible: _vm.selfVisible,
        "target-class": "cmui-datePicker__container"
      },
      on: {
        "update:visible": function($event) {
          _vm.selfVisible = $event;
        }
      }
    },
    [
      _c(
        "div",
        { staticClass: "pos-r" },
        [
          _c("div", { staticClass: "flex-container" }, [
            _c("div", { staticClass: "flex1 flex-container yearNow" }, [
              _c("i", {
                staticClass: "baseIcon baseIcon-back ",
                on: { click: _vm.subYear }
              }),
              _vm._v(" "),
              _c(
                "span",
                {
                  staticClass: "flex1 text-center",
                  on: {
                    click: function($event) {
                      _vm.showYearList = true;
                    }
                  }
                },
                [_vm._v(_vm._s(_vm.year) + "年")]
              ),
              _vm._v(" "),
              _c("i", {
                staticClass: "baseIcon baseIcon-right ",
                on: { click: _vm.addYear }
              })
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "flex1 flex-container monthNow" }, [
              _c("i", {
                staticClass: "baseIcon baseIcon-back ",
                on: { click: _vm.subMonth }
              }),
              _vm._v(" "),
              _c(
                "span",
                {
                  staticClass: "flex1 text-center",
                  on: {
                    click: function($event) {
                      _vm.showMonthList = true;
                    }
                  }
                },
                [_vm._v(_vm._s(_vm.month + 1) + "月")]
              ),
              _vm._v(" "),
              _c("i", {
                staticClass: "baseIcon baseIcon-right ",
                on: { click: _vm.addMonth }
              })
            ])
          ]),
          _vm._v(" "),
          _c(
            "div",
            { staticClass: "flex-container cmui-datePicker__weekList" },
            _vm._l(["日", "一", "二", "三", "四", "五", "六"], function(
              item,
              key
            ) {
              return _c(
                "div",
                { key: key, staticClass: "text-center flex1 weekItem" },
                [_c("span", { domProps: { textContent: _vm._s(item) } })]
              )
            }),
            0
          ),
          _vm._v(" "),
          _c(
            "cmui-list",
            {
              staticClass: "cmui-datePicker__dayList",
              attrs: { col: 7, border: _vm.border }
            },
            _vm._l(_vm.dayList, function(item, key) {
              return _c("cmui-list-item", { key: key }, [
                _c("div", { staticClass: "dayItem", class: item.className }, [
                  _c("span", {
                    staticClass: "flex-container center",
                    domProps: { textContent: _vm._s(item.string) },
                    on: {
                      click: function($event) {
                        return _vm.select(item)
                      }
                    }
                  })
                ])
              ])
            }),
            1
          ),
          _vm._v(" "),
          _c("transition", { attrs: { name: "fade" } }, [
            _c(
              "div",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.showYearList,
                    expression: "showYearList"
                  }
                ],
                staticClass: "abs-full  scroll-container-y yearList"
              },
              _vm._l(_vm.yearList, function(yearValue, key) {
                return _c(
                  "div",
                  {
                    key: key,
                    staticClass: "yearItem",
                    class: { active: yearValue === _vm.year },
                    on: {
                      click: function($event) {
                        return _vm.setYear(yearValue)
                      }
                    }
                  },
                  [_c("span", [_vm._v(_vm._s(yearValue))])]
                )
              }),
              0
            )
          ]),
          _vm._v(" "),
          _c("transition", { attrs: { name: "fade" } }, [
            _c(
              "div",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.showMonthList,
                    expression: "showMonthList"
                  }
                ],
                staticClass: "abs-full  scroll-container-y monthList"
              },
              _vm._l(12, function(i) {
                return _c(
                  "div",
                  {
                    key: i,
                    staticClass: "monthItem",
                    class: { active: i === _vm.month + 1 }
                  },
                  [
                    _c(
                      "span",
                      {
                        on: {
                          click: function($event) {
                            return _vm.setMonth(i - 1)
                          }
                        }
                      },
                      [_vm._v(_vm._s(i) + "月")]
                    )
                  ]
                )
              }),
              0
            )
          ])
        ],
        1
      )
    ]
  )
};
var __vue_staticRenderFns__$t = [];
__vue_render__$t._withStripped = true;

  /* style */
  const __vue_inject_styles__$u = undefined;
  /* scoped */
  const __vue_scope_id__$u = undefined;
  /* module identifier */
  const __vue_module_identifier__$u = undefined;
  /* functional template */
  const __vue_is_functional_template__$u = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$u = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$t, staticRenderFns: __vue_staticRenderFns__$t },
    __vue_inject_styles__$u,
    __vue_script__$u,
    __vue_scope_id__$u,
    __vue_is_functional_template__$u,
    __vue_module_identifier__$u,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$u.install = function (Vue, Maple) {
  Vue.component(__vue_component__$u.name, __vue_component__$u);
};

var script$v = {
  name: 'cmui-mask',
  methodName: 'mask',
  argumentsRole: function argumentsRole(options, args, CURRENT) {
    var argString = _$1.filter(args, _$1.isString);

    options.position = _$1.find(argString, function (item) {
      return _$1.every(item.split(' ').filter(function (i) {
        return i.length;
      }), function (i) {
        return /^(top|left|bottom|right|center|between)$/.test(i);
      });
    });
    options.content = _$1.find(argString, function (item) {
      return item !== options.position;
    });
    options.callback = _$1.find(args, _$1.isFunction);
  },
  props: {
    position: {
      type: String,
      default: 'center',
      intro: '内容的位置，继承于flex-container，可以使用top，left，bottom，right，center，between中的任意一项或两项配合'
    },
    content: {
      type: String,
      default: '',
      intro: '遮罩内部的内容'
    },
    closeFn: {
      type: Function,
      default: null,
      intro: '关闭遮罩时的事件'
    },
    contentStyle: {
      type: Object,
      default: null,
      intro: '遮罩渲染完成后的回调'
    }
  },
  data: function data() {
    return {
      visible: false
    };
  },
  methods: {
    cancel: function cancel() {
      this.visible = false;
      document.body.classList.remove('overflow-h');
      typeof this.closeFn === 'function' && this.closeFn(this.$el);
    }
  }
};

/* script */
const __vue_script__$v = script$v;

/* template */
var __vue_render__$u = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.visible,
          expression: "visible"
        }
      ],
      staticClass: "mask",
      class: _vm.position,
      on: {
        click: function($event) {
          return _vm.cancel()
        }
      }
    },
    [
      _c("div", {
        staticClass: "mask-content",
        staticStyle: { "max-width": "100%" },
        style: _vm.contentStyle,
        domProps: { innerHTML: _vm._s(_vm.content) },
        on: {
          click: function($event) {
            $event.stopPropagation();
            $event.preventDefault();
            return (function() {})()
          },
          touchstart: function($event) {
            $event.stopPropagation();
            $event.preventDefault();
            return (function() {})()
          },
          touchmove: function($event) {
            $event.stopPropagation();
            $event.preventDefault();
            return (function() {})()
          }
        }
      })
    ]
  )
};
var __vue_staticRenderFns__$u = [];
__vue_render__$u._withStripped = true;

  /* style */
  const __vue_inject_styles__$v = undefined;
  /* scoped */
  const __vue_scope_id__$v = undefined;
  /* module identifier */
  const __vue_module_identifier__$v = undefined;
  /* functional template */
  const __vue_is_functional_template__$v = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$v = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$u, staticRenderFns: __vue_staticRenderFns__$u },
    __vue_inject_styles__$v,
    __vue_script__$v,
    __vue_scope_id__$v,
    __vue_is_functional_template__$v,
    __vue_module_identifier__$v,
    false,
    undefined,
    undefined,
    undefined
  );

dialogInstall(__vue_component__$v);

function setDisFromValue(value) {
  var barInfo = this.$refs.bar.getBoundingClientRect();
  var dotInfo = this.$refs.dot.getBoundingClientRect();
  var dis = value * (barInfo.width - dotInfo.width) / this.range;
  dis = _$1.max([dis, 0]);
  dis = _$1.min([dis, barInfo.width - dotInfo.width]);
  this.transDisX = dis;
}

var script$w = {
  name: 'cmui-slidebar',
  props: {
    value: {
      type: Number,
      default: 0,
      intro: '当前的值'
    },
    step: {
      type: Number,
      default: 0,
      intro: '每次滑动的最小单位'
    },
    range: {
      type: Number,
      default: 100,
      intro: '滑动的范围'
    }
  },
  data: function data() {
    return {
      transDisX: 0,
      barInfo: null,
      dotInfo: null,
      selfValue: this.value
    };
  },
  computed: {
    transDis: function transDis() {
      return {
        transform: "translate3d(".concat(this.transDisX, "px, -50%, 0px)")
      };
    }
  },
  watch: {
    value: function value(_value) {
      setDisFromValue.call(this, _value);
    }
  },
  mounted: function mounted() {
    setDisFromValue.call(this, this.value);
  },
  methods: {
    startHandle: function startHandle(e) {
      this.barInfo = this.$refs.bar.getBoundingClientRect();
      this.dotInfo = this.$refs.dot.getBoundingClientRect();
    },
    moveHandle: function moveHandle(e) {
      if (!this.barInfo || !this.dotInfo) {
        return;
      }

      var dis = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      dis -= this.barInfo.x + this.dotInfo.width / 2;
      dis = _$1.min([dis, this.barInfo.width - this.dotInfo.width]);
      dis = _$1.max([dis, 0]);
      var value = dis / (this.barInfo.width - this.dotInfo.width) * this.range;
      var step = Math.abs(this.step) % 100;

      if (step) {
        var c = value % step;

        if (c > step / 2) {
          value += step - c;
        } else {
          value -= c;
        }
      }

      this.selfValue = value;
      this.$emit('input', this.selfValue);
    },
    endHandle: function endHandle(e) {
      this.barInfo = null;
      this.dotInfo = null;
      this.$emit('change', this.selfValue);
    }
  }
};

var css_248z$i = ".cmui-slidebar__dot{position:absolute;left:0;top:50%}";
styleInject(css_248z$i);

/* script */
const __vue_script__$w = script$w;
/* template */
var __vue_render__$v = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "cmui-slidebar",
      class: { start: _vm.value === 0, end: _vm.value === _vm.range }
    },
    [
      _c("div", { staticClass: "cmui-slidebar__warp flex-container hfull" }, [
        _c("div", { ref: "bar", staticClass: "cmui-slidebar__bar pos-r" }, [
          _c("div", {
            staticClass: "cmui-slidebar__progress",
            style: { width: _vm.transDisX + "px" }
          }),
          _vm._v(" "),
          _c("div", {
            ref: "dot",
            staticClass: "cmui-slidebar__dot",
            style: _vm.transDis,
            on: {
              touchstart: function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.startHandle($event)
              },
              touchmove: function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.moveHandle($event)
              },
              touchend: function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.endHandle($event)
              },
              mousedown: function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.startHandle($event)
              },
              mousemove: function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.moveHandle($event)
              },
              mouseup: function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.endHandle($event)
              }
            }
          })
        ])
      ])
    ]
  )
};
var __vue_staticRenderFns__$v = [];
__vue_render__$v._withStripped = true;

  /* style */
  const __vue_inject_styles__$w = undefined;
  /* scoped */
  const __vue_scope_id__$w = undefined;
  /* module identifier */
  const __vue_module_identifier__$w = undefined;
  /* functional template */
  const __vue_is_functional_template__$w = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$w = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$v, staticRenderFns: __vue_staticRenderFns__$v },
    __vue_inject_styles__$w,
    __vue_script__$w,
    __vue_scope_id__$w,
    __vue_is_functional_template__$w,
    __vue_module_identifier__$w,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$w.install = function (Vue, Maple) {
  Vue.component(__vue_component__$w.name, __vue_component__$w);
};

var script$x = {
  name: 'cmui-scroll',
  props: {
    col: {
      type: [String, Number],
      default: 'auto',
      intro: '如果为auto则不固定列数，如果为数字类型则表示列数'
    },
    direction: {
      type: String,
      default: 'h',
      intro: '滚动的方向，可选值是h和v'
    },
    watch: {
      type: [Array, Object],
      default: function _default() {
        return null;
      },
      intro: '要监控的内容，通常是在scroll-item中v-for对应的内容，当内容变化时会更新滚动容器'
    },
    pullDis: {
      type: Number,
      default: 50,
      intro: '边缘滑动距离，超过这个距离将触发对应事件'
    },
    pullEvent: {
      type: Boolean,
      default: true,
      intro: '是否使用pull事件，如果为false，边缘滑动对应的事件不会触发'
    },
    freeMode: {
      type: Boolean,
      default: true,
      intro: '是否使用free模式，如果为false，将以scroll-item为组进行滑动'
    },
    pullText: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '边缘滑动需要展示的文本，支持4种状态，通常写成下拉刷新,释放刷新,上拉加载,释放加载，你也可以替换成其他的文本或HTML'
    }
  },
  data: function data() {
    return {
      swiper: null,
      pullStartStyle: {
        transform: ''
      },
      pullEndStyle: {
        transform: ''
      },
      pullStartText: '',
      pullEndText: ''
    };
  },
  watch: {
    watch: function watch() {
      var _this2 = this;

      if (this.swiper) {
        this.$nextTick(function () {
          _this2.swiper.update();
        });
      }
    }
  },
  mounted: function mounted() {
    var container = this.$refs.scroll;

    var _this = this;

    this.$nextTick(function () {
      _this.swiper = new Swiper(container, {
        direction: _this.direction === 'v' ? 'vertical' : 'horizontal',
        slidesPerView: +_this.col || 'auto',
        freeMode: _this.freeMode,
        on: {
          progress: function progress(value) {
            _this.updatePull(value, this.translate);
          },
          touchEnd: function touchEnd() {
            _this.updatePull(this.progress, this.translate, true);

            _$1.delay(_this.resetPull);
          }
        }
      });

      _this.$emit('rendered', this);
    });
  },
  destroyed: function destroyed() {
    this.swiper.destroy();
  },
  methods: {
    updatePull: function updatePull(progress, translate, endHandel) {
      if (!this.pullEvent) {
        return;
      }

      if (progress < 0) {
        if (translate > this.pullDis) {
          this.pullStartText = _$1.get(this.pullText, 1);
          endHandel && this.$emit('pullStart', this);
        } else {
          this.pullStartText = _$1.get(this.pullText, 0);
        }

        var dis = parseInt(_$1.min([translate - 20, 10]));

        if (this.direction === 'v') {
          this.pullStartStyle.transform = 'translate(0,' + dis + 'px)';
        } else {
          this.pullStartStyle.transform = 'translate(' + dis + 'px,0)';
        }
      } else if (progress > 1) {
        /**
         * todo 位置计算
         * 现在滑动到底部时的距离计算有误差，需要改正
         * */
        if (translate * (progress - 1) * -1 - 20 > this.pullDis) {
          this.pullEndText = _$1.get(this.pullText, 3);
          endHandel && this.$emit('pullEnd', this);
        } else {
          this.pullEndText = _$1.get(this.pullText, 2);
        }

        var _dis = _$1.min([translate * (progress - 1) * -1 - 20, 10]) * -1;

        if (this.direction === 'v') {
          this.pullEndStyle.transform = 'translate(0,' + _dis + 'px)';
        } else {
          this.pullEndStyle.transform = 'translate(' + _dis + 'px,0)';
        }
      }

      this.$emit('pull', progress, this);
    },
    resetPull: function resetPull() {
      this.pullStartStyle.transform = 'translate(-100%)';
      this.pullEndStyle.transform = 'translate(-100%)';
    }
  }
};

/* script */
const __vue_script__$x = script$x;

/* template */
var __vue_render__$w = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { ref: "scroll", staticClass: "cmui-scroll swiper-container" },
    [
      _vm.pullEvent
        ? _c(
            "div",
            {
              ref: "pullStart",
              staticClass: "abs-top flex-container hfull",
              style: _vm.pullStartStyle
            },
            [
              _vm.$slots.pullStart ? _vm._t("pullStart") : _vm._e(),
              _vm._v(" "),
              _c("p", {
                staticClass: "text-center",
                domProps: { textContent: _vm._s(_vm.pullStartText) }
              })
            ],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c("div", { staticClass: "swiper-wrapper" }, [_vm._t("default")], 2),
      _vm._v(" "),
      _c(
        "div",
        {
          ref: "pullEnd",
          staticClass: "abs-bottom flex-container hfull",
          style: _vm.pullEndStyle
        },
        [
          _vm.$slots.pullEnd ? _vm._t("pullEnd") : _vm._e(),
          _vm._v(" "),
          _c("p", {
            staticClass: "text-center",
            domProps: { textContent: _vm._s(_vm.pullEndText) }
          })
        ],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$w = [];
__vue_render__$w._withStripped = true;

  /* style */
  const __vue_inject_styles__$x = undefined;
  /* scoped */
  const __vue_scope_id__$x = undefined;
  /* module identifier */
  const __vue_module_identifier__$x = undefined;
  /* functional template */
  const __vue_is_functional_template__$x = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$x = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$w, staticRenderFns: __vue_staticRenderFns__$w },
    __vue_inject_styles__$x,
    __vue_script__$x,
    __vue_scope_id__$x,
    __vue_is_functional_template__$x,
    __vue_module_identifier__$x,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$x.install = function (Vue, Maple) {
  Vue.component(__vue_component__$x.name, __vue_component__$x);
};

//
var script$y = {
  name: 'cmui-scroll-item',
  mixins: [basemixin],
  data: function data() {
    var parent = this.getParent('cmui-scroll');
    var itemStyle = {};

    if (_$1.get(parent, 'direction') === 'v' && _$1.get(parent, 'col') === 'auto') {
      itemStyle.height = 'auto';
    }

    return {
      itemStyle: itemStyle
    };
  }
};

/* script */
const __vue_script__$y = script$y;

/* template */
var __vue_render__$x = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { staticClass: "swiper-slide overflow-h", style: _vm.itemStyle },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$x = [];
__vue_render__$x._withStripped = true;

  /* style */
  const __vue_inject_styles__$y = undefined;
  /* scoped */
  const __vue_scope_id__$y = undefined;
  /* module identifier */
  const __vue_module_identifier__$y = undefined;
  /* functional template */
  const __vue_is_functional_template__$y = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$y = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$x, staticRenderFns: __vue_staticRenderFns__$x },
    __vue_inject_styles__$y,
    __vue_script__$y,
    __vue_scope_id__$y,
    __vue_is_functional_template__$y,
    __vue_module_identifier__$y,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$y.install = function (Vue, Maple) {
  Vue.component(__vue_component__$y.name, __vue_component__$y);
};

var touchesStart = {};
var isTouched;
var isScrolling;
var openedList = [];
ready(function (window) {
  if (window) {
    window.addEventListener('scroll', function () {
      openedList.forEach(function (item) {
        return item.close();
      });
    });
  }
});
var script$z = {
  name: 'cmui-swiper',
  props: {
    right: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '右侧滑动列表项'
    },
    left: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '左侧滑动列表项'
    }
  },
  data: function data() {
    return {
      leftDis: 0,
      rightDis: 0,
      handleData: {
        currentTrans: 0,
        dis: 0
      },
      transDis: {
        transform: 'translate3d(0px, 0px, 0px)'
      },
      hasOpened: false
    };
  },
  watch: {
    right: {
      immediate: true,
      handler: function handler() {
        var _this = this;

        this.$nextTick(function () {
          _this.rightDis = _this.$refs.right.getBoundingClientRect().width;
        });
      }
    },
    left: {
      immediate: true,
      handler: function handler() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.leftDis = _this2.$refs.left.getBoundingClientRect().width;
        });
      }
    }
  },
  methods: {
    handleTouchStart: function handleTouchStart(e) {
      var _this3 = this;

      _$1.forEach(openedList, function (item) {
        return item !== _this3 && item.close();
      });

      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isScrolling = undefined;
    },
    handleTouchMove: function handleTouchMove(e) {
      if (!isTouched) return;
      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      var disX = pageX - touchesStart.x;
      var disY = pageY - touchesStart.y;

      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(disX) < Math.abs(disY));
      }

      if (isScrolling) {
        isTouched = false;
        return;
      }

      e.preventDefault();
      var dis = disX + this.handleData.currentTrans;

      if (dis > 0) {
        dis = Math.min(Math.abs(dis), this.leftDis);
      }

      if (dis < 0) {
        dis = Math.min(Math.abs(dis), this.rightDis) * -1;
      }

      this.transDis.transform = "translate3d(".concat(dis, "px, 0px, 0px)");
      this.handleData.dis = dis;
    },
    handleTouchEnd: function handleTouchEnd() {
      var _this4 = this;

      this.$el.classList.add('translating');
      var dis = this.handleData.dis;

      if (dis > 0 && dis > this.leftDis / 2) {
        dis = this.leftDis;
      } else if (dis < 0 && Math.abs(dis) > this.rightDis / 2) {
        dis = this.rightDis * -1;
      } else {
        dis = 0;
      }

      this.handleData.dis = this.handleData.currentTrans = dis;

      if (dis && !this.hasOpened) {
        openedList.push(this);
        this.hasOpened = true;
      }

      this.transDis.transform = "translate3d(".concat(dis, "px, 0px, 0px)");

      _$1.delay(function () {
        _this4.$el.classList.remove('translating');
      }, 300);
    },
    controlHandle: function controlHandle(pos, index, text) {
      this.$emit('swiper', {
        pos: pos,
        index: index,
        text: text,
        vm: this
      });
    },
    close: function close() {
      var _this5 = this;

      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      this.hasOpened = false;
      this.handleData.currentTrans = 0;
      this.handleData.dis = 0;
      this.$el.classList.add('translating');
      this.transDis.transform = "translate3d(0px, 0px, 0px)";

      _$1.delay(function () {
        _this5.$el.classList.remove('translating');

        callback();
      }, 300);

      _$1.remove(openedList, function (item) {
        return item === _this5;
      });
    }
  }
};

var css_248z$j = ".cmui-swiper{-webkit-transform-style:preserve-3d;transform-style:preserve-3d;overflow:hidden}.cmui-swiper.translating .cmui-swiper__content,.cmui-swiper.translating .cmui-swiper__control{-webkit-transition:.3s;transition:.3s}.cmui-swiper__control{height:100%;padding:20px}.cmui-swiper__right{-webkit-transform:translateX(100%);transform:translateX(100%)}.cmui-swiper__left{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.cmui-swiper__left .cmui-swiper__control:first-child{background-color:#857e7f}.cmui-swiper__left .cmui-swiper__control:nth-child(2){background-color:#ff9827}.cmui-swiper__left .cmui-swiper__control:nth-child(3){background-color:#fffe43}.cmui-swiper__right .cmui-swiper__control:last-child{background-color:#ff3a3c}.cmui-swiper__right .cmui-swiper__control:nth-last-child(2){background-color:#ff9827}.cmui-swiper__right .cmui-swiper__control:nth-last-child(3){background-color:#fffe43}";
styleInject(css_248z$j);

/* script */
const __vue_script__$z = script$z;
/* template */
var __vue_render__$y = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      ref: "swiper",
      staticClass: "cmui-swiper pos-r",
      on: {
        touchstart: _vm.handleTouchStart,
        touchmove: _vm.handleTouchMove,
        touchend: _vm.handleTouchEnd
      }
    },
    [
      _c(
        "div",
        { staticClass: "cmui-swiper__content pos-r", style: _vm.transDis },
        [_vm._t("default"), _vm._v(" "), _vm._t("right")],
        2
      ),
      _vm._v(" "),
      _c(
        "div",
        {
          ref: "left",
          staticClass: "cmui-swiper__left abs-left flex-container"
        },
        _vm._l(_vm.left, function(item, index) {
          return _c("div", {
            key: index,
            staticClass: "cmui-swiper__control flex-container center",
            style: _vm.transDis,
            domProps: { textContent: _vm._s(item) },
            on: {
              click: function($event) {
                return _vm.controlHandle("left", index, item)
              }
            }
          })
        }),
        0
      ),
      _vm._v(" "),
      _c(
        "div",
        {
          ref: "right",
          staticClass: "cmui-swiper__right abs-right flex-container"
        },
        _vm._l(_vm.right, function(item, index) {
          return _c("div", {
            key: index,
            staticClass: "cmui-swiper__control flex-container center",
            style: _vm.transDis,
            domProps: { textContent: _vm._s(item) },
            on: {
              click: function($event) {
                return _vm.controlHandle("right", index, item)
              }
            }
          })
        }),
        0
      )
    ]
  )
};
var __vue_staticRenderFns__$y = [];
__vue_render__$y._withStripped = true;

  /* style */
  const __vue_inject_styles__$z = undefined;
  /* scoped */
  const __vue_scope_id__$z = undefined;
  /* module identifier */
  const __vue_module_identifier__$z = undefined;
  /* functional template */
  const __vue_is_functional_template__$z = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$z = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$y, staticRenderFns: __vue_staticRenderFns__$y },
    __vue_inject_styles__$z,
    __vue_script__$z,
    __vue_scope_id__$z,
    __vue_is_functional_template__$z,
    __vue_module_identifier__$z,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$z.install = function (Vue, Maple) {
  Vue.component(__vue_component__$z.name, __vue_component__$z);
};

var script$A = {
  name: 'cmui-tabbar-nav',
  props: {
    items: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    activeIndex: {
      type: Number,
      default: 0
    },
    itemStyle: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  inject: ['cmuiTabbar'],
  methods: {
    itemEvent: function itemEvent(item, index) {
      var oldIndex = this.cmuiTabbar.activeIndex;
      this.$emit('nav-item', item, index, oldIndex);
      this.cmuiTabbar.changeToIndex(index);
    }
  },
  render: function render(h) {
    var _this = this;

    this.cmuiTabbar.items.forEach(function (item, index) {
      return item.index = index;
    });
    var items = this.cmuiTabbar.items.map(function (item, index) {
      return h('div', {
        class: ['cmui-tabbar__head-item', {
          active: index === _this.cmuiTabbar.activeIndex,
          flex1: _this.cmuiTabbar.col !== 'center'
        }],
        style: _this.itemStyle,
        on: {
          click: function click() {
            _this.itemEvent(item, index);
          }
        }
      }, item.$slots.title || [h('div', {}, item.$attrs.title)]);
    });
    return h('div', {
      class: 'cmui-tabbar__nav flex1'
    }, items);
  }
};

/* script */
const __vue_script__$A = script$A;

/* template */

  /* style */
  const __vue_inject_styles__$A = undefined;
  /* scoped */
  const __vue_scope_id__$A = undefined;
  /* module identifier */
  const __vue_module_identifier__$A = undefined;
  /* functional template */
  const __vue_is_functional_template__$A = undefined;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$A = /*#__PURE__*/normalizeComponent(
    {},
    __vue_inject_styles__$A,
    __vue_script__$A,
    __vue_scope_id__$A,
    __vue_is_functional_template__$A,
    __vue_module_identifier__$A,
    false,
    undefined,
    undefined,
    undefined
  );

function log (text, data) {
  var styleString = '';
  styleString += 'font-size:13px;';
  styleString += 'font-family:"microsoft yahei";';
  styleString += 'color:#125ce8;';
  var line = '------------------';

  if (arguments.length !== 1) {
    console.log('%c' + line + text.toString() + line + '', styleString);

    for (var i = 1; i < arguments.length; i++) {
      console.log(arguments[i]);
    }

    console.log('%c' + line + text.toString() + line + '\n\n\n', styleString);
  } else {
    console.log('%c' + line + line + '', styleString);
    console.log(text);
    console.log('%c' + line + line + '\n\n\n', styleString);
  }
}

var timer;

function scrollTo(target) {
  var dom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
  var animate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  timer && cancelAnimationFrame(timer);
  var top = target.top,
      left = target.left;

  if (_$1.isNumber(top)) {
    var domPos = dom.scrollTop;

    if (Math.abs(top - domPos) <= 3 || !animate) {
      dom.scrollTop = top;
      _$1.isFunction(callback) && callback();
    } else {
      var t = dom.scrollTop;
      dom.scrollTop = top < domPos ? domPos - domPos / 8 : domPos + (top - domPos) / 8 + 1;
      if (dom.scrollTop === t) return;
      timer = requestAnimationFrame(function () {
        return scrollTo({
          top: top
        }, dom, callback);
      });
    }
  }

  if (_$1.isNumber(left)) {
    var _domPos = dom.scrollLeft;

    if (Math.abs(left - _domPos) <= 3 || !animate) {
      dom.scrollLeft = left;
      _$1.isFunction(callback) && callback();
    } else {
      var _t = dom.scrollLeft;
      dom.scrollLeft = left < _domPos ? _domPos - _domPos / 8 : _domPos + (left - _domPos) / 8 + 1;
      if (dom.scrollLeft === _t) return;
      timer = requestAnimationFrame(function () {
        return scrollTo({
          left: left
        }, dom, callback);
      });
    }
  }
}

function scrollBar () {
  for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
    arg[_key] = arguments[_key];
  }

  var dom = _$1.remove(arg, _$1.isElement)[0] || document.documentElement;

  var animate = _$1.remove(arg, _$1.isBoolean)[0];

  var callback = _$1.remove(arg, _$1.isFunction)[0];

  var domScrollTop = dom.scrollTop || document.body.scrollTop;
  var domScrollLeft = dom.scrollLeft || document.body.scrollLeft;
  var argLen = arg.length;
  var regexp = /^-?(\d+(?:\.\d+)?)(%|view)?$/;
  var curr, total, view, temp;

  if (argLen === 1) {
    // 读操作
    switch (arg[0]) {
      case 'top':
        total = dom.scrollHeight;
        curr = domScrollTop;
        view = dom.clientHeight;
        break;

      case 'bottom':
        total = dom.scrollHeight;
        view = dom.clientHeight;
        curr = total - domScrollTop - view;
        break;

      case 'left':
        total = dom.scrollWidth;
        curr = domScrollLeft;
        view = dom.clientWidth;
        break;

      case 'right':
        total = dom.scrollWidth;
        view = dom.clientWidth;
        curr = total - domScrollLeft - view;
        break;
    }

    return {
      px: curr,
      percent: Math.floor(curr / total * 100),
      view: parseFloat((curr / view).toFixed(1))
    };
  } else {
    // 写操作
    temp = regexp.exec(arg[1].toString());

    if (temp) {
      switch (arg[0]) {
        case 'top':
          curr = parseFloat(temp[1]);

          if (temp[2] === '%') {
            // 百分比
            curr = curr * dom.scrollHeight / 100;
          } else if (temp[2] === 'view') {
            // 屏数
            curr = curr * dom.clientHeight;
          }

          scrollTo({
            top: curr
          }, dom, callback, animate); // dom.scrollTop = curr

          break;

        case 'bottom':
          curr = parseFloat(temp[1]);

          if (temp[2] === '%') {
            // 百分比
            curr = Math.max(dom.scrollHeight * (1 - curr / 100), 0);
          } else if (temp[2] === 'view') {
            // 屏数
            curr = Math.max(dom.scrollHeight - (curr + 1) * dom.clientHeight, 0);
          } else {
            curr = dom.scrollHeight - curr;
          }

          scrollTo({
            top: curr
          }, dom, callback, animate); // dom.scrollTop = curr

          break;

        case 'left':
          curr = parseFloat(temp[1]);

          if (temp[2] === '%') {
            // 百分比
            curr = curr * dom.scrollWidth / 100;
          } else if (temp[2] === 'view') {
            // 屏数
            curr = curr * dom.clientWidth;
          }

          scrollTo({
            left: curr
          }, dom, callback, animate); // dom.scrollLeft = curr

          break;

        case 'right':
          curr = parseFloat(temp[1]);

          if (temp[2] === '%') {
            // 百分比
            curr = Math.max(dom.scrollWidth * (1 - curr / 100), 0);
          } else if (temp[2] === 'view') {
            // 屏数
            curr = Math.max(dom.scrollWidth - (curr + 1) * dom.clientWidth, 0);
          } else {
            curr = dom.scrollWidth - curr;
          }

          scrollTo({
            left: curr
          }, dom, callback, animate); // dom.scrollLeft = curr

          break;

        default:
          log('scrollBar反向设置错误，请使用"left right top bottom" 中的值');
          break;
      }
    } else {
      log('scrollBar数值设置错误，请使用"20"，"20%"或"20view"形式的参数');
    }
  }
}

var contentScrollEvent = _$1.throttle(function (e) {
  if (this.stopScrollEvent) return;

  if (this.isVertical) {
    var _this$$refs$content$g = this.$refs.content.getBoundingClientRect(),
        contentTop = _this$$refs$content$g.top,
        contentBottom = _this$$refs$content$g.bottom;

    switch (e.target) {
      case this.$refs.content:
        var findIndex = _$1.findLastIndex(this.$refs.content.childNodes, function (item) {
          return item.getBoundingClientRect().top <= contentTop;
        });

        if (~findIndex) this.activeIndex = findIndex;
        break;

      case document:
        this.disableContent = !(contentTop <= this.top || contentBottom <= document.documentElement.clientHeight);
        break;
    }
  } else {
    var _this$$refs$head$getB = this.$refs.head.getBoundingClientRect(),
        top = _this$$refs$head$getB.top,
        height = _this$$refs$head$getB.height;

    var _findIndex = _$1.findLastIndex(this.$refs.content.childNodes, function (item) {
      return item.getBoundingClientRect().top <= top + height;
    });

    if (~_findIndex) this.activeIndex = _findIndex;
  }
}, {
  wait: 50,
  trailing: false
});

var script$B = {
  name: 'cmui-tabbar',
  components: {
    cmuiTabbarNav: __vue_component__$A
  },
  provide: function provide() {
    return {
      cmuiTabbar: this
    };
  },
  props: {
    col: {
      type: [String, Number],
      default: 'auto',
      intro: 'nav的列数,如果为数字则将nav分成对应的份数，如果item数量超过col则滚动显示'
    },
    index: {
      type: Number,
      default: 0,
      intro: '活动的索引'
    },
    nav: {
      type: Array,
      default: function _default() {
        return [false, false];
      },
      intro: '是否显示左右导航'
    },
    position: {
      type: String,
      default: 'top',
      intro: 'nav栏的位置，你可以在top bottom right left中任选其一'
    },
    screen: {
      type: Boolean,
      default: false,
      intro: '是否使用筛选模式'
    },
    top: {
      type: Number,
      default: 0,
      intro: '粘贴距顶部的位置，单位：像素'
    },
    throttle: {
      type: Number,
      default: 100,
      intro: 'screen模式下节流函数的间隔时间'
    }
  },
  data: function data() {
    return {
      items: [],
      activeIndex: this.index,
      stopScrollEvent: false,
      disableContent: true,
      contentScrollEvent: contentScrollEvent.bind(this)
    };
  },
  computed: {
    stopContentScroll: function stopContentScroll() {
      return this.isVertical && this.disableContent;
    },
    itemStyle: function itemStyle() {
      var rs = {};

      if (_$1.isNumber(this.col)) {
        rs[this.isVertical ? 'height' : 'width'] = 100 / this.col + '%';
      }

      return rs;
    },
    isVertical: function isVertical() {
      return _$1.includes(['left', 'right'], this.position);
    },
    headContainerClass: function headContainerClass() {
      return {
        'scroll-container': !this.isVertical,
        'scroll-container-y': this.isVertical,
        'flex-container': this.col === 'flex' && !this.isVertical,
        'flex-container-col': this.col === 'flex' && this.isVertical,
        'flex-container center': this.col === 'center' && !this.isVertical,
        'flex-container-col center': this.col === 'center' && this.isVertical
      };
    },
    showPreNav: function showPreNav() {
      return !!_$1.get(this.nav, '[0]');
    },
    showNextNav: function showNextNav() {
      return !!_$1.get(this.nav, '[1]');
    },
    extras: function extras() {
      return this.$slots.extra || [];
    }
  },
  watch: {
    activeIndex: function activeIndex(index) {
      this.$emit('update:index', index);
    }
  },
  mounted: function mounted() {
    this.update();

    if (this.screen) {
      document.addEventListener('scroll', this.contentScrollEvent, true);
    }
  },
  destroyed: function destroyed() {
    if (this.screen) {
      document.removeEventListener('scroll', this.contentScrollEvent);
    }
  },
  updated: function updated() {
    this.update();
  },
  methods: {
    scrollAcitveIntoViewIfNeeded: function scrollAcitveIntoViewIfNeeded() {
      var isStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var tabBar = this.$refs.nav.$el;
      var activeItem = tabBar.children[this.activeIndex];
      var tabBarP = tabBar.getBoundingClientRect();
      var activeItemP = activeItem.getBoundingClientRect();
      var pos = this.isVertical ? ['top', 'bottom'] : ['left', 'right'];

      if (!_$1.inRange(activeItemP[pos[0]], tabBarP[pos[0]], tabBarP[pos[1]])) {
        activeItem.scrollIntoView(isStart);
      }
    },
    changeToNext: function changeToNext() {
      if (this.activeIndex < this.items.length - 1) {
        this.activeIndex++;
        this.changeToIndex(this.activeIndex);
      }
    },
    changeToPre: function changeToPre() {
      if (this.activeIndex > 0) {
        this.activeIndex--;
        this.changeToIndex(this.activeIndex);
      }
    },
    changeToIndex: function changeToIndex() {
      var _this2 = this;

      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (_$1.inRange(index, this.items.length)) {
        var _this = this;

        var targetContent = this.$refs.content.childNodes[index];
        this.activeIndex = index;

        if (this.screen) {
          this.stopScrollEvent = true;

          if (this.isVertical) {
            scrollBar(this.$refs.content, 'top', targetContent.offsetTop, true, function () {
              _$1.delay(function () {
                _this.stopScrollEvent = false;
              }, 100);
            });
          } else {
            var t = targetContent.getBoundingClientRect().top + targetContent.ownerDocument.defaultView.pageYOffset - this.$refs.head.getBoundingClientRect().height;
            scrollBar('top', t, true, function () {
              _$1.delay(function () {
                _this.stopScrollEvent = false;
              }, 100);
            });
          }
        }

        this.$nextTick(function () {
          _this2.scrollAcitveIntoViewIfNeeded(true);
        });
      }
    },
    changeByStep: function changeByStep() {
      var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (_$1.inRange(this.activeIndex + num, this.items.length)) {
        this.activeIndex += num;
        this.changeToIndex(this.activeIndex);
      }
    },
    getItems: function getItems() {
      return _$1.filter(this.$slots.default, function (item) {
        return item.tag === 'cmui-tabbar-item';
      });
    },
    extraEvent: function extraEvent(event, item, index) {
      this.$emit('extra-click', this, item, index);
    },
    navItem: function navItem() {
      this.$emit.apply(this, ['item-click', this].concat(Array.prototype.slice.call(arguments)));
    },
    update: function update() {
      var _this3 = this;

      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.$slots.default) {
        var items = _$1.filter(this.$slots.default, function (vnode) {
          return _$1.get(vnode, 'componentOptions.Ctor.options.name') === 'cmui-tabbar-item';
        }).map(function (_ref) {
          var componentInstance = _ref.componentInstance;
          return componentInstance;
        });

        var changed = !(items.length === this.items.length && items.every(function (pane, index) {
          return pane === _this3.items[index];
        }));

        if (force || changed) {
          this.items = items;
        }
      } else {
        this.items = [];
      }
    }
  },
  render: function render(h) {
    var items = this.items,
        activeIndex = this.activeIndex,
        position = this.position,
        changeToPre = this.changeToPre,
        changeToNext = this.changeToNext,
        headContainerClass = this.headContainerClass,
        isVertical = this.isVertical,
        itemStyle = this.itemStyle,
        navItem = this.navItem,
        screen = this.screen,
        extras = this.extras,
        extraEvent = this.extraEvent;
    var content = h('div', {
      class: {
        'cmui-tabbar__content pos-r': true,
        'flex1': screen || isVertical,
        'scroll-container-y': this.screen,
        'overflow-h': this.stopContentScroll
      },
      on: {
        scroll: contentScrollEvent.bind(this)
      },
      ref: 'content'
    }, this.$slots.default);
    var pre = h('div', {
      class: {
        'cmui-tabbar__pre': true,
        'text-center': true
      },
      on: {
        click: changeToPre
      }
    }, [h('i', {
      class: "baseIcon baseIcon-".concat(isVertical ? 'fold' : 'back')
    })]);
    var next = h('div', {
      class: {
        'cmui-tabbar__next': true,
        'text-center': true
      },
      on: {
        click: changeToNext
      }
    }, [h('i', {
      class: "baseIcon baseIcon-".concat(isVertical ? 'unfold' : 'right')
    })]);
    var nav = h('cmui-tabbar-nav', {
      class: headContainerClass,
      props: {
        items: items,
        activeIndex: activeIndex,
        itemStyle: itemStyle
      },
      on: {
        'nav-item': navItem
      },
      ref: 'nav'
    });
    var extraList = extras.map(function (item, index) {
      return h('div', {
        class: 'cmui-tabbar__extra-item',
        key: index,
        on: {
          click: _$1.partialRight(extraEvent, item, index)
        }
      }, [item]);
    });
    var extra = h('div', {
      class: {
        'cmui-tabbar__extra': true,
        'flex-container': !isVertical
      }
    }, extraList);
    var head = h('div', {
      class: {
        'cmui-tabbar__head': true,
        'flex-container': !isVertical,
        'flex-container-col': isVertical,
        'pos-s': screen
      },
      style: {
        top: screen ? +this.top + 'px' : undefined,
        'z-index': 1
      },
      ref: 'head'
    }, [this.nav[0] ? pre : undefined, nav, this.nav[1] ? next : undefined, extraList.length ? extra : undefined]);
    return h('div', {
      class: ["cmui-tabbar cmui-tabbar-".concat(this.position), {
        'flex-container vfull': this.isVertical,
        'flex-container-col hfull': this.screen && !this.isVertical
      }],
      style: {
        height: this.screen && isVertical ? '100vh' : undefined // vnode.data.staticStyle.height

      }
    }, _$1.includes(['right', 'bottom'], position) ? [content, head] : [head, content]);
  }
};

/* script */
const __vue_script__$B = script$B;

/* template */

  /* style */
  const __vue_inject_styles__$B = undefined;
  /* scoped */
  const __vue_scope_id__$B = undefined;
  /* module identifier */
  const __vue_module_identifier__$B = undefined;
  /* functional template */
  const __vue_is_functional_template__$B = undefined;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$B = /*#__PURE__*/normalizeComponent(
    {},
    __vue_inject_styles__$B,
    __vue_script__$B,
    __vue_scope_id__$B,
    __vue_is_functional_template__$B,
    __vue_module_identifier__$B,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$B.install = function (Vue, Maple) {
  Vue.component(__vue_component__$B.name, __vue_component__$B);
};

//
//
//
//
//
var script$C = {
  name: 'cmui-tabbar-item',
  inject: ['cmuiTabbar'],
  data: function data() {
    return {
      index: null
    };
  },
  computed: {
    active: function active() {
      return this.cmuiTabbar.screen || this.index === this.cmuiTabbar.activeIndex;
    }
  },
  updated: function updated() {
    this.cmuiTabbar.update(true);
  }
};

/* script */
const __vue_script__$C = script$C;

/* template */
var __vue_render__$z = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.active,
          expression: "active"
        }
      ],
      staticClass: "cmui-tabbar-item"
    },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$z = [];
__vue_render__$z._withStripped = true;

  /* style */
  const __vue_inject_styles__$C = undefined;
  /* scoped */
  const __vue_scope_id__$C = undefined;
  /* module identifier */
  const __vue_module_identifier__$C = undefined;
  /* functional template */
  const __vue_is_functional_template__$C = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$C = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$z, staticRenderFns: __vue_staticRenderFns__$z },
    __vue_inject_styles__$C,
    __vue_script__$C,
    __vue_scope_id__$C,
    __vue_is_functional_template__$C,
    __vue_module_identifier__$C,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$C.install = function (Vue, Maple) {
  Vue.component(__vue_component__$C.name, __vue_component__$C);
};

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$D = {
  name: 'cmui-virtual-list',
  props: {
    // 所有列表数据
    listData: {
      type: Array,
      default: function _default() {
        return [];
      },
      intro: '列表所需要的数据'
    },
    // 列表列数
    column: {
      type: Number,
      default: 1,
      intro: '列数'
    },
    // 是否开启下拉刷新
    topLoadMore: {
      type: Boolean,
      default: false,
      intro: '是否启用下拉刷新'
    },
    // 超过阈值的回调
    topMethod: {
      type: Function,
      default: function _default() {
        return function () {};
      },
      intro: '刷新时调用的回调函数'
    },
    topTextColor: {
      type: String,
      default: '#000000',
      intro: '刷新区域的文本颜色'
    },
    topPullText: {
      type: String,
      default: '上拉刷新',
      intro: '刷新状态为pull时提示区的文字'
    },
    topDropText: {
      type: String,
      default: '释放更新',
      intro: '刷新状态为drop时提示区的文字'
    },
    topLoadingText: {
      type: String,
      default: '加载中...',
      intro: '刷新状态为loading时提示区的文字'
    },
    // 最大滑动距离
    maxDistance: {
      type: Number,
      default: 0,
      intro: '组件可移动的最大距离（像素），若为 0 则不限制'
    },
    // 滑动距离与真实距离比值
    distanceScale: {
      type: Number,
      default: 2,
      intro: '手指移动与组件移动距离的比值'
    },
    // 滑动距离阈值，超过阈值回调
    topDistance: {
      type: Number,
      default: 70,
      intro: '触发 topMethod 的下拉距离阈值（像素）'
    },
    // onScroll: {
    //   type: Function,
    //   default: null,
    //   intro:'列表所需要的数据'
    // },
    // onScrollEnd: {
    //   type: Function,
    //   default: null,
    //   intro:'列表所需要的数据'
    // },
    // 预估高度
    estimatedItemSize: {
      type: Number,
      required: true,
      intro: '列表项的预估高度，用于预先计算可视区域的显示项数'
    },
    // 缓冲区比例
    bufferScale: {
      type: Number,
      default: 1,
      intro: '在可见区域之外的上/下方预渲染比例，避免快速滑动时出现闪烁'
    },
    // 容器高度 100px or 50vh
    height: {
      type: String,
      default: '100%',
      intro: '包裹元素的高度'
    }
  },
  data: function data() {
    return {
      // 拖拽状态
      // pull 开始拖拽，距离未达到topDistance
      // drop 距离达到 topDistance 释放触发 topMethod
      // loading 已被释放，topMethod 已经执行
      // none 拖拽完成或未触发
      dargState: 'none',
      // 当前下拉距离
      touchDistance: 0,
      // 是否正在滚动
      scrolling: false,
      // 可视区域高度
      screenHeight: 0,
      // 起始索引
      start: 0,
      // 结束索引
      end: 0
    };
  },
  computed: {
    _listData: function _listData() {
      var _this = this;

      return this.listData.reduce(function (init, cur, index) {
        if (index % _this.column === 0) {
          init.push({
            // _转换后的索引_第一项在原列表中的索引_本行包含几列
            _key: "_".concat(index / _this.column, "_").concat(index, "_").concat(_this.column),
            value: [cur]
          });
        } else {
          init[init.length - 1].value.push(cur);
        }

        return init;
      }, []);
    },
    anchorPoint: function anchorPoint() {
      return this.positions.length ? this.positions[this.start] : null;
    },
    visibleCount: function visibleCount() {
      return Math.ceil(this.screenHeight / this.estimatedItemSize);
    },
    aboveCount: function aboveCount() {
      return Math.min(this.start, this.bufferScale * this.visibleCount);
    },
    belowCount: function belowCount() {
      return Math.min(this.listData.length - this.end, this.bufferScale * this.visibleCount);
    },
    visibleData: function visibleData() {
      var start = this.start - this.aboveCount;
      var end = this.end + this.belowCount;
      return this._listData.slice(start, end);
    }
  },
  watch: {// scrolling(cur,pre){
    //   //滚动结束
    //   if(!cur && pre){
    //   }
    // }
  },
  created: function created() {
    this.initPositions();
    this.setScrollState(false); // window.vm = this;
  },
  mounted: function mounted() {
    this.screenHeight = this.$el.clientHeight;
    this.start = 0;
    this.end = this.start + this.visibleCount;
    this.setStartOffset(); // 添加拖拽事件

    if (this.topLoadMore) {
      this.$refs.list.addEventListener('touchstart', this.touchStartEvent);
      this.$refs.list.addEventListener('touchmove', this.touchMoveEvent);
      this.$refs.list.addEventListener('touchend', this.touchEndEvent);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.topLoadMore) {
      this.$refs.list.removeEventListener('touchstart', this.touchStartEvent);
      this.$refs.list.removeEventListener('touchmove', this.touchMoveEvent);
      this.$refs.list.removeEventListener('touchend', this.touchEndEvent);
    }
  },
  updated: function updated() {
    if (this.dargState !== 'none') {
      return;
    } // 列表数据长度不等于缓存长度


    if (this._listData.length !== this.positions.length) {
      this.initPositions();
    }

    this.$nextTick(function () {
      if (!this.$refs.items || !this.$refs.items.length) {
        return;
      } // 获取真实元素大小，修改对应的尺寸缓存


      this.updateItemsSize(); // 更新列表总高度

      var height = this.positions[this.positions.length - 1].bottom;
      this.$refs.phantom.style.height = height + 'px'; // 更新真实偏移量

      this.setStartOffset();
    });
  },
  methods: {
    // 设定滚动状态
    setScrollState: function setScrollState() {
      var flg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.scrolling = flg;
    },
    // 防抖处理，设置滚动状态
    // scrollEnd:_.debounce(function(event,data){
    //   this.setScrollState(false)
    //   this.onScrollEnd && this.onScrollEnd(event,data);
    // },100),
    scrollingEvent: function scrollingEvent(event, data) {
      this.onScroll && this.onScroll(event, data);
    },
    // 初始化缓存
    initPositions: function initPositions() {
      var _this2 = this;

      this.positions = this._listData.map(function (d, index) {
        return {
          index: index,
          height: _this2.estimatedItemSize,
          top: index * _this2.estimatedItemSize,
          bottom: (index + 1) * _this2.estimatedItemSize
        };
      });
    },
    // 获取列表起始索引
    getStartIndex: function getStartIndex() {
      var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // 二分法查找
      return this.binarySearch(this.positions, scrollTop);
    },
    // 二分法查找
    binarySearch: function binarySearch(list, value) {
      var start = 0;
      var end = list.length - 1;
      var tempIndex = null;

      while (start <= end) {
        var midIndex = parseInt((start + end) / 2);
        var midValue = list[midIndex].bottom;

        if (midValue === value) {
          return midIndex + 1;
        } else if (midValue < value) {
          start = midIndex + 1;
        } else if (midValue > value) {
          if (tempIndex === null || tempIndex > midIndex) {
            tempIndex = midIndex;
          }

          end = end - 1;
        }
      }

      return tempIndex;
    },
    // 获取列表项的当前尺寸
    updateItemsSize: function updateItemsSize() {
      var _this3 = this;

      var nodes = this.$refs.items;
      nodes.forEach(function (node) {
        var rect = node.getBoundingClientRect();
        var height = rect.height;
        var index = +node.id.replace(/^_(\d+).*/, '$1');
        var oldHeight = _this3.positions[index].height;
        var dValue = oldHeight - height; // 存在差值

        if (dValue) {
          _this3.positions[index].bottom = _this3.positions[index].bottom - dValue;
          _this3.positions[index].height = height;
          _this3.positions[index].over = true; // TODO

          for (var k = index + 1; k < _this3.positions.length; k++) {
            _this3.positions[k].top = _this3.positions[k - 1].bottom;
            _this3.positions[k].bottom = _this3.positions[k].bottom - dValue;
          }
        }
      });
    },
    // 更新偏移量
    setStartOffset: function setStartOffset() {
      var startOffset;

      if (this.start >= 1) {
        var size = this.positions[this.start].top - (this.positions[this.start - this.aboveCount] ? this.positions[this.start - this.aboveCount].top : 0);
        startOffset = this.positions[this.start - 1].bottom - size;
      } else {
        startOffset = 0;
      }

      this.startOffset = startOffset;
      this.$refs.content.style.transform = "translate3d(0,".concat(startOffset, "px,0)");
    },
    // 滚动事件
    scrollEvent: function scrollEvent(event) {
      // 当前滚动位置
      var scrollTop = this.$refs.list.scrollTop; // 更新滚动状态

      this.setScrollState(true); // 排除不需要计算的情况

      if (scrollTop > this.anchorPoint.bottom || scrollTop < this.anchorPoint.top) {
        // 此时的开始索引
        this.start = this.getStartIndex(scrollTop); // 此时的结束索引

        this.end = this.start + this.visibleCount; // 更新偏移量

        this.setStartOffset();
      } // 触发外部滚动事件


      this.scrollingEvent(event, {
        start: this.start * this.column,
        end: Math.min(this.end * this.column, this.listData.length - 1),
        startOffset: this.startOffset,
        scrollTop: scrollTop
      }); // //防抖处理滚动结束
      // this.scrollEnd(event,{
      //     start:this.start * this.column,
      //     end:Math.min(this.end * this.column,this.listData.length - 1),
      //     startOffset:this.startOffset,
      //     scrollTop
      //   }
      // );
    },
    // Start
    touchStartEvent: function touchStartEvent(event) {
      if (!this.topLoadMore) {
        return;
      } // 记录当前起始Y坐标


      this._startPos = event.touches[0].pageY;
      this._prevPos = event.touches[0].pageY;
    },
    // Move
    touchMoveEvent: function touchMoveEvent(event) {
      var _this4 = this;

      if (!this.topLoadMore) {
        return;
      } // 暂时这样处理 loading 中不可滚动


      if (this.dargState === 'loading') {
        event.preventDefault();
        return;
      } // 当前Y坐标


      var curPos = event.touches[0].pageY; // 下拉 且 不在顶部

      if (curPos > this._prevPos && this.$refs.list.scrollTop !== 0) {
        return;
      } // 下拉 且 在顶部


      if (curPos > this._prevPos && this.$refs.list.scrollTop === 0) {
        // event.preventDefault();
        this.touchDistance = Math.max(this.touchDistance + curPos - this._prevPos, 0);
        var distance = ~~(this.touchDistance / this.distanceScale); // 未达到阈值

        if (distance < this.topDistance) {
          this.dargState = 'pull';
          this.$emit('top-status-change', this.dargState, distance);
        } // 已达到阈值


        if (distance >= this.topDistance) {
          this.dargState = 'drop';
          this.$emit('top-status-change', this.dargState, distance);
        } // 设定偏移距离


        if (distance <= this.maxDistance || !this.maxDistance) {
          var d = this.maxDistance ? Math.min(distance, this.maxDistance) : distance;
          setTimeout(function () {
            _this4.$refs.content.style.transform = "translate3d(0,".concat(d, "px,0)");
            _this4.$refs.top.style.height = "".concat(d, "px");
          }, 0);
        }
      } // 上划 且 没有拖拽距离


      if (curPos < this._prevPos && !this.touchDistance) {
        return;
      } // 上划 且 有拖拽距离


      if (curPos < this._prevPos && this.touchDistance) {
        this.touchDistance = Math.max(this.touchDistance + curPos - this._prevPos, 0);

        var _distance = ~~(this.touchDistance / this.distanceScale); // 未达到阈值


        if (_distance < this.topDistance) {
          this.dargState = 'pull';
          this.$emit('top-status-change', this.dargState, _distance);
        } // 已达到阈值


        if (_distance >= this.topDistance) {
          this.dargState = 'drop';
          this.$emit('top-status-change', this.dargState, _distance);
        } // 设定偏移距离


        if (_distance <= this.maxDistance || !this.maxDistance) {
          var _d = this.maxDistance ? Math.min(_distance, this.maxDistance) : _distance;

          setTimeout(function () {
            _this4.$refs.content.style.transform = "translate3d(0,".concat(_d, "px,0)");
            _this4.$refs.top.style.height = "".concat(_d, "px");
          }, 0);
        }

        event.preventDefault();
      }

      this._prevPos = curPos;
    },
    // End
    touchEndEvent: function touchEndEvent() {
      var _this5 = this;

      if (!this.topLoadMore) {
        return;
      }

      if (this.dargState !== 'pull' && this.dargState !== 'drop') {
        return;
      }

      if (this.dargState === 'pull') {
        setTimeout(function () {
          _this5.dargState = 'none';
        }, 300);
        this.touchDistance = 0;
      }

      if (this.dargState === 'drop') {
        setTimeout(function () {
          _this5.dargState = 'loading';
        }, 300); // 将距离变更为阈值点 - 20

        this.touchDistance = (this.topDistance - 20) * this.distanceScale;
        this.topMethod && this.topMethod();
      }

      this.$emit('top-status-change', this.dargState, ~~(this.touchDistance / this.distanceScale));
      this.$refs.content.style.transition = "transform 0.3s";
      this.$refs.content.style.transform = "translate3d(0,".concat(~~(this.touchDistance / this.distanceScale), "px,0)");
      this.$refs.top.style.transition = "height 0.3s";
      this.$refs.top.style.height = "".concat(~~(this.touchDistance / this.distanceScale), "px");
      setTimeout(function () {
        _this5.$refs.content.style.transition = "";
        _this5.$refs.top.style.transition = "";
      }, 350);
    },
    onBottomLoaded: function onBottomLoaded() {
      var _this6 = this;

      this.touchDistance = 0;
      this.$emit('top-status-change', this.dargState, ~~(this.touchDistance / this.distanceScale));
      this.$refs.content.style.transition = "transform 0.2s";
      this.$refs.content.style.transform = "translate3d(0,".concat(~~(this.touchDistance / this.distanceScale), "px,0)");
      this.$refs.top.style.transition = "height 0.2s";
      this.$refs.top.style.height = "0px";
      this.dargState = 'none';
      setTimeout(function () {
        _this6.$refs.content.style.transition = "";
        _this6.$refs.top.style.transition = "";
      }, 250);
    }
  }
};

var css_248z$k = ".infinite-top-content{height:100%;-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center}.infinite-top-content,.infinite-top-content-icon{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-align:center;-webkit-align-items:center;align-items:center}.infinite-top-content-icon{-webkit-transition:-webkit-transform .2s;transition:-webkit-transform .2s;transition:transform .2s;transition:transform .2s, -webkit-transform .2s;transition:transform .2s,-webkit-transform .2s}.icon-arrow{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.icon-arrow.icon-reverse{-webkit-transform:rotate(1turn);transform:rotate(1turn)}.icon-revolve{-webkit-animation:revolve 1.2s linear infinite;animation:revolve 1.2s linear infinite}@-webkit-keyframes revolve{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes revolve{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.infinite-top-content-title{font-size:14px}.infinite-top-container{-webkit-transform:translateZ(0);transform:translateZ(0);position:relative;z-index:2}.infinite-list-container{overflow-x:hidden;width:100%;overflow-y:auto;position:relative;-webkit-overflow-scrolling:touch}.infinite-list-phantom{z-index:-1}.infinite-list,.infinite-list-phantom{position:absolute;left:0;top:0;right:0}.infinite-list{z-index:1}.infinite-list-item-container{display:-webkit-box;display:-webkit-flex;display:flex}.infinite-item{-webkit-box-flex:1;-webkit-flex:1;flex:1}";
styleInject(css_248z$k);

/* script */
const __vue_script__$D = script$D;
/* template */
var __vue_render__$A = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { ref: "parent" }, [
    _c(
      "div",
      {
        ref: "list",
        staticClass: "infinite-list-container",
        style: { height: _vm.height },
        on: {
          scroll: function($event) {
            return _vm.scrollEvent($event)
          }
        }
      },
      [
        _c("div", { ref: "phantom", staticClass: "infinite-list-phantom" }),
        _vm._v(" "),
        _vm.topLoadMore
          ? _c(
              "div",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.dargState !== "none" && _vm.touchDistance >= 20,
                    expression: "dargState !== 'none' && touchDistance >= 20"
                  }
                ],
                ref: "top",
                staticClass: "infinite-top-container"
              },
              [
                _vm._t(
                  "top",
                  [
                    _c(
                      "div",
                      {
                        staticClass: "infinite-top-content",
                        style: { color: _vm.topTextColor }
                      },
                      [
                        _vm.dargState === "pull" || _vm.dargState === "drop"
                          ? _c(
                              "span",
                              {
                                staticClass:
                                  "infinite-top-content-icon icon-arrow",
                                class:
                                  _vm.dargState === "drop" ? "icon-reverse" : ""
                              },
                              [
                                _c(
                                  "svg",
                                  {
                                    staticClass: "icon",
                                    attrs: {
                                      t: "1572934878285",
                                      viewBox: "0 0 1024 1024",
                                      version: "1.1",
                                      xmlns: "http://www.w3.org/2000/svg",
                                      "p-id": "4245",
                                      width: "24",
                                      height: "24"
                                    }
                                  },
                                  [
                                    _c("path", {
                                      attrs: {
                                        d:
                                          "M548.352 241.152L716.8 409.6a32.768 32.768 0 0 1 0 46.592 30.72 30.72 0 0 1-45.568 0l-116.736-115.2v464.896a32.768 32.768 0 1 1-65.024 0V340.992L372.736 460.8a39.424 39.424 0 0 1-45.568-6.656 32.768 32.768 0 0 1 0-46.592l162.816-166.4a35.328 35.328 0 0 1 58.368 0z",
                                        fill: _vm.topTextColor,
                                        "p-id": "4246"
                                      }
                                    })
                                  ]
                                )
                              ]
                            )
                          : _vm._e(),
                        _vm._v(" "),
                        _vm.dargState === "loading"
                          ? _c(
                              "span",
                              {
                                staticClass:
                                  "infinite-top-content-icon icon-revolve"
                              },
                              [
                                _c(
                                  "svg",
                                  {
                                    staticClass: "icon",
                                    attrs: {
                                      t: "1572936012117",
                                      viewBox: "0 0 1024 1024",
                                      version: "1.1",
                                      xmlns: "http://www.w3.org/2000/svg",
                                      "p-id": "9195",
                                      width: "32",
                                      height: "32"
                                    }
                                  },
                                  [
                                    _c("path", {
                                      attrs: {
                                        d:
                                          "M527.36 225.28h-30.72c-8.192 0-15.36 7.168-15.36 15.36v133.12c0 8.192 7.168 15.36 15.36 15.36h30.72c8.192 0 15.36-7.168 15.36-15.36v-133.12c0-8.192-7.168-15.36-15.36-15.36z m256 256h-133.12c-8.192 0-15.36 7.168-15.36 15.36v30.72c0 8.192 7.168 15.36 15.36 15.36h133.12c8.192 0 15.36-7.168 15.36-15.36v-30.72c0-8.192-7.168-15.36-15.36-15.36z m-256 153.6h-30.72c-8.192 0-15.36 7.168-15.36 15.36v133.12c0 8.192 7.168 15.36 15.36 15.36h30.72c8.192 0 15.36-7.168 15.36-15.36v-133.12c0-8.192-7.168-15.36-15.36-15.36zM389.12 527.36v-30.72c0-8.192-7.168-15.36-15.36-15.36h-133.12c-8.192 0-15.36 7.168-15.36 15.36v30.72c0 8.192 7.168 15.36 15.36 15.36h133.12c8.192 0 15.36-7.168 15.36-15.36z m220.16-91.136c6.144 6.144 15.36 6.144 21.504 0l94.208-94.208c6.144-6.144 6.144-15.36 0-21.504l-21.504-21.504c-6.144-6.144-15.36-6.144-21.504 0l-94.208 94.208c-6.144 6.144-6.144 15.36 0 21.504l21.504 21.504z m22.528 151.552c-6.144-6.144-15.36-6.144-21.504 0l-21.504 21.504c-6.144 6.144-6.144 15.36 0 21.504l94.208 94.208c6.144 6.144 15.36 6.144 21.504 0l21.504-21.504c6.144-6.144 6.144-15.36 0-21.504l-94.208-94.208z m-217.088 0c-6.144-6.144-15.36-6.144-21.504 0l-94.208 94.208c-6.144 6.144-6.144 15.36 0 21.504l21.504 21.504c6.144 6.144 15.36 6.144 21.504 0l94.208-94.208c6.144-6.144 6.144-15.36 0-21.504l-21.504-21.504z m-72.704-289.792c-6.144-6.144-15.36-6.144-21.504 0l-21.504 21.504c-6.144 6.144-6.144 15.36 0 21.504l94.208 94.208c6.144 6.144 15.36 6.144 21.504 0l21.504-21.504c6.144-6.144 6.144-15.36 0-21.504l-94.208-94.208z",
                                        fill: _vm.topTextColor,
                                        "p-id": "9196"
                                      }
                                    })
                                  ]
                                )
                              ]
                            )
                          : _vm._e(),
                        _vm._v(" "),
                        _c(
                          "span",
                          { staticClass: "infinite-top-content-title" },
                          [
                            _vm.dargState === "pull"
                              ? [
                                  _vm._v(
                                    "\n            " +
                                      _vm._s(_vm.topPullText) +
                                      "\n          "
                                  )
                                ]
                              : _vm._e(),
                            _vm._v(" "),
                            _vm.dargState === "drop"
                              ? [
                                  _vm._v(
                                    "\n             " +
                                      _vm._s(_vm.topDropText) +
                                      "\n          "
                                  )
                                ]
                              : _vm._e(),
                            _vm._v(" "),
                            _vm.dargState === "loading"
                              ? [
                                  _vm._v(
                                    "\n            " +
                                      _vm._s(_vm.topLoadingText) +
                                      "\n          "
                                  )
                                ]
                              : _vm._e()
                          ],
                          2
                        )
                      ]
                    )
                  ],
                  { dargState: _vm.dargState, dargDistance: _vm.touchDistance }
                )
              ],
              2
            )
          : _vm._e(),
        _vm._v(" "),
        _c(
          "div",
          { ref: "content", staticClass: "infinite-list" },
          _vm._l(_vm.visibleData, function(row, row_index) {
            return _c(
              "div",
              {
                key: row._key,
                ref: "items",
                refInFor: true,
                staticClass: "infinite-list-item-container",
                attrs: { id: row._key }
              },
              [
                _vm._l(row.value, function(item, col_index) {
                  return [
                    _c(
                      "div",
                      {
                        key: row._key + "-" + col_index,
                        staticClass: "infinite-item"
                      },
                      [
                        _vm._t("default", null, {
                          item: item,
                          row: row_index,
                          col: col_index
                        })
                      ],
                      2
                    )
                  ]
                }),
                _vm._v(" "),
                row.value.length < _vm.column
                  ? _vm._l(
                      _vm.column - (row.value.length % _vm.column),
                      function(item, index) {
                        return _c("div", {
                          key: "empty-" + index,
                          staticClass: "infinite-item"
                        })
                      }
                    )
                  : _vm._e()
              ],
              2
            )
          }),
          0
        )
      ]
    )
  ])
};
var __vue_staticRenderFns__$A = [];
__vue_render__$A._withStripped = true;

  /* style */
  const __vue_inject_styles__$D = undefined;
  /* scoped */
  const __vue_scope_id__$D = undefined;
  /* module identifier */
  const __vue_module_identifier__$D = undefined;
  /* functional template */
  const __vue_is_functional_template__$D = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$D = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$A, staticRenderFns: __vue_staticRenderFns__$A },
    __vue_inject_styles__$D,
    __vue_script__$D,
    __vue_scope_id__$D,
    __vue_is_functional_template__$D,
    __vue_module_identifier__$D,
    false,
    undefined,
    undefined,
    undefined
  );

__vue_component__$D.install = function (Vue, Maple) {
  Vue.component(__vue_component__$D.name, __vue_component__$D);
};

var components$1 = {
  Alert: __vue_component__$1,
  Backtop: __vue_component__$2,
  Popup: __vue_component__,
  Actions: __vue_component__$3,
  Confirm: __vue_component__$4,
  Notice: __vue_component__$5,
  Affix: __vue_component__$6,
  Captcha: __vue_component__$7,
  Collapse: __vue_component__$8,
  CollapseItem: __vue_component__$9,
  Countdown: __vue_component__$a,
  Checkbox: __vue_component__$g,
  CheckboxGroup: __vue_component__$h,
  Input: __vue_component__$c,
  Number: __vue_component__$f,
  Radio: __vue_component__$i,
  RadioGroup: __vue_component__$j,
  Select: __vue_component__$e,
  Textarea: __vue_component__$b,
  Form: __vue_component__$k,
  FormItem: __vue_component__$m,
  // form
  Picker: __vue_component__$d,
  Img: __vue_component__$p,
  Slider: __vue_component__$n,
  SliderItem: __vue_component__$o,
  List: __vue_component__$q,
  ListItem: __vue_component__$r,
  ListGroup: __vue_component__$s,
  Progress: __vue_component__$t,
  DatePicker: __vue_component__$u,
  Mask: __vue_component__$v,
  Slidebar: __vue_component__$w,
  Scroll: __vue_component__$x,
  ScrollItem: __vue_component__$y,
  Swiper: __vue_component__$z,
  Tabbar: __vue_component__$B,
  TabbarItem: __vue_component__$C,
  VirtualList: __vue_component__$D
};

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$E = {
  name: 'cmuiScreen',
  props: {
    top: {
      type: String,
      default: '0px'
    },
    color: {
      type: String,
      default: 'blue'
    }
  },
  data: function data() {
    return {
      children: [],
      navMinHeight: '0',
      actived: false,
      index: null
    };
  },
  provide: function provide() {
    return {
      cmuiScreen: this
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      _this.navMinHeight = _this.$refs.nav.offsetHeight + 'px';
    });
  },
  methods: {
    titleEvent: function titleEvent(index) {
      this.active(index);
    },
    active: function active(index) {
      this.actived = true;
      this.index = index;
      this.children.forEach(function (item) {
        return item.cancel();
      });
      this.children[index].active();
    },
    cancel: function cancel() {
      this.actived = false;
      this.index = null;
    }
  }
};

var css_248z$l = ".cmui-screen{color:#666;background:#fff}.cmui-screen__nav{background-color:#fff;border-bottom:1px solid #ccc}.cmui-screen__nav.active{position:fixed;top:0}.cmui-screen_warp{background-color:#fff}.cmui-screen__title{padding:.266666rem;position:relative}.cmui-screen__title .cmui-screen__arrow{display:inline-block;border-top:7px solid #b7b7b7;border-left:5px solid transparent;border-right:5px solid transparent;border-bottom:0;margin-left:6px}.cmui-screen__title.active .cmui-screen__arrow{border-top:0;border-bottom:7px solid transparent;-webkit-transform:translateY(-50%);transform:translateY(-50%)}";
styleInject(css_248z$l);

/* script */
const __vue_script__$E = script$E;
/* template */
var __vue_render__$B = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "cmui-screen",
      class: { active: _vm.actived },
      style: { minHeight: _vm.navMinHeight }
    },
    [
      _vm.actived
        ? _c("div", {
            staticClass: "mask",
            staticStyle: { "z-index": "auto" },
            on: {
              click: function($event) {
                return _vm.cancel()
              }
            }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        {
          ref: "nav",
          staticClass: "flex-container cmui-screen__nav",
          class: { "fixed-top": _vm.actived },
          style: { top: _vm.top }
        },
        [
          _vm._l(_vm.children, function(child, i) {
            return _c(
              "div",
              {
                key: i,
                staticClass: "cmui-screen__title",
                class: { active: i === _vm.index },
                style: { color: i === _vm.index ? _vm.color : undefined },
                on: {
                  click: function($event) {
                    return _vm.titleEvent(i)
                  }
                }
              },
              [
                _vm._v(
                  "\n            " + _vm._s(child.title) + "\n            "
                ),
                _c("span", {
                  staticClass: "cmui-screen__arrow",
                  style: {
                    borderBottomColor: i === _vm.index ? _vm.color : undefined
                  }
                })
              ]
            )
          }),
          _vm._v(" "),
          _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.actived,
                  expression: "actived"
                }
              ],
              staticClass: "abs-top cmui-screen_warp",
              style: { top: _vm.navMinHeight }
            },
            [_vm._t("default")],
            2
          )
        ],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$B = [];
__vue_render__$B._withStripped = true;

  /* style */
  const __vue_inject_styles__$E = undefined;
  /* scoped */
  const __vue_scope_id__$E = undefined;
  /* module identifier */
  const __vue_module_identifier__$E = undefined;
  /* functional template */
  const __vue_is_functional_template__$E = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$E = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$B, staticRenderFns: __vue_staticRenderFns__$B },
    __vue_inject_styles__$E,
    __vue_script__$E,
    __vue_scope_id__$E,
    __vue_is_functional_template__$E,
    __vue_module_identifier__$E,
    false,
    undefined,
    undefined,
    undefined
  );

//
var script$F = {
  name: 'cmuiScreenItem',
  props: {
    title: {
      type: String,
      default: ''
    }
  },
  data: function data() {
    var _this = this;

    return {
      check: function check() {
        if (!_this.cmuiScreen) {
          throw new Error('请将cmui-screen-item放置在cmui-screen标签中');
        }
      },
      actived: false
    };
  },
  inject: ['cmuiScreen'],
  created: function created() {
    this.check();
    this.cmuiScreen.children.push(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.check();

    _$1.remove(this.cmuiScreen.children, this);
  },
  methods: {
    active: function active() {
      this.actived = true;
    },
    cancel: function cancel() {
      this.actived = false;
    }
  }
};

/* script */
const __vue_script__$F = script$F;

/* template */
var __vue_render__$C = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      directives: [
        {
          name: "show",
          rawName: "v-show",
          value: _vm.actived,
          expression: "actived"
        }
      ],
      staticClass: "cmui-screen-item"
    },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$C = [];
__vue_render__$C._withStripped = true;

  /* style */
  const __vue_inject_styles__$F = undefined;
  /* scoped */
  const __vue_scope_id__$F = undefined;
  /* module identifier */
  const __vue_module_identifier__$F = undefined;
  /* functional template */
  const __vue_is_functional_template__$F = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$F = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$C, staticRenderFns: __vue_staticRenderFns__$C },
    __vue_inject_styles__$F,
    __vue_script__$F,
    __vue_scope_id__$F,
    __vue_is_functional_template__$F,
    __vue_module_identifier__$F,
    false,
    undefined,
    undefined,
    undefined
  );

function scrollEvent() {// if (this.$refs.classify.getBoundingClientRect().top === this.top) {
  //   this.active = true
  // }
}

var script$G = {
  name: 'cmui-classify',
  props: {
    position: {
      type: String,
      default: 'left'
    },
    top: {
      type: Number,
      default: 0
    },
    animate: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      items: [],
      active: false,
      index: 0,
      stopScrollEvent: false
    };
  },
  computed: {
    isV: function isV() {
      return !(this.position === 'top' || this.position === 'bottom');
    },
    contentClass: function contentClass() {
      if (this.isV) {
        return ['flex1', this.active ? 'scroll-container-y' : 'overflow-h'];
      } else {
        return '';
      }
    },
    contentStyle: function contentStyle() {
      if (this.isV) {
        return {
          height: '100%'
        };
      } else {
        return {};
      }
    },
    tabStyle: function tabStyle() {
      if (this.isV) {
        return {
          height: '100%'
        };
      } else {
        return {};
      }
    }
  },
  mounted: function mounted() {
    this.setTitle();
    document.addEventListener('scroll', scrollEvent.bind(this));
  },
  destroyed: function destroyed() {
    document.removeEventListener('scroll', scrollEvent.bind(this));
  },
  updated: function updated() {
    this.setTitle();
  },
  methods: {
    setTitle: function setTitle() {
      var _this2 = this;

      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.$slots.default) {
        var items = _$1.filter(this.$slots.default, function (vnode) {
          return _$1.get(vnode, 'componentOptions.Ctor.options.name') === 'cmui-classify-item';
        }).map(function (_ref) {
          var componentInstance = _ref.componentInstance;
          return componentInstance;
        });

        var changed = !(items.length === this.items.length && items.every(function (pane, index) {
          return pane === _this2.items[index];
        }));

        if (force || changed) {
          this.items = items;
        }
      } else {
        this.items = [];
      }
    }
  },
  render: function render(h) {
    var _this3 = this;

    var _this = this;

    var renderItem = function renderItem(item, index) {
      return h('div', {
        class: ['cmui-classify__tabItem', {
          active: _this3.index === index
        }],
        on: {
          click: function click() {
            _this.index = index;
            var targetContent = _this.$refs.content.childNodes[index];
            _this.stopScrollEvent = true;
            scrollBar(_this.$refs.content, 'top', targetContent.offsetTop, _this.animate, function () {
              _this.stopScrollEvent = false;
            });
          }
        }
      }, item.$slots.title || [h('div', {}, item.$attrs.title)]);
    };

    var tab = h('div', {
      class: ['cmui-classify__tab', this.isV ? 'scroll-container-y' : 'scroll-container'],
      style: this.tabStyle
    }, this.items.map(renderItem));
    var content = h('div', {
      class: ['cmui-classify__content pos-r', this.contentClass],
      ref: 'content',
      on: {
        scroll: _$1.throttle(function () {
          if (_this.stopScrollEvent) return;

          if (_this.$refs.content.scrollTop === 0) {
            _this.active = false;
          }

          var contentTop = _this.$refs.content.getBoundingClientRect().top;

          _this.index = _$1.findIndex(_this.$refs.content.childNodes, function (item) {
            return item.getBoundingClientRect().top > contentTop;
          }) - 1;
        }, {
          wait: 200
        })
      },
      style: this.contentStyle
    }, this.$slots.default);
    return h('div', {
      class: ['cmui-classify', this.isV ? 'flex-container top' : ''],
      ref: 'classify',
      style: {
        height: '100vh'
      }
    }, [tab, content]);
  },
  provide: function provide() {
    return {
      cmuiClassify: this
    };
  }
};

var css_248z$m = ".cmui-classify{background-color:#fff}.cmui-classify__tab{border-right:1px solid #ccc}.cmui-classify__tabItem{padding:20px;border-bottom:1px solid #ccc}.cmui-classify__tabItem.active{color:red}.cmui-classify-item{border-bottom:1px solid #ccc}";
styleInject(css_248z$m);

/* script */
const __vue_script__$G = script$G;
/* template */

  /* style */
  const __vue_inject_styles__$G = undefined;
  /* scoped */
  const __vue_scope_id__$G = undefined;
  /* module identifier */
  const __vue_module_identifier__$G = undefined;
  /* functional template */
  const __vue_is_functional_template__$G = undefined;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$G = /*#__PURE__*/normalizeComponent(
    {},
    __vue_inject_styles__$G,
    __vue_script__$G,
    __vue_scope_id__$G,
    __vue_is_functional_template__$G,
    __vue_module_identifier__$G,
    false,
    undefined,
    undefined,
    undefined
  );

//
//
//
//
//
//
var script$H = {
  name: 'cmui-classify-item',
  inject: ['cmuiClassify']
};

/* script */
const __vue_script__$H = script$H;

/* template */
var __vue_render__$D = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { staticClass: "cmui-classify-item" },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$D = [];
__vue_render__$D._withStripped = true;

  /* style */
  const __vue_inject_styles__$H = undefined;
  /* scoped */
  const __vue_scope_id__$H = undefined;
  /* module identifier */
  const __vue_module_identifier__$H = undefined;
  /* functional template */
  const __vue_is_functional_template__$H = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$H = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$D, staticRenderFns: __vue_staticRenderFns__$D },
    __vue_inject_styles__$H,
    __vue_script__$H,
    __vue_scope_id__$H,
    __vue_is_functional_template__$H,
    __vue_module_identifier__$H,
    false,
    undefined,
    undefined,
    undefined
  );

var components$2 = [__vue_component__$E, __vue_component__$F, __vue_component__$G, __vue_component__$H].map(function (component) {
  component.install = function (Vue) {
    Vue.component(component.name, component);
  };

  return component;
});

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

// call something on iterator step with safe closing on error

var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$2 = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
};

var _createProperty = function (object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
  else object[index] = value;
};

var ITERATOR$3 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$3]
    || it['@@iterator']
    || _iterators[_classof(it)];
};

var ITERATOR$4 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$4]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$4]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR$4] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);
      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var alias = {
  androidchrome: 'androidChrome',
  webview: 'webView',
  minimalui: 'minimalUi',
  statusbar: 'statusBar',
  pixelratio: 'pixelRatio',
  wechat: 'weixin',
  wx: 'weixin'
};
var metaViewport = Array.from(document.getElementsByTagName('meta')).filter(function (item) {
  return item.getAttribute('name') === 'viewport' && item.getAttribute('content').indexOf('minimal-ui') >= 0;
}); // Classes

var classNames = [];
var htmlClass = document.documentElement.classList;

var device = function device() {
  var l = arguments.length;
  var i = 0;
  var t;
  var result = true;

  if (l === 0) {
    result = false;
  } else {
    for (; i < l; i++) {
      t = arguments[i];

      if (t in device && device.hasOwnProperty(t)) {
        result = result && device[t];
      } else {
        t = t.toLowerCase();

        if (t in alias) {
          result = result && device[alias[t]];
        } else {
          result = result && false;
        }
      }

      if (!result) {
        break;
      }
    }
  }

  return result;
};

var ua = navigator.userAgent;
var android = ua.match(/(Android);?[\s/]+([\d.]+)?/);
var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
device.ios = device.android = device.iphone = device.ipad = device.androidChrome = false; // Chrome

device.chrome = ua.toLowerCase().indexOf('chrome') >= 0; // Android

if (android) {
  device.os = 'android';
  device.osVersion = android[2];
  device.android = true;
  device.androidChrome = device.android && device.chrome;
}

if (ipad || iphone || ipod) {
  device.os = 'ios';
  device.ios = true;
} // iOS


if (iphone && !ipod) {
  device.osVersion = iphone[2].replace(/_/g, '.');
  device.iphone = true;
}

if (ipad) {
  device.osVersion = ipad[2].replace(/_/g, '.');
  device.ipad = true;
}

if (ipod) {
  device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
  device.iphone = true;
} // iOS 8+ changed UA


if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
  if (device.osVersion.split('.')[0] === '10') {
    device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
  }
} // Webview


device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i); // Minimal UI

if (device.os && device.os === 'ios') {
  var osVersionArr = device.osVersion.split('.');
  device.minimalUi = !device.webView && (ipod || iphone) && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) && metaViewport.length > 0;
} // Check for status bar and fullscreen app mode


var windowWidth = window.innerWidth;
var windowHeight$1 = window.innerHeight;
device.statusBar = device.webView && windowWidth * windowHeight$1 === screen.width * screen.height; // Pixel Ratio

device.pixelRatio = window.devicePixelRatio || 1;
classNames.push('pixel-ratio-' + Math.floor(device.pixelRatio));

if (device.pixelRatio >= 2) {
  classNames.push('retina');
} // OS classes


if (device.os) {
  classNames.push(device.os, device.os + '-' + device.osVersion.split('.')[0], device.os + '-' + device.osVersion.replace(/\./g, '-'));

  if (device.os === 'ios') {
    var major = parseInt(device.osVersion.split('.')[0], 10);

    for (var i$1 = major - 1; i$1 >= 6; i$1--) {
      classNames.push('ios-gt-' + i$1);
    }
  }
} // Status bar classes


if (device.statusBar) {
  classNames.push('with-statusbar-overlay');
} else {
  htmlClass.remove('with-statusbar-overlay');
} // keng..


device.weixin = /MicroMessenger/i.test(ua); // UC �����

device.uc = ua.indexOf('UCBrowser') > -1; // Add html classes

for (var key$2 in device) {
  if (device[key$2]) {
    classNames.push("device_".concat(key$2));
  }
}

htmlClass.add.apply(htmlClass, classNames);

function BaseLoad(src, tagName) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return !src ? Promise.resolve(null) : new Promise(function (resolve, reject) {
    var dom = document.createElement(tagName);
    dom.src = src;

    (function loop(props, target) {
      _$1.forEach(props, function (value, key) {
        _$1.isObject(value) ? loop(value, target[key]) : target[key] = value;
      });
    })(props, dom);

    dom.onload = function () {
      setTimeout(function () {
        resolve(dom);
      });
    };

    dom.onError = function () {
      reject(new Error(''));
    };

    document.body.appendChild(dom);
  });
}

function load(type, url) {
  if (_$1.isObject(type)) {
    var _type = type;
    type = _type.type;
    url = _type.url;
  }

  switch (type) {
    case 'js':
    case 'javascript':
      return BaseLoad(url, 'javascript', {
        type: 'text/javascript'
      });

    case 'css':
      return BaseLoad(url, 'link', {
        ref: 'stylesheet'
      });

    case 'img':
    case 'image':
      return BaseLoad(url, 'img', {
        style: {
          display: 'none'
        }
      });

    case 'iframe':
      return BaseLoad(url, 'iframe', {
        style: {
          display: 'none'
        }
      });

    default:
      return Promise.resolve(null);
  }
}

var eventName = function () {
  if ('DeviceMotionEvent' in window) {
    return 'devicemotion';
  } else if ('DeviceOrientationEvent' in window) {
    return 'deviceorientation';
  } else {
    return false;
  }
}();

var ShakeHandle = /*#__PURE__*/function () {
  function ShakeHandle(options) {
    _classCallCheck(this, ShakeHandle);

    this.handleList = _$1.filter(options, _$1.isFunction);

    this.handle = function (e) {
      var acceleration = e.acceleration || e.accelerationIncludingGravity;
      var x;
      var y;
      var z;

      if (acceleration) {
        x = acceleration.x;
        y = acceleration.y;
        z = acceleration.z;

        if ([x, y, z].some(function (item) {
          return Math.abs(item) > 15;
        })) {
          clearTimeout(options.timer);

          if (options.continueEvent) {
            options.startFn();
          } else if (options.hasRun === false) {
            options.startFn();
            options.hasRun = true;
          }

          options.timer = setTimeout(function () {
            options.endFn();

            if (!options.continueEvent) {
              options.hasRun = false;
            }
          }, 500);
        }
      }
    };

    if (eventName) {
      window.addEventListener(eventName, this.handle, false);
    }
  }

  _createClass(ShakeHandle, [{
    key: "cancel",
    value: function cancel() {
      window.removeEventListener(eventName, this.handle);
    }
  }]);

  return ShakeHandle;
}();

function shake() {
  var options = {
    startFn: _$1.filter(arguments, _$1.isFunction)[0] || function () {},
    endFn: _$1.filter(arguments, _$1.isFunction)[1] || function () {},
    interval: _$1.filter(arguments, _$1.isNumber)[0] || 0,
    // 每次触发startFn的时间间隔
    continueEvent: _$1.filter(arguments, _$1.isBoolean)[0] || true // 摇动过程中是否持续执行startFn事件

  };

  _$1.assign(options, _$1.find(arguments, _$1.isPlainObject));

  if (!options.continueEvent) {
    options.hasRun = false;
  } else if (options.interval > 16) {
    // 针对16毫秒的时差做兼容
    options.startFn = _$1.throttle(options.startFn, options.interval, {
      trailing: false
    });
  }

  return new ShakeHandle(options);
}

var cmuiStyle;
var cssRules;
var cssRulesLen;
ready(function () {
  cmuiStyle = document.createElement('style');
  document.head.appendChild(cmuiStyle);
  cssRules = _$1.get(cmuiStyle, 'sheet.cssRules');
  cssRulesLen = cssRules.length;
});

function style() {
  if (arguments.length) {
    var argStringList = _$1.filter(arguments, _$1.isString);

    var selector = _$1.get(argStringList, 0);

    var name = _$1.camelCase(_$1.get(argStringList, 1)) || undefined;

    var value = _$1.get(argStringList, 2);

    value = _$1.find(arguments, _$1.isPlainObject) || value;

    if (selector && name && value) {
      // 设置样式
      if (_$1.isString(value)) {
        var matchRule = _$1.findLast(cssRules, function (item) {
          return _$1.get(item, 'selectorText') === selector;
        });

        if (matchRule) {
          matchRule.style[name] = value;
        } else {
          cmuiStyle.sheet.insertRule(selector + '{}', cssRulesLen);
          cmuiStyle.sheet.cssRules[cssRulesLen++].style[name] = value;
        }
      }
    } else if (selector && name) {
      if (value === undefined) {
        // 读取样式
        var t = _$1.findLast(cssRules, function (item) {
          return _$1.get(item, 'selectorText') === selector;
        });

        return _$1.get(t, "style[".concat(name, "]"));
      } else {
        // 删除选择器下的具体样式
        var _t = _$1.findLast(cssRules, function (item) {
          return _$1.get(item, 'selectorText') === selector;
        });

        _t = _$1.get(_t, 'style');
        delete _t[name];
      }
    } else if (selector && _$1.isPlainObject(value)) {
      _$1.forEach(value, function (value, key) {
        style(selector, key, value);
      });
    } else if (selector) {
      // 读取样式
      if (name === '' || value === '') ; else {
        var tempStyle = _$1.findLast(cssRules, function (item) {
          return _$1.get(item, 'selectorText') === selector;
        });

        tempStyle = _$1.get(tempStyle, 'style');

        var arr = _$1.filter(tempStyle, function (item) {
          return item;
        });

        return _$1.pick(tempStyle, arr);
      }
    }
  }

  return cmuiStyle;
}

// let time = require('dayjs');

// 7.2.9 SameValue(x, y)
var _sameValue = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

// @@search logic
_fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = _regexpExecAbstract(rx, S);
      if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

function Url(url) {
  return new Url.prototype.Init(url);
}

Url.prototype.Init = function (url) {
  var a = document.createElement('a');
  a.href = url || location.href;
  this.source = url || location.href;
  this.protocol = a.protocol.replace(':', '');
  this.host = a.hostname;
  this.port = a.port;
  this.query = a.search;

  this.params = function () {
    var ret = {};
    var seg = a.search.replace(/^\?/, '').split('&');
    var len = seg.length;
    var i = 0;
    var s;

    for (; i < len; i++) {
      if (!seg[i]) {
        continue;
      }

      s = seg[i].split('=');
      ret[s[0]] = s.slice(1).join('='); // 删除微信下的?10000skip

      if (ret[s[0]] && typeof ret[s[0]] === 'string') {
        ret[s[0]] = ret[s[0]].replace(/\?10000skip(=true)?/, '');
      }
    }

    return ret;
  }();

  this.file = (a.pathname.match(/\/([^/?#]+)$/i) || ['', ''])[1];
  this.hash = a.hash.replace('#', '');
  this.path = a.pathname.replace(/^([^/])/, '/$1');
  this.relative = (a.href.match(/tps?:\/\/[^/]+(.+)/) || ['', ''])[1];
  this.segments = a.pathname.replace(/^\//, '').split('/');

  this.isUrl = function (url) {
    var regular = /^\b(((https?|ftp):\/\/)?[-a-z0-9]+(\.[-a-z0-9]+)*\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]\d)|\d))\b(\/[-a-z0-9_:@&?=+,.!/~%$]*)?)$/i;
    return !!regular.test(url);
  }(this.source);

  this.route = this.hash ? Url(this.hash) : {};
  return this;
};

Url.prototype.Init.prototype = Url.prototype;

Url.prototype.replace = function () {
  var key;
  var argc = arguments[0];
  var i;
  var l;
  var t;
  var search = [];

  switch (_typeof(argc)) {
    case 'string':
      for (i = 0, l = arguments.length; i < l; i++) {
        t = arguments[i];

        if (typeof t === 'string') {
          delete this.params[t];
        }
      }

      break;

    case 'object':
      for (key in argc) {
        if (argc.hasOwnProperty(key)) {
          this.params[key] = argc[key];
        }
      }

      break;
  }

  for (key in this.params) {
    if (this.params.hasOwnProperty(key)) {
      search.push(key + '=' + this.params[key]);
    }
  }

  this.query = search.length ? '?' + search.join('&') : '';
  history.replaceState(null, '', this.pack());
  return this;
};

Url.prototype.replaceHash = function () {
  var _this = this;

  var search = [];

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  _$1.forEach(args, function (item) {
    switch (_typeof(item)) {
      case 'string':
        delete _this.route.params[item];
        break;

      case 'object':
        for (var key in item) {
          if (item.hasOwnProperty(key)) {
            _this.route.params[key] = item[key];
          }
        }

        break;
    }
  });

  _$1.forEach(this.route.params, function (value, key) {
    if (value !== null && value !== undefined) {
      search.push("".concat(key, "=").concat(value));
    }
  });

  this.hash = this.route.path + (search.length ? '?' + search.join('&') : '');
  history.replaceState(null, '', this.pack());
};

Url.prototype.push = function () {
  var key;
  var argc = arguments[0];
  var i;
  var l;
  var t;
  var search = [];

  switch (_typeof(argc)) {
    case 'string':
      for (i = 0, l = arguments.length; i < l; i++) {
        t = arguments[i];

        if (typeof t === 'string') {
          delete this.params[t];
        }
      }

      break;

    case 'object':
      for (key in argc) {
        if (argc.hasOwnProperty(key)) {
          this.params[key] = argc[key];
        }
      }

      break;
  }

  for (key in this.params) {
    if (this.params.hasOwnProperty(key)) {
      search.push(key + '=' + this.params[key]);
    }
  }

  this.query = search.length ? '?' + search.join('&') : '';
  location.href = this.pack();
};

Url.prototype.pack = function () {
  return this.protocol + '://' + this.host + (!this.port || this.port === '80' ? '' : ':' + this.port) + this.path + this.query + (this.hash ? '#' + this.hash : '');
};

Url.prototype.Init.call(Url);

function copy(str) {
  var el = document.createElement('textarea');
  el.value = str;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  el.style.top = '-9999px';
  document.body.appendChild(el);
  var selected = document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);

  if (selected) {
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(selected);
  }
}

function enterFullScreen() {
  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;

  for (var _i = 0, _arr = ['requestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen', 'webkitRequestFullscreen']; _i < _arr.length; _i++) {
    var methodName = _arr[_i];

    if (element[methodName]) {
      element[methodName]();
      break;
    }
  }
}

function exitFullScreen() {
  for (var _i2 = 0, _arr2 = ['exitFullscreen', 'msExitFullscreen', 'mozCancelFullScreen', 'webkitExitFullscreen']; _i2 < _arr2.length; _i2++) {
    var methodName = _arr2[_i2];

    if (document[methodName]) {
      document[methodName]();
      break;
    }
  }
}

function fullScreen() {
  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;

  if (_$1.isBoolean(element)) {
    element ? enterFullScreen() : exitFullScreen();
  } else if (_$1.isElement(element)) {
    enterFullScreen(element);
  }
}

var isTimeStr = function isTimeStr() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return /^\d+(s|m|h|d|y)?$/.test(str);
};
var formatTimeStr = function formatTimeStr() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  if (!isTimeStr(str)) {
    return 0;
  }

  var num = Number(str.match(/\d+/)[0]);

  if (/s$/.test(str)) {
    return num * 1000;
  } else if (/m$/.test(str)) {
    return num * 60 * 1000;
  } else if (/h$/.test(str)) {
    return num * 60 * 60 * 1000;
  } else if (/d$/.test(str)) {
    return num * 24 * 60 * 60 * 1000;
  } else if (/y$/.test(str)) {
    return num * 365 * 24 * 60 * 60 * 1000;
  } else {
    return num;
  }
};
// /**
//  * @method  sortBy
//  * @param   array   {Array}
//  * @param   condition   {Array|Function}
//  * @desc    对 json 数组多条件排序，只针对所有条件为同一级别，若 json 对象不存在该属性则默认值为 0
//  * @example
//  * var a = [{a:1,b:2,c:3,d:2}
//     , {a:2,b:1,c:3}
//     , {a:0, b:1,c:1}
//     , {a:1,b:1,c:3,d:1}
//     , {a:1, b:1,c: 1}
//     ]
//     sortBy(a, ['a', 'c'])
//  * */
// export let sortBy = (array, condition) => {
//
//     if( Array.isArray( array ) ){
//         if( condition ){
//             if( typeof condition === 'function' ){
//                 array.sort( condition );
//             }
//             else if( Array.isArray( condition ) ){
//                 array.sort((a, b) => {
//                     let t = condition[0]
//                         , i = 1
//                         , l = condition.length
//                         , rs = a[t] - b[t]
//                         ;
//
//                     if( rs === 0 ){
//                         for(; i < l; i++ ){
//                             t = condition[i];
//                             rs = (a[t] || 0) - (b[t] || 0);
//
//                             if( rs !== 0 ){
//                                 break;
//                             }
//                         }
//                     }
//
//                     return rs;
//                 });
//             }
//         }
//     }
//     return array;
// };

var pluses = /\+/g;

function encode(s) {
  return config.raw ? s : encodeURIComponent(s);
}

function decode(s) {
  return config.raw ? s : decodeURIComponent(s);
}

function stringifyCookieValue(value) {
  return encode(config.json ? JSON.stringify(value) : String(value));
}

function parseCookieValue(s) {
  if (s.indexOf('"') === 0) {
    // This is a quoted cookie as according to RFC2068, unescape...
    s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
  }

  try {
    // Replace server-side written pluses with spaces.
    // If we can't decode the cookie, ignore it, it's unusable.
    // If we can't parse the cookie, ignore it, it's unusable.
    s = decodeURIComponent(s.replace(pluses, ' '));
    return config.json ? JSON.parse(s) : s;
  } catch (e) {}
}

function read(s, converter) {
  var value = config.raw ? s : parseCookieValue(s);
  return isFunction(converter) ? converter(value) : value;
}

var config = function config(key, value, options) {
  // Write
  if (value !== undefined && !isFunction(value)) {
    options = Object.assign({}, config.defaults, options);

    if (typeof options.expires === 'number') {
      var days = options.expires;
      var t = options.expires = new Date();
      t.setTime(+t + days * 864e+5);
    }

    return document.cookie = [encode(key), '=', stringifyCookieValue(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
    options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join('');
  } // Read


  var result = key ? undefined : {}; // To prevent the for loop in the first place assign an empty array
  // in case there are no cookies at all. Also prevents odd result when
  // calling $.cookie().

  var cookies = document.cookie ? document.cookie.split('; ') : [];

  for (var i = 0, l = cookies.length; i < l; i++) {
    var parts = cookies[i].split('=');
    var name = decode(parts.shift());

    var _cookie = parts.join('=');

    if (key && key === name) {
      // If second argument (value) is a function it's a converter...
      result = read(_cookie, value); // break;
    } // Prevent storing a cookie that we couldn't decode.


    if (!key && (_cookie = read(_cookie)) !== undefined) {
      result[name] = _cookie;
    }
  }

  return result;
};

config.defaults = {};

var removeCookie = function removeCookie(key, options) {
  if (cookie(key) === undefined) {
    return false;
  } // Must not alter options, thus extending a fresh object...


  cookie(key, '', Object.assign({}, options, {
    expires: -1
  }));
  return !cookie(key);
};
/* ---------- copy jquery.cookie end---------------- */


var cookie = function cookie() {
  if (arguments[2] && isObject$1(arguments[2])) {
    if (isTimeStr(arguments[2]['expires'])) {
      arguments[2]['expires'] = new Date(new Date().getTime() + formatTimeStr(arguments[2]['expires']));
    }
  }

  return config.apply(this, arguments);
};

cookie.remove = function () {
  return removeCookie.apply(this, arguments);
};

/**
 * Created by chenqifeng on 2016/8/26.
 */
var sessionStorage$1 = window.sessionStorage && window.sessionStorage.setItem && typeof window.sessionStorage.setItem === 'function';
var localStorage$1 = window.localStorage && window.localStorage.setItem && typeof window.localStorage.setItem === 'function';

var sessionKey = 'tg_local_cache';
var cache = localStorage$1 ? localStorage : false;
var data$1 = localStorage$1 ? JSON.parse(cache.getItem(sessionKey) || JSON.stringify({})) : {};

var formatData$1 = function formatData() {
  var d = {};
  var t = new Date().getTime();

  for (var i in data$1) {
    if (t - data$1[i].t < data$1[i].time || !data$1[i].time) {
      d[i] = data$1[i].value;
    }
  }

  return d;
};

var localData = function localData() {
  var length = arguments.length;
  var d = {};
  var t = new Date().getTime();

  if (!length) {
    return formatData$1();
  } else if (length === 1) {
    if (isObject$1(arguments[0])) {
      for (var i in arguments[0]) {
        if (arguments[0].hasOwnProperty(i)) {
          d[i] = {
            value: arguments[0][i],
            time: 0,
            t: t
          };
        }
      }

      data$1 = Object.assign({}, data$1, d);
      cache && cache.setItem(sessionKey, JSON.stringify(data$1));
    } else {
      return formatData$1()[arguments[0]];
    }
  } else if (length === 2) {
    if (isObject$1(arguments[0]) && isTimeStr(arguments[1])) {
      for (var _i in arguments[0]) {
        if (arguments[0].hasOwnProperty(_i)) {
          d[_i] = {
            value: arguments[0][_i],
            time: formatTimeStr(arguments[1]),
            t: t
          };
        }
      }

      data$1 = Object.assign({}, data$1, d);
    } else {
      data$1[arguments[0]] = {
        value: arguments[1],
        time: 0,
        t: t
      };
    }

    cache && cache.setItem(sessionKey, JSON.stringify(data$1));
  } else if (length === 3) {
    d[arguments[0]] = {
      value: arguments[1],
      time: formatTimeStr(arguments[2]),
      t: t
    };
    data$1 = Object.assign({}, data$1, d);
    cache && cache.setItem(sessionKey, JSON.stringify(data$1));
  }
};

localData.remove = function (key) {
  var length = arguments.length;

  if (!length) {
    this.removeAll();
  } else {
    for (var i = 0; i < length; i++) {
      data$1[arguments[i]] = undefined;
      delete data$1[arguments[i]];
    }

    cache && cache.setItem(sessionKey, JSON.stringify(data$1));
  }
};

localData.removeAll = function () {
  data$1 = {};
  cache && cache.setItem(sessionKey, JSON.stringify(data$1));
};

var sessionKey$1 = 'tg_session_cache';
var cache$1 = sessionStorage$1 ? sessionStorage : false;
var data$2 = sessionStorage$1 ? JSON.parse(cache$1.getItem(sessionKey$1) || JSON.stringify({})) : {};

var sessionData = function sessionData() {
  var length = arguments.length;

  if (!length) {
    return data$2;
  } else if (length === 1) {
    if (isObject$1(arguments[0])) {
      data$2 = Object.assign({}, data$2, arguments[0]);
      cache$1 && cache$1.setItem(sessionKey$1, JSON.stringify(data$2));
    } else {
      return data$2[arguments[0]];
    }
  } else if (length === 2) {
    data$2[arguments[0]] = arguments[1];
    cache$1 && cache$1.setItem(sessionKey$1, JSON.stringify(data$2));
  }
};

sessionData.remove = function (key) {
  var length = arguments.length;

  if (!length) {
    this.removeAll();
  } else {
    for (var i = 0; i < length; i++) {
      data$2[arguments[i]] = undefined;
      delete data$2[arguments[i]];
    }

    cache$1 && cache$1.setItem(sessionKey$1, JSON.stringify(data$2));
  }
};

sessionData.removeAll = function () {
  data$2 = {};
  cache$1 && cache$1.setItem(sessionKey$1, JSON.stringify(data$2));
};

var methods = {
  device: device,
  isInView: isInView,
  ready: ready,
  load: load,
  log: log,
  scrollBar: scrollBar,
  shake: shake,
  style: style,
  time: dayjs_min,
  url: Url,
  copy: copy,
  fullScreen: fullScreen,
  cookie: cookie,
  localData: localData,
  sessionData: sessionData
};

function Maple() {
  return new Maple.prototype.Init();
}

Maple.prototype.Init = function () {};

Maple.prototype.Init.prototype = Maple.prototype;

var install = function install(Vue) {
  if (install.installed) return;

  _$1.forEach(components$1, function (component) {
    return component.install(Vue, Maple);
  });

  _$1.forEach(components$2, function (component) {
    return component.install(Vue);
  });

  _$1.assign(Maple, methods);
};

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  window.maple = Maple;
}

if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var index$1 = _$1.assign({}, {
  install: install
}, components$1);

export default index$1;
